#+TITLE: Podcast Database
#+AUTHOR: Martín Alsinet
#+DATE: 2019
#+OPTIONS: ^:nil num:nil ':t
#+LANGUAGE: es
#+PROPERTY: header-args:python :python python-3.6 :results output drawer :mkdirp yes
#+PROPERTY: header-args:sh :results raw drawer
#+TODO: TODO DOING | DONE

* Motivación

Me gusta escuchar podcasts de [[https://franceinter.fr][France Inter]] cuando salgo a caminar, y en su momento me armé un script que me genera los links para descargar los episodios usando cURL.

Quiero mejorar ese script y transformarlo en una aplicación que me permita buscar podcasts, generar una base de datos con podcasts de distintas fuentes (p.ej. YouTube) y armar una cola de descargas.

Además, me gustaría usar este proyecto para probar dos enfoques de programación que me están interesando últimamente:

- [[http://www.literateprogramming.com/][Literate Programming]] :: Es una manera de programar en la que el código de la aplicación es un subproducto del documento que explica cómo está hecha

- [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]] :: En este libro se define una receta para la construcción de programas en forma iterativa usando el paradigma de programación funcional

** Literate Programming

Para escribir este documento estoy usando [[https://www.gnu.org/software/emacs][Emacs]] y [[https://orgmode.org][Org mode]], que es un modo de Emacs que tiene funcionalidades para literate programming.

La idea de la programación literaria consiste en que el código fuente de la aplicación sale de la documentación. Esto quiere decir que para poder generar un ejecutable (un /build/) de una aplicación hecha "literariamente" es necesario procesar la documentación, extraer de ella los fragmentos de código fuente que constituyen la aplicación (en org-mode este proceso se denomina /tangle/) y luego generar el ejecutable correspondiente con ese código.

En nuestro caso, la documentación a procesar es /este documento/. Todo el código fuente de la aplicación está contenido en este documento, dentro de los fragmentos de código delimitados por las etiquetas =#+begin_src= y =#+end_src=. Los bloques de código que tienen el parámetro =:tangle path/to/file= en el tag de inicio son exportados al archivo que indica el path. De esta manera, podemos generar todos los archivos del código fuente de la aplicación /tangleando/ la documentación. El comando =org-babel-tangle= dispara la generación de los archivos en cualquier momento.

El hecho de generar el código fuente desde este documento permite que no sea necesario guardarlo en el repositorio. Cada vez que es necesario ejecutar la aplicación, o generar un build para una versión determinada, se exporta el código fuente desde este documento. Como podemos ver usando el comando =git ls-tree=, los únicos archivos que están comiteados en el repositorio son el =.gitignore= y =podcast-db.org= (este archivo). El archivo =README.org= es un link simbólico a =podcast-db.org= para que aparezca como índice en github.

#+begin_src sh
# listar los archivos comiteados en el repositorio
git ls-tree --full-tree -r --name-only HEAD
#+end_src

#+RESULTS:
:results:
.gitignore
README.org
podcast-db.org
:end:

*** ¿Y qué hago si no sé (o no quiero) usar emacs?

Dado que el código fuente está en este documento, para poder obtener los fuentes es necesario procesarlo (tanglearlo) con emacs. Así, podemos extraer el código de la aplicación desde el documento y ejecutarlo como haríamos con cualquier otro programa. 

Vamos a usar [[https://www.docker.com/][Docker]] para bajar una imagen de Emacs y usar esa imagen para tanglear nuestro documento. 

#+begin_src sh :eval never
# descarga la imagen de emacs
docker pull silex/emacs:26-alpine

# lanza emacs en modo batch, 
# carga el archivo ./podcast-db.org del directorio actual,
# y ejecuta org-babel tangle
docker run --rm -i -v $(pwd):/app -w /app silex/emacs:26-alpine emacs --batch -l org podcast-db.org -f org-babel-tangle
#+end_src

Vemos que los fuentes se generan en la carpeta =franceinter=

#+begin_src sh :eval never
find ./franceinter
#+end_src

En teoría podríamos modificar el documento con otro editor de texto y regenerar los fuentes usando este método luego de editarlo, pero el procedimiento sería demasiado engorroso como para usarlo en la práctica.

** How to Design Programs

La otra fuente de inspiración para la metodología utilizada en este proyecto es el libro [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]]. Hay un video---[[https://media.ccc.de/v/35c3-9800-how_to_teach_programming_to_your_loved_ones][How to teach programming to your loved ones]]---en el que Mike Sperber explica la técnica utilizada para construir programas que se describe en el libro.

La idea es desarrollar una aplicación a partir de funciones elementales que se usan como piezas para ir armando componentes más complejos. El libro ofrece una receta para elaborar una función, que es la unidad mínima de código recomendada. Vamos a escribir cada una de las funciones de nuestra aplicación de acuerdo a los pasos de la siguiente receta:

- 1. Objetivo :: Identificar brevemente el propósito de la función. Nombrar las estructuras de datos que va a manipular
- 2. Firma :: Definir formalmente los parámetros de entrada y la salida de la función
- 3. Ejemplos :: Confeccionar un listado de ejemplos de parámetros de entrada que podría recibir la función y analizar cuál debería ser la salida para cada uno
- 4. Boceto :: Traducir la firma de la función en un boceto de la implementación
- 5. Definición :: Completar el boceto teniendo en cuenta el análisis y los ejemplos para lograr cumplir el propósito de la función
- 6. Casos de prueba :: Transformar los ejemplos en casos de prueba y asegurarse de que la función los pase a todos

En este caso, vamos a desarrollar nuestra aplicación en el lenguaje [[https://python.org][Python]] usando el paradigma de programación funcional. Esto quiere decir que nuestra aplicación va a estar mayormente compuesta de funciones (=def my_func():=) que vamos a ir combinando para realizar tareas complejas.

* Diseño
** Fuentes de podcasts

Quiero que mi base de datos pueda consultar las siguientes fuentes de podcasts:

- FranceInter
- FranceCulture
- RFI
- Youtube
- PBS
- BBC
- Team Human
- Radiolab

** Funcionalidades

- Listar las fuentes de podcasts disponibles
- Listar los podcasts de un fuente
- Listar los episodios de un podcast
- Obtener el detalle de un episodio
- Filtrar los episodios de un podcast según algún criterio (año, mes, palabra clave)
- Generar una playlist o feed RSS de los episodios filtrados
- Crear una cola de descarga a partir de una playlist
- Procesar los archivos descargados (p.ej, cambiar el bitrate a 64k)

* Setup
*** .gitignore

#+begin_src text :tangle .gitignore
.DS_Store
.pytest_cache
__pycache__
.coverage
coverage
downloads
franceinter
requirements.txt
utils
venv
#+end_src

*** Dependencias

Vamos a usar las siguientes bibliotecas

- requests :: Para realizar las peticiones http
- requests-cache :: Para cachear las peticiones http
- beautifulsoup4 :: Para parsear html
- slugify :: Para generar el nombre del archivo a descargar
- pytest :: Para ejecutar los casos de prueba
- pytest-cov :: Para generar el reporte de cobertura de tests
- validators :: Para validar URLs

**** TODO evaluar [[https://html.python-requests.org/][Requests-HTML]]

Parece que sería una alternativa interesante a BeautifulSoup4. 

Ventajas:

- Automatic following of redirects
- Pagination support
- Mocked user-agent (like a real web browser)

Desventajas:

- Solamente funciona con Python >= 3.6
- Tiene apenas un año de desarrollo (bs4 está /battle-tested/)
- Depende de muchos módulos (bloated?)

*** requirements.txt

#+begin_src txt :tangle requirements.txt
beautifulsoup4
slugify
requests
requests-cache
pytest
pytest-cov
validators
#+end_src

*** Instalación de dependencias
**** 1. Inicializar la carpeta =./venv=

#+begin_src sh
rm -Rf ./venv
virtualenv-3.6 ./venv
#+end_src

**** 2. Instalar dependencias con =pip=

#+begin_src sh
pip-3.6 install -r requirements.txt
#+end_src

* France Inter
** Submódulos

Vamos a organizar el código en paquetes (carpetas), lo que nos permite usar namespaces para importar las funcionalidades. Para ello, necesitamos crear un archivo =__init__.py= en cada carpeta para declarar los módulos que forman parte nuestro paquete y que Python pueda encontrarlos cuando los referenciamos en el =import=.

El módulo actual es =franceinter=, y que tiene los siguientes submódulos:

- podcasts
- episodes

#+begin_src python :tangle franceinter/__init__.py
__all__ = ["podcasts", "episodes"]
#+end_src

#+begin_src python :tangle franceinter/podcasts/__init__.py
__all__ = [
    "author_from_tag", 
    "title_from_tag", 
    "url_from_tag", 
    "podcast_from_tag", 
    "tags_from_html", 
    "podcasts_from_tags", 
    "podcasts_from_response", 
    "podcasts_from_url", 
    "podcasts_from_filename", 
    "podcasts_from_query",
    "podcast"
]
#+end_src

#+begin_src python :tangle franceinter/podcasts/tests/__init__.py
__all__ = [
    "test_author_from_tag", 
    "test_title_from_tag", 
    "test_url_from_tag", 
    "test_podcast_from_tag", 
    "test_tags_from_html", 
    "test_podcasts_from_tags", 
    "test_podcasts_from_response", 
    "test_podcasts_from_url", 
    "test_podcasts_from_filename", 
    "test_podcasts_from_query",
    "examples_author_from_tag", 
    "examples_title_from_tag",
    "examples_url_from_tag",
    "examples_podcast_from_tag",
    "examples_tags_from_html",
    "examples_podcasts_from_tags",
    "examples_podcasts_from_response",
    "examples_podcasts_from_url",
    "examples_podcasts_from_filename",
    "examples_podcasts_from_query"
]
#+end_src

** Podcasts

France Inter publica en una sola página (enorme) el listado de todas sus emisiones. El html está bastante fácil de parsear, dado que los datos cada emisión se encuentran dentro de un =div= con la clase =rich-section-list-item-content=. Revisando el contenido de ese div, podemos obtener el título del podcast, su URL y el autor (que es opcional).

**** Wishlist

- [X] Obtener el listado de los podcasts de France Inter
- [X] Para cada podcast obtener el nombre, el url y el autor
- [ ] Filtrar el listado de podcasts por una palabra clave

**** Mejoras a futuro

- [ ] =podcasts_from_filename= :: Se podrían matchear los errores de lectura del archivo con los códigos de la respuesta HTTP (404 si no se encuentra, 500 si hubo un error de I/O, etc)

*** title_from_tag
**** 1. Objetivo

Obtener el título del podcast de un fragmento de html.

El título se encuentra en el atributo =title= de un =<a>= que tiene la clase =rich-section-list-item-content-title=

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, Un tag que contiene un =<a>= con la clase correcta y el atributo =title=
- Un tag que no tiene el =<a>=
- Un tag que tiene el =<a>= pero éste no tiene la clase =rich-section...=
- Un tag que tiene el =<a>= pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_title_from_tag.py
from bs4 import BeautifulSoup

def tag_with_title():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    title="Sur les epaules de Darwin">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a title="Sur les epaules de Darwin">
</a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    title="Sur les epaules de Darwin">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def author_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    title = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable title
    return title
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/title_from_tag.py
import bs4

def title_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "title" in link.attrs:
        title = link.attrs["title"]
    return title

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el título
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene la clase correcta, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_title_from_tag.py
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

def test_author_ok():
    tag = tag_with_title()
    assert ("Sur les epaules de Darwin" == title_from_tag(tag))

def test_invalid_tag():
    try:
        title_from_tag(5)
    except AssertionError:
        assert(True)

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == title_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == title_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == title_from_tag(tag))

#+end_src

#+begin_src python
from bs4 import BeautifulSoup
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

tag = tag_with_title()
title = title_from_tag(tag)
print(title)
#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_title_from_tag.py
#+end_src

*** url_from_tag
**** 1. Objetivo

Obtener el URL del podcast de un fragmento de html.

El URL se encuentra en el atributo =href= de un tag =<a>= que tiene la clase =rich-section-list-item-content-title=. 

El URL es relativo, por lo que hay que agregarle baseUrl de France Inter (https://www.franceinter.fr).

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag que contiene un =<a>= con la clase =rich-section-list-item-content-title= y el atributo =href=
- Un tag que no tiene el =<a>=
- Un tag que tiene el =<a>= pero el link no tiene clase
- Un tag que tiene el =<a>= pero el link no tiene el atributo =href=

#+begin_src python :tangle franceinter/podcasts/tests/examples_url_from_tag.py
from bs4 import BeautifulSoup

def tag_with_url():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</p>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a href="emissions/la-tete-au-carre"></a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_href():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def url_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    url = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el <a> hay que revisar si tiene el atributo href
    # si tiene el atributo href 
    #     - se le agrega "https://www.franceinter.fr/" adelante
    #     - se guarda en la variable url
    return url
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/url_from_tag.py
import bs4

def url_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    url = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "href" in link.attrs:
        url = "https://www.franceinter.fr/" + link.attrs["href"]
    return url

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el url
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene la clase buscada, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene el atributo =href=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_url_from_tag.py
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.tests.examples_url_from_tag import *

def test_url_ok():
    tag = tag_with_url()
    url = "https://www.franceinter.fr/emissions/la-tete-au-carre"
    assert (url == url_from_tag(tag))

def test_invalid_tag():
    try:
        url_from_tag(5)
    except AssertionError:
        assert(True)

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == url_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == url_from_tag(tag))

def test_title_not_found():
    tag = tag_without_href()
    assert ("" == url_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_url_from_tag.py
#+end_src

*** author_from_tag
**** 1. Objetivo

Obtener el autor del podcast de un fragmento de html. 

El autor se encuentra en el atributo =title= de un =<a>= que está dentro de un =<span>= que tiene la clase =rich-section-list-item-content-infos-author=

**** 2. Firma

La funcion recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, el tag tiene un =<span>= con la clase =rich-section-list-item-content-infos-author= que contiene un =<a>= con el atributo =title=
- El tag no tiene un =<span>=
- El tag tiene un =<span>=, pero éste no tiene un =<a>=
- El tag tiene un =<span>= que contiene un =<a>=, pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_author_from_tag.py
from bs4 import BeautifulSoup

def tag_with_author():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a title="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_span():
    html = '''<div class="boldest">
Extremely bold
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<p title="William Shakespeare"></p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a subtitle="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

#+RESULTS:
:results:
True
:end:

**** 4. Boceto

#+begin_src python

def author_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    author = ""
    # hay que buscar un span con la clase "rich-section..."
    # si existe el span hay que buscar un a
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable author
    return author
    
#+end_src

#+RESULTS:
:results:
None
:end:

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/author_from_tag.py
import bs4

def author_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    cls = "rich-section-list-item-content-infos-author"
    span = tag.find("span", class_=cls)
    author = ""
    if span:
        link = span.find("a")
        if link and "title" in link.attrs:
            author = link.attrs["title"]
    return author

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el autor
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no tiene un tag =<span>= con la clase buscada, devuelve un string vacío
- Cuando recibe un tag que tiene el =<span>= pero éste no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<span>= y el =<a>= pero éste último no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_author_from_tag.py
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.tests.examples_author_from_tag import *

def test_author_ok():
    tag = tag_with_author()
    assert ("William Shakespeare" == author_from_tag(tag))

def test_invalid_tag():
    try:
        author_from_tag(5)
    except AssertionError:
        assert True

def test_span_not_found():
    tag = tag_without_span()
    assert ("" == author_from_tag(tag))

def test_a_not_found():
    tag = tag_without_link()
    assert ("" == author_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == author_from_tag(tag))

#+end_src

#+RESULTS:
:results:
None
:end:

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_author_from_tag.py
#+end_src

*** podcast_from_tag
**** 1. Objetivo

Obtener un podcast de un fragmento de html.

Un podcast tiene tres propiedades, a saber:

- título :: es un =str= y es obligatorio
- url :: es un =str=, es obligatorio y debe ser un URL válido
- autor :: es un =str=, pero puede estar vacío

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un objeto =franceinter.podcasts.podcast=

Necesitamos entonces definir la clase =podcast=

#+begin_src python :tangle franceinter/podcasts/podcast.py

class Podcast:
    def __init__(self, title, url, author=""):
        self.title = title
        self.url = url
        self.author = author

    def __repr__(self):
        return "Podcast(title='%s', url='%s')" % (self.title, self.url)

#+end_src

**** 3. Ejemplos

- Un tag que tiene todos los elementos para generar un podcast válido (título, URL y autor)
- Un tag que no es un =bs4.element.Tag=
- Un tag que no tiene el elemento del título
- Un tag que no tiene el elemento del URL
- Un tag que tiene el elemento del URL, pero el URL no es válido
- Un tag que no tiene el elemento del autor

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcast_from_tag.py
from bs4 import BeautifulSoup

def tag_ok():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def invalid_tag():
    return "I am not a tag"

def tag_without_title():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_with_invalid_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="this://isnot[?=>avalid[[/\\url"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_author():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def podcast_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag

    # extraer el título con title_from_tag
    # validar que el título no sea un string vacío

    # extraer el url con url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer el autor usando author_from_tag

    # crear una instancia de franceinter.podcasts.podcast
    # con el título, el url y el autor
    return podcast

#+end_src

**** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceinter/podcasts/podcast_from_tag.py
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.podcast import Podcast
from validators.url import url as is_valid_url
import bs4

def podcast_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = title_from_tag(tag)
    assert (title != ""), no_title(tag)

    url = url_from_tag(tag)
    assert (url != ""), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)

    author = author_from_tag(tag)

    return Podcast(title, url, author)

def no_url(tag):
    return "received tag does not have a podcast URL\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid podcast URL\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have a podcast title\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve un podcast
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no tiene título, lanza un =AssertionError=
- Cuando recibe un tag que no tiene url, lanza un =AssertionError=
- Cuando recibe un tag que tiene un url pero es inválido, lanza un =AssertionError=
- Cuando recibe un tag que no tiene autor, devuelve un podcast con un =str= vacío en la propiedad author

#+begin_src python :tangle franceinter/podcasts/tests/test_podcast_from_tag.py
from franceinter.podcasts import podcast
from franceinter.podcasts.podcast_from_tag import podcast_from_tag
from franceinter.podcasts.tests.examples_podcast_from_tag import *

def test_podcast_ok():
    tag = tag_ok()
    podcast = podcast_from_tag(tag)
    assert (len(podcast.title) > 0)
    assert (len(podcast.url) > 0)
    assert (len(podcast.author) >0)
    assert (len(str(podcast)) > 0)

def test_podcast_without_title():
    tag = tag_without_title()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_url():
    tag = tag_without_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    tag = tag_with_invalid_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_author():
    tag = tag_without_author()
    podcast = podcast_from_tag(tag)
    assert len(podcast.title) > 0
    assert len(podcast.url) > 0
    assert len(podcast.author) == 0

def test_invalid_tag():
    tag = invalid_tag()
    try:
        podcast_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcast_from_tag.py
#+end_src

*** tags_from_html
**** 1. Objetivo

Obtener un array de tags con el fragmento de html que tiene el detalle del podcast (título, URL y autor) a partir del html de la página con el listado de podcasts

Hay que extraer todos los =<div>= que tengan la clase =rich-section-list-item-content=

**** 2. Firma

La función recibe un =str= con el html de la página y devuelve un =GeneratorType= de elementos =bs4.element.Tag=

**** 3. Ejemplos

- Un html que tiene varios =<div>= con la clase buscada
- Un html que no es un =str=
- Un html que no tiene ningún =<div>=
- Un html que tiene varios =<div>= pero que ninguno tenga la clase =rich-section-list-item-content=
- Un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen

#+begin_src python :tangle franceinter/podcasts/tests/examples_tags_from_html.py
from bs4 import BeautifulSoup
from random import shuffle

def html_with_divs(how_many):
    class_name = "rich-section-list-item-content"
    divs = map(lambda x: div(class_name), range(how_many))
    return html(divs)

def html_is_not_string():
    return 42

def html_without_divs():
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>'''
    return html

def html_divs_without_class(how_many):
    divs = map(lambda x: div(), range(how_many))
    return html(divs)

def html_some_divs_with_class(how_many_with, how_many_without):
    class_name = "rich-section-list-item-content"
    divs_with = list(map(lambda x: div(class_name), range(how_many_with)))
    divs_without = list(map(lambda x: div(), range(how_many_without)))
    divs = divs_with + divs_without
    shuffle(divs)
    return html(divs)

def div(class_name=""):
    attr = ""
    if class_name:
        attr = "class=%s" % class_name
    html = '''<div %s>
    here goes the div body
</div>''' % attr
    soup = BeautifulSoup(html, "html.parser")
    return soup.div

def html(divs):
    div_str = "".join(map(lambda div: str(div), divs))
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
%s
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    ''' % div_str
    return html
    
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup

def tags_from_html(html):
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # filtrar los tag <div> que tienen la clase "rich-section-list-item-content"
    return tags

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/tags_from_html.py
from bs4 import BeautifulSoup

def tags_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    cls = "rich-section-list-item-content"
    tags = soup.find_all("div", class_=cls)
    for tag in tags:
        yield tag

def invalid_html(html):
    return "html parameter must be a string, received %s instead" % type(html)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un html que tiene varios =<div>= con la clase buscada, devuelve un =GeneratorType= de tantos elementos como =<div>= hay en el html
- Cuando recibe un html que no es un string, lanza un =AssertionError=
- Cuando recibe un html que no tiene ningún =<div>=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene varios =<div>= pero ninguno tiene la clase =rich-section-list-item-content=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen, devuelve un =GeneratorType= con solamente los =<div>= que tienen la clase

#+begin_src python :tangle franceinter/podcasts/tests/test_tags_from_html.py
import types
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *

def test_html_with_divs():
    html = html_with_divs(5)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 5)

def test_html_is_not_string():
    try:
        html = html_is_not_string()
        tags = list(tags_from_html(html))
    except AssertionError:
        assert True

def test_html_without_divs():
    html = html_without_divs()
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_divs_without_class():
    html = html_divs_without_class(4)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_some_divs_with_class():
    html = html_some_divs_with_class(2,3)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 2)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_tags_from_html.py
#+end_src

*** podcasts_from_tags
**** 1. Objetivo

Generar un listado de podcasts a partir de un listado de fragmentos de HTML tomados de la página

**** 2. Firma

La función recibe un listado de objetos =bs4.element.Tag= y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

Vamos a aceptar tanto un =list= como un =GeneratorType=

**** 3. Ejemplos

- Un objeto que no es iterable
- Una lista vacía
- Una lista con tags válidos
- Una lista con objetos que no son del tipo =bs4.element.Tag=
- Una lista con tags válidos y un tag inválido (sin el título o el URL)

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_tags.py
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *
from franceinter.podcasts.tests.examples_podcast_from_tag import (
    tag_ok, 
    tag_without_url
)

def invalid_list():
    return 123

def empty_list():
    return []

def list_without_tags():
    return [1, 2, 3, 4, 5]

def list_with_valid_tags(how_many):
    html = ""
    for item in range(1, how_many):
        html+= str(tag_ok())
    tags = tags_from_html(html)
    return tags

def list_with_invalid_tag(how_many):
    tags = list(list_with_valid_tags(how_many - 1))
    tags+= tag_without_url()
    return tags

#+end_src

**** 4. Boceto

#+begin_src python
from franceinter.podcasts.tags_from_html import tags_from_html

def podcasts_from_tags(tags):
    # validar que tags sea un GeneratorType
    # para cada tag de la lista
    # usar podcast_from_tag() para obtener un podcast
    # yield posdcast

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_tags.py
from franceinter.podcasts.podcast_from_tag import podcast_from_tag

def podcasts_from_tags(tags):
    try:
        it = iter(tags)
    except TypeError:
        assert False, invalid_tags(tags)
    for tag in tags:
        yield podcast_from_tag(tag)

def invalid_tags(tags):
    return "tags parameter must be iterable, received %s instead" % type(tags)
#+end_src

**** 6. Casos de prueba

- Si recibe un objeto que no es iterable, lanza un =AssertionError=
- Si recibe una lista vacía, devuelve un =GeneratorType= vacío
- Si recibe una lista de tags válidos, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Si recibe una lista con objetos que no son del tipo =bs4.element.Tag=, lanza un =AssertionError=
- Si recibe una lista con algún tag inválido (que no tenga el título o el URL), lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_tags.py
import types
from franceinter.podcasts.podcasts_from_tags import podcasts_from_tags
from franceinter.podcasts.tests.examples_podcasts_from_tags import *
from franceinter.podcasts.podcast import Podcast

def test_invalid_list():
    tags = invalid_list()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_empty_list():
    tags = empty_list()
    podcasts = podcasts_from_tags(tags)
    assert isinstance(podcasts, types.GeneratorType)
    assert (len(list(podcasts))==0)

def test_list_with_valid_tags():
    tags = list_with_valid_tags(6)
    podcasts = podcasts_from_tags(tags)
    assert isinstance(podcasts, types.GeneratorType)
    for p in podcasts:
        assert (isinstance(p, Podcast))

def test_list_without_tags():
    tags = list_without_tags()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_list_with_invalid_tag():
    tags = list_with_invalid_tag(6)
    podcasts = podcasts_from_tags(tags)
    try:
        for p in podcasts:
            assert (isinstance(p, Podcast))
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_tags.py
#+end_src

*** podcasts_from_response
**** 1. Objetivo

Extraer el listado de podcasts de la respuesta de una petición HTTP

**** 2. Firma

La función recibe una =requests.model.Response= y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Una respuesta válida, con el HTML de la página del listado de podcasts
- Una respuesta inválida, que no es de la clase =requests.model.Response=
- Una respuesta válida, pero que tiene el HTML de otra página

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_response.py
from requests.models import Response

def response_ok():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/podcast-list-short.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

def invalid_response():
    return "i am not a Response"

def wrong_page_response():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/wrong-page.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

#+end_src

#+RESULTS:
:results:
:end:

**** 4. Boceto

#+begin_src python
import requests

def podcasts_from_response(resp):
    # validar la respuesta
    # obtener el HTML de resp.text
    # extraer los tags usando tags_from_html
    # obtener los podcasts usando podcasts_from_html

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_response.py
import requests
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.podcasts_from_tags import podcasts_from_tags

def podcasts_from_response(resp):
    assert isinstance(resp, requests.models.Response), invalid_type(resp)
    html = resp.text
    tags = tags_from_html(html)
    podcasts = podcasts_from_tags(tags)
    return podcasts
    
def invalid_type(resp):
    return "resp parameter must be a requests.models.Response, received %s instead" % type(resp)

#+end_src

**** 6. Casos de prueba

- Cuando recibe una respuesta válida, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Cuando recibe una respuesta que no es de la clase =requests.model.Response=, lanza un =AssertionError=
- Cuando recibe una respuesta válida que tiene el HTML de otra página, devuelve un =GeneratorType= vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_response.py
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_response import podcasts_from_response
from franceinter.podcasts.tests.examples_podcasts_from_response import *

def test_response_ok():
    resp = response_ok()
    podcasts = podcasts_from_response(resp)
    assert isinstance(podcasts, types.GeneratorType)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_invalid_response():
    resp = invalid_response()
    try:
        podcasts = podcasts_from_response(resp)
    except AssertionError:
        assert True
    
def test_wrong_page_response():
    resp = wrong_page_response()
    podcasts = podcasts_from_response(resp)
    assert isinstance(podcasts, types.GeneratorType)
    assert (len(list(podcasts)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_response.py
#+end_src

*** podcasts_from_url
**** 1. Objetivo

Extraer el listado de podcasts desde un URL

**** 2. Firma

La función recibe un URL y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Un URL con el listado de podcasts
- Un URL de otra página, que no tiene podcasts
- Un URL de una página inexistente, que dispare un error 404 (not found)
- Un URL de un sitio inexistente, que dispare un error de DNS
- Un URL inválido

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_url.py

def url_ok():
    url = "http://localhost:3000/podcast-list-short.html"
    return url

def wrong_page_url():
    url = "http://localhost:3000/wrong-page.html"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def wrong_site_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

def invalid_url():
    url = "ht pt:\\hostlocal:3000/this-url-is-not-valid.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_url(url):
    # validar el url
    # realizar una petición al url
    # obtener la respuesta del url
    # obtener los podcasts llamando a podcasts_from_url
    # revisar si da un error de conexión
    return podcasts

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_url.py
import requests
from validators.url import url as is_valid_url
from franceinter.podcasts.podcasts_from_response import podcasts_from_response

def podcasts_from_url(url):
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        podcasts = podcasts_from_response(response)
        return podcasts
    except requests.ConnectionError:
        assert False, connection_error(url)

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url
#+end_src

**** 6. Casos de prueba

Bueno, aquí tenemos un caso de prueba un poco más complejo que lo normal. Para poder testear nuestra función necesitamos realizar una petición HTTP. El problema es que no queremos depender de un sitio web externo, o de que haya conectividad a Internet cuando se ejecuten los casos de prueba. La solución es levantar un servidor HTTP desde una carpeta local y en nuestro caso vamos a usar los archivos HTML de ejemplo que tenemos en =franceinter/html=.

Ahora bien, necesitamos que el servidor HTTP esté levantado antes de correr nuestros casos de prueba y sería ideal poder bajarlo luego de ejecutar todos los tests que lo necesiten. Para ello vamos a usar un [[https://docs.pytest.org/en/latest/fixture.html][fixture]] (=@pytest.fixture=), que es una funcionalidad de pytest que permite que los casos de prueba reciban un argumento con algún recurso, en este caso, el servidor HTTP ya levantado y sirviendo los archivos desde la carpeta local.

El atributo ~scope="module"~ indica que el fixture =http_server= será invocado una sola vez por módulo, que es lo que queremos para que todos los tests de nuestra función compartan el mismo servidor HTTP y no tener que levantarlo y bajarlo para cada test. Cuando no se indica un =scope=, pytest invoca el fixture para cada caso de prueba.

Un fixture es una función común y corriente como cualquier otra, a la que pytest llama cuando comienza a procesar el módulo, se guarda el valor retornado, y se lo inyecta a los casos de prueba que declaren ese fixture como parámetro.

Nótese en el código del fixture =http_server= que se levanta el servidor HTTP en otro thread para no bloquear la ejecución de los tests y que se utiliza =yield= para poder bajar el servidor luego de su uso.

- Cuando recibe un URL con el listado de podcasts, devuelve un =GeneratorType= de objetos =Podcast=
- Cuando recibe un URL de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de una página inexistente, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de un sitio inexistente (error de DNS), lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_url.py
import pytest
import threading
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_url import podcasts_from_url
from franceinter.podcasts.tests.examples_podcasts_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = url_ok()
    gen = podcasts_from_url(url)
    assert isinstance(gen, types.GeneratorType)
    podcasts = list(gen)
    assert (len(podcasts) > 0)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_wrong_page_url(http_server):
    url = wrong_page_url()
    podcasts = list(podcasts_from_url(url))
    assert (len(podcasts) == 0)

def test_not_found_url(http_server):
    url = not_found_url()
    podcasts = list(podcasts_from_url(url))
    assert (len(podcasts) == 0)

@pytest.mark.skip(reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = wrong_site_url()
    try:
        podcasts = list(podcasts_from_url(url))
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        podcasts = podcasts_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_url.py
#+end_src

*** podcasts_from_filename
**** 1. Objetivo

Extraer un listado de podcasts desde un archivo

**** 2. Firma

La función recibe un =str= con el nombre del archivo y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Un archivo HTML que tiene un listado de podcasts
- Un archivo HTML de otra página, que no tiene podcasts
- Un archivo que no existe
- Un nombre de archivo que no es un =str=

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_filename.py

def ok_filename():
    return "./franceinter/html/podcast-list-short.html"

def wrong_filename():
    return "./franceinter/html/wrong-page.html"

def not_found_filename():
    return "./franceinter/html/this-file-does-not-exist.html"

def invalid_filename():
    return [1, 2, 3]

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_filename(filename):
    # validar que filename sea un str
    # validar que el archivo exista
    podcasts = []
    # crear un requests.models.Response con el contenido del archivo
    # obtener los podcasts llamando a podcasts_from_response
    return podcasts
     
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_filename.py
from requests.models import Response
from franceinter.podcasts.podcasts_from_response import podcasts_from_response

def podcasts_from_filename(filename):
    assert isinstance(filename, str), invalid_filename(filename)
    resp = Response()
    podcasts = []
    try:
        with open(filename, "rb") as f:
            resp._content = f.read()
            podcasts = podcasts_from_response(resp)
    except (OSError, IOError) as error:
        assert False, not_found(filename, error)
    return podcasts

def invalid_filename(filename):
    return "filename parameter must be a str, %s received instead" % filename

def not_found(filename, error):
    return "filename %s cannot be read, thrown error :\n%s" % (filename, error)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un archivo HTML que tiene un listado de podcasts, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Cuando recibe un archivo HTML de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un archivo que no existe, lanza un =AssertionError=
- Cuando recibe un nombre de archivo que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_filename.py
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_filename import podcasts_from_filename
from franceinter.podcasts.tests.examples_podcasts_from_filename import *

def test_ok_filename():
    filename = ok_filename()
    podcasts = podcasts_from_filename(filename)
    assert isinstance(podcasts, types.GeneratorType)
    podcasts = list(podcasts)
    assert (len(podcasts) > 0)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_wrong_filename():
    filename = wrong_filename()
    podcasts = podcasts_from_filename(filename)
    assert isinstance(podcasts, types.GeneratorType)
    podcasts = list(podcasts)
    assert (len(podcasts) == 0)

def test_not_found_filename():
    filename = not_found_filename()
    try:
        podcasts = podcasts_from_filename(filename)
    except AssertionError:
        assert True

def test_invalid_filename():
    filename = invalid_filename()
    try:
        podcasts = podcasts_from_filename(filename)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_podcasts_from_filename.py
#+end_src

*** DOING podcasts_from_query
**** 1. Objetivo

Filtrar un listado de podcasts y obtener solamente los que contienen una palabra clave en el título o en el autor

Se debe buscar la palabra clave sin tener encuenta las mayúsculas o minúsculas (case insensitive match)

**** 2. Firma

La función recibe un listado de objetos =franceinter.podcasts.Podcast= y un =str=, y devuelve un =filter= de objetos =franceinter.podcasts.Podcast=

Para el listado de podcasts vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 podcasts en el que hay 2 que tienen la palabra "radio" en el título 
- Un listado de 5 podcasts en el que hay 3 que tienen la palabra "radio" en el autor
- Un listado de 5 podcasts en el que ninguno tiene la palabra "radio" en el título y/o autor
- Un listado de podcasts que no es iterable
- Un listado de podcasts que no tiene objetos =franceinter.podcasts.Podcast=
- Una query que no es un =str=

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_query.py
import random
from franceinter.podcasts.podcast import Podcast

def podcasts_with_word_in_title(word):
    podcasts = []
    for i in range(0, 3):
        podcasts.append(new_podcast())
    p = new_podcast()
    p.title+= " " + word
    podcasts.append(p)
    podcasts.append(p)
    random.shuffle(podcasts)
    return podcasts

def podcasts_with_word_in_author(word):
    podcasts = []
    for i in range(0, 2):
        podcasts.append(new_podcast())
    p = new_podcast()
    p.author+= " " + word
    podcasts.append(p)
    podcasts.append(p)
    podcasts.append(p)
    random.shuffle(podcasts)
    return podcasts

def some_podcasts(how_many):
    for i in range(0, how_many):
        yield new_podcast()

def podcasts_not_iterable():
    return 42
        
def invalid_podcasts():
    return range(0,10)

def invalid_query():
    return 42

def new_podcast():
    title = "Este es un podcast de ejemplo"
    url = "http://podcastplace.com/shows"
    author = "Juan Perez"
    return Podcast(title, url, author)

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_query(podcasts, query):
    # validar que los podcasts sean iterables
    # validar que la query sea un str
    # validar que cada podcast sea un Podcast
    # filtrar los podcasts con una función que devuelva true 
    # si el título o el autor contienen la query

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_query.py
import re
from franceinter.podcasts.podcast import Podcast

def podcasts_from_query(podcasts, query):
    # validar que los podcasts sean iterables
    try:
        it = iter(podcasts)
    except TypeError:
        assert False, invalid_podcasts(podcasts)
    # validar que la query sea un str
    assert isinstance(query, str), invalid_query(query)
    # validar que cada podcast sea un Podcast
    valid_podcasts = filter(is_podcast, podcasts)
    # filtrar los podcasts que contienen la query
    contains_query = query_matcher(query)
    return filter(contains_query, valid_podcasts)

def is_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    return True
    
def query_matcher(query):
    def matcher(podcast):
        return (re.search(query, podcast.title, re.IGNORECASE) 
                or re.search(query, podcast.author, re.IGNORECASE))
    return matcher
    
def invalid_podcasts(podcasts):
    return "podcasts parameter must be iterable, received %s instead" % type(podcasts)

def invalid_query(query):
    return "query parameter must be a string, received %s instead" % type(query)

def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % type(podcast)

#+end_src

**** 6. Casos de prueba

- Cuando recibe un listado de 5 podcasts en el que hay 2 que tienen la palabra "radio" en el título, devuelve un =filter= con los 2 podcasts que cumplen la condición
- Cuando recibe un listado de 5 podcasts en el que hay 3 que tienen la palabra "radio" en el autor, devuelve un =filter= con los 3 podcasts que cumplen la condición
- Cuando recibe un listado de 5 podcasts en el que ninguno tiene la palabra "radio" en el título y/o autor, devuelve un =filter= vacío
- Cuando recibe un listado de podcasts que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de podcasts que no tiene objetos =franceinter.podcasts.Podcast=, lanza un =AssertionError=
- Cuando recibe una query que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_query.py
import types
from franceinter.podcasts.podcasts_from_query import podcasts_from_query
from franceinter.podcasts.tests.examples_podcasts_from_query import *

def test_podcasts_with_word_in_title():
    podcasts = podcasts_with_word_in_title("radio")
    result = podcasts_from_query(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_podcasts_with_word_in_author():
    podcasts = podcasts_with_word_in_author("radio")
    result = podcasts_from_query(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 3)

def test_podcasts_without_word():
    podcasts = some_podcasts(8)
    result = podcasts_from_query(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_podcasts_not_iterable():
    podcasts = podcasts_not_iterable()
    try:
        result = podcasts_from_query(podcasts, "radio")
    except AssertionError:
        assert True

def test_invalid_podcasts():
    podcasts = invalid_podcasts()
    try:
        result = podcasts_from_query(podcasts, "radio")
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_query():
    podcasts = some_podcasts(10)
    query = invalid_query()
    try:
        result = podcasts_from_query(podcasts, query)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_query.py
#+end_src

*** Implementación completa

#+begin_src python
from bs4 import BeautifulSoup
from urllib.request import urlopen
import re

def div_author(div):
    cls = "rich-section-list-item-content-infos-author"
    span = div.find("span", class_=cls)
    author = ''
    if span:
        author = span.find("a").attrs["title"]
    return author

def div_title(div):
    cls = "rich-section-list-item-content-title"
    link = div.find("a", class_=cls)
    title = ''
    if link:
        title = link.attrs["title"]
    return title

def div_href(div):
    cls = "rich-section-list-item-content-title"
    link = div.find("a", class_=cls)
    href = ''
    if link:
        href = "https://franceinter.fr/" + link.attrs["href"]
    return href

def div_to_podcast(div):
    return {
        'author': div_author(div),
        'title': div_title(div),
        'url': div_href(div)
    }

def divs(html):
    soup = BeautifulSoup(html, "html.parser")
    cls = "rich-section-list-item-content"
    return soup.find_all("div", class_=cls)

def podcasts():
    for div in divs():
        yield div_to_podcast(div)

def podcasts_from_file(filename):
    with open(filename) as html:
        for div in divs(html.read()):
            yield div_to_podcast(div)

def podcasts_from_url(url):
    with urlopen(url) as html:
        for div in divs(html.read()):
            yield div_to_podcast(div)

def podcast_search(query, podcasts):
    return filter(lambda p: re.search(query, p["title"], re.IGNORECASE) 
                  or re.search(query, p["author"], re.IGNORECASE), 
                  podcasts)

#+end_src

** Episodios

En el URL de un podcast vemos el listado de los últimos episodios disponibles. Al final del listado hay un selector de páginas para acceder al historial de episodios. Para poder obtener el historial completo necesitamos la cantidad de páginas, que está en un tag ~<li>~ que tiene la clase =last=. Una vez que tengamos la cantidad de páginas podemos obtener el listado de episodios, parseando cada una de las páginas del historial.

#+begin_src python
from bs4 import BeautifulSoup
from urllib.request import urlopen
from franceinter import podcasts as p
import re

def lastpage_from_filename(filename):
    with open(filename) as html:
        soup = BeautifulSoup(html, "html.parser")
        lastpage = 1
        item = soup.find("li", class_="last")
        if item:
            href = item.find("a").attrs["href"]
            match = re.search("([0-9]+)$", href)
            if match:
                lastpage = int(match.groups()[0])
        return lastpage

def page_list(podcast):
    lastpage = lastpage_from_filename("episodes.html")
    for pagenum in range(1, lastpage+1):
        yield podcast["url"] + "?p=" + str(pagenum)

#return lastpage_from_filename("episodes.html")

podcasts = p.podcasts_from_file('emissions.html')
darwin = list(p.podcast_search("darwin", podcasts))[0]

return list(page_list(darwin))
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src sh
#curl -o episodes.html https://franceinter.fr/emissions/sur-les-epaules-de-darwin
#ls -alh *.html
cat episodes.html | grep "pager-item"
#+end_src

#+RESULTS:
:results:
                                    <li class="pager-item active">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                                                            <li class="pager-item show-hidden">
                                        <li class="pager-item next">
                    <li class="pager-item last">
                            <li class="pager-item">
:end:

** HTML

Vamos a usar cURL para descargar el HTML de las diferentes páginas que necesitamos parsear, así podemos desarrollar y ejecutar los casos de prueba sin tener conexión a Internet. Guardamos los archivos en la carpeta =franceinter/html=.

#+begin_src sh
mkdir -p ./franceinter/html
curl -o ./franceinter/html/podcast-list.html https://www.franceinter.fr/emissions
head -n 1000 ./franceinter/html/podcast-list.html > franceinter/html/podcast-list-short.html
curl -o ./franceinter/html/episode-list.html https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin
curl -o ./franceinter/html/wrong-page.html https://www.pagina12.com.ar
ls -alh ./franceinter/html
#+end_src

#+RESULTS:
:results:
total 10968
drwxr-xr-x  5 martin  staff   160B Feb  8 17:18 .
drwxr-xr-x  7 martin  staff   224B Feb  8 17:18 ..
-rw-r--r--  1 martin  staff   276K Feb  8 17:18 episode-list.html
-rw-r--r--  1 martin  staff   4.1M Feb  8 17:18 podcast-list.html
-rw-r--r--  1 martin  staff    20K Feb  8 17:18 wrong-page.html
:end:

* Herramientas
** Submódulos

#+begin_src python :tangle utils/__init__.py
__all__ = ["http_server"]
#+end_src

** LocalFolderHTTPServer

Para poder ejecutar los casos de prueba que realizan peticiones HTTP, necesitamos levantar un servidor HTTP desde una carpeta local.

https://stackoverflow.com/questions/39801718/how-to-run-a-http-server-which-serve-a-specific-path/46332163#46332163

#+begin_src python :tangle utils/http_server.py
import os
try:
    # python 2
    from SimpleHTTPServer import SimpleHTTPRequestHandler
    from BaseHTTPServer import HTTPServer as BaseHTTPServer
except ImportError:
    # python 3
    from http.server import HTTPServer as BaseHTTPServer, SimpleHTTPRequestHandler

class HTTPHandler(SimpleHTTPRequestHandler):
    """This handler uses server.base_path instead of always using os.getcwd()"""
    def translate_path(self, path):
        path = SimpleHTTPRequestHandler.translate_path(self, path)
        relpath = os.path.relpath(path, os.getcwd())
        fullpath = os.path.join(self.server.base_path, relpath)
        return fullpath

class LocalFolderHTTPServer(BaseHTTPServer):
    """The main server, you pass in base_path which is the path you want to serve requests from"""
    def __init__(self, base_path, server_address, RequestHandlerClass=HTTPHandler):
        self.base_path = base_path
        BaseHTTPServer.__init__(self, server_address, RequestHandlerClass)   
#+end_src

* Tests
*** Ejecutar los casos de prueba

#+begin_src sh
pytest
#+end_src

*** Generar el reporte de cobertura

#+begin_src sh
pytest --cov-report html:coverage --cov ./franceinter/ 
#+end_src

Para visualizar el reporte se debe abrir el archivo =./coverage/index.html= con el navegador

#+begin_src sh
firefox --new-tab ./coverage/index.html
#+end_src

* Apéndices
*** listar podcasts

#+begin_src python :python python-3.6 :results drawer
import franceinter.podcasts_old as fr

podcasts = fr.podcasts_from_file('./downloads/emissions.html')
#podcasts = fr.podcasts_from_url('https://www.franceinter.fr/emissions')

#return list(podcasts)[39]
print(list(fr.podcast_search("darwin", podcasts)))
#+end_src

#+RESULTS:
:results:
[{'author': 'Jean Claude Ameisen', 'title': 'Sur les épaules de Darwin', 'url': 'https://franceinter.fr/emissions/sur-les-epaules-de-darwin'}]
:end:

*** implementación de referencia

#+begin_src python :python python-3.6 :results output
from bs4 import BeautifulSoup
from urllib.request import urlopen
import re

def slugify(string):
    return re.sub(r'[-\s]+', '-',
                  (re.sub(r'[^\w\s-]', '',string).strip().lower()))

def linkToDate(link):
    date = ""
    rd = re.search("([0-9]{2})-([a-z]+)-([0-9]{4})$", link)
    if rd:
        date = rd.group(3) + "-" + monthNumber(rd.group(2)) + "-" + rd.group(1)
    return date
        
def monthNumber(month):
    return {
        'janvier': "01",
        'fevrier': "02",
        'mars': "03",
        'avril': "04",
        'mai': "05",
        'juin': "06",
        'juillet': "07",
        'aout': "08",
        'septembre': "09",
        'octobre': "10",
        'novembre': "11",
        'decembre': "12"
    }[month]

    
r = urlopen('https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin?p=2').read()
soup = BeautifulSoup(r, "html.parser")
#print(soup.prettify())
buttons = soup.find_all("button", class_="replay-button")

for button in buttons:
    if "data-url" in button.attrs:
        #print(button.attrs)
        link = button.attrs["data-diffusion-path"]
        date = linkToDate(link)
        filename = date + "-" + slugify(button.attrs["data-diffusion-title"]) + ".mp3"
        #print(filename)
        print("curl -o " + filename + " " + button.attrs["data-url"])
        #print("")

#+end_src

#+RESULTS:
:results:
:end:

