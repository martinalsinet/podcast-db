#+TITLE: Podcast Database
#+AUTHOR: Martín Alsinet
#+DATE: 2019
#+OPTIONS: ^:nil num:nil ':t
#+LANGUAGE: es
#+PROPERTY: header-args:python :python python-3.6 :results output drawer :mkdirp yes
#+PROPERTY: header-args:sh :results raw drawer
#+TODO: TODO DOING | DONE

* Motivación

Me gusta escuchar podcasts de [[https://franceinter.fr][France Inter]] cuando salgo a caminar, y en su momento me armé un script que me genera los links para descargar los episodios usando cURL.

Quiero mejorar ese script y transformarlo en una aplicación que me permita buscar podcasts, generar una base de datos con podcasts de distintas fuentes (p.ej. YouTube) y armar una cola de descargas.

Además, me gustaría usar este proyecto para probar dos enfoques de programación que me están interesando últimamente:

- [[http://www.literateprogramming.com/][Literate Programming]] :: Es una manera de programar en la que el código de la aplicación es un subproducto del documento que explica cómo está hecha

- [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]] :: En este libro se define una receta para la construcción de programas en forma iterativa usando el paradigma de programación funcional

** Literate Programming

Para escribir este documento estoy usando [[https://www.gnu.org/software/emacs][Emacs]] y [[https://orgmode.org][Org mode]], que es un modo de Emacs que tiene funcionalidades para literate programming.

La idea de la programación literaria consiste en que el código fuente de la aplicación sale de la documentación. Esto quiere decir que para poder generar un ejecutable (un /build/) de una aplicación hecha "literariamente" es necesario procesar la documentación, extraer de ella los fragmentos de código fuente que constituyen la aplicación (en org-mode este proceso se denomina /tangle/) y luego generar el ejecutable correspondiente con ese código.

En nuestro caso, la documentación a procesar es /este documento/. Todo el código fuente de la aplicación está contenido en este documento, dentro de los fragmentos de código delimitados por las etiquetas =#+begin_src= y =#+end_src=. Los bloques de código que tienen el parámetro =:tangle path/to/file= en el tag de inicio son exportados al archivo que indica el path. De esta manera, podemos generar todos los archivos del código fuente de la aplicación /tangleando/ la documentación. El comando =org-babel-tangle= dispara la generación de los archivos en cualquier momento.

El hecho de generar el código fuente desde este documento permite que no sea necesario guardarlo en el repositorio. Cada vez que es necesario ejecutar la aplicación, o generar un build para una versión determinada, se exporta el código fuente desde este documento. Como podemos ver usando el comando =git ls-tree=, los únicos archivos que están comiteados en el repositorio son el =.gitignore= y =podcast-db.org= (este archivo). El archivo =README.org= es un link simbólico a =podcast-db.org= para que aparezca como índice en github.

#+begin_src sh
# listar los archivos comiteados en el repositorio
git ls-tree --full-tree -r --name-only HEAD
#+end_src

#+RESULTS:
:results:
.gitignore
README.org
podcast-db.org
:end:

*** ¿Y qué hago si no sé (o no quiero) usar emacs?

Dado que el código fuente está en este documento, para poder obtener los fuentes es necesario procesarlo (tanglearlo) con emacs. Así, podemos extraer el código de la aplicación desde el documento y ejecutarlo como haríamos con cualquier otro programa. 

Vamos a usar [[https://www.docker.com/][Docker]] para bajar una imagen de Emacs y usar esa imagen para tanglear nuestro documento. 

#+begin_src sh :eval never
# descarga la imagen de emacs
docker pull silex/emacs:26-alpine

# lanza emacs en modo batch, 
# carga el archivo ./podcast-db.org del directorio actual,
# y ejecuta org-babel tangle
docker run --rm -i -v $(pwd):/app -w /app silex/emacs:26-alpine emacs --batch -l org podcast-db.org -f org-babel-tangle
#+end_src

Vemos que los fuentes se generan en la carpeta =franceinter=

#+begin_src sh :eval never
find ./franceinter
#+end_src

En teoría podríamos modificar el documento con otro editor de texto y regenerar los fuentes usando este método luego de editarlo, pero el procedimiento sería demasiado engorroso como para usarlo en la práctica.

** How to Design Programs

La otra fuente de inspiración para la metodología utilizada en este proyecto es el libro [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]]. Hay un video---[[https://media.ccc.de/v/35c3-9800-how_to_teach_programming_to_your_loved_ones][How to teach programming to your loved ones]]---en el que Mike Sperber explica la técnica utilizada para construir programas que se describe en el libro.

La idea es desarrollar una aplicación a partir de funciones elementales que se usan como piezas para ir armando componentes más complejos. El libro ofrece una receta para elaborar una función, que es la unidad mínima de código recomendada. Vamos a escribir cada una de las funciones de nuestra aplicación de acuerdo a los pasos de la siguiente receta:

- 1. Objetivo :: Identificar brevemente el propósito de la función. Nombrar las estructuras de datos que va a manipular
- 2. Firma :: Definir formalmente los parámetros de entrada y la salida de la función
- 3. Ejemplos :: Confeccionar un listado de ejemplos de parámetros de entrada que podría recibir la función y analizar cuál debería ser la salida para cada uno
- 4. Boceto :: Traducir la firma de la función en un boceto de la implementación
- 5. Definición :: Completar el boceto teniendo en cuenta el análisis y los ejemplos para lograr cumplir el propósito de la función
- 6. Casos de prueba :: Transformar los ejemplos en casos de prueba y asegurarse de que la función los pase a todos

En este caso, vamos a desarrollar nuestra aplicación en el lenguaje [[https://python.org][Python]] usando el paradigma de programación funcional. Esto quiere decir que nuestra aplicación va a estar mayormente compuesta de funciones (=def my_func():=) que vamos a ir combinando para realizar tareas complejas.

* Diseño
** Fuentes de podcasts

Quiero que mi base de datos pueda consultar las siguientes fuentes de podcasts:

- FranceInter
- FranceCulture
- RFI
- Youtube
- PBS
- BBC
- Team Human
- Radiolab

** Funcionalidades

- [ ] Listar las fuentes de podcasts disponibles
- [X] Listar los podcasts de una fuente
- [X] Listar los episodios de un podcast
- [X] Obtener el detalle de un episodio
- [X] Filtrar los episodios de un podcast según algún criterio (año, mes, palabra clave)
- [ ] Generar una playlist o feed RSS de los episodios filtrados
- [ ] Crear una cola de descarga a partir de una playlist
- [ ] Procesar los archivos descargados (p.ej, cambiar el bitrate a 64k)

* Setup
*** .gitignore

#+begin_src text :tangle .gitignore
.DS_Store
.pytest_cache
__pycache__
.coverage
coverage
downloads
franceinter
requirements.txt
utils
venv
#+end_src

*** Dependencias

Vamos a usar las siguientes bibliotecas

- requests :: Para realizar las peticiones http
- requests-cache :: Para cachear las peticiones http
- beautifulsoup4 :: Para parsear html
- slugify :: Para generar el nombre del archivo a descargar
- pytest :: Para ejecutar los casos de prueba
- pytest-cov :: Para generar el reporte de cobertura de tests
- validators :: Para validar URLs

**** TODO evaluar [[https://html.python-requests.org/][Requests-HTML]]

Parece que sería una alternativa interesante a BeautifulSoup4. 

Ventajas:

- Automatic following of redirects
- Pagination support
- Mocked user-agent (like a real web browser)

Desventajas:

- Solamente funciona con Python >= 3.6
- Tiene apenas un año de desarrollo (bs4 está /battle-tested/)
- Depende de muchos módulos (bloated?)

*** requirements.txt

#+begin_src txt :tangle requirements.txt
beautifulsoup4
slugify
requests
requests-cache
pytest
pytest-cov
validators
#+end_src

*** Instalación de dependencias
**** 1. Inicializar la carpeta =./venv=

#+begin_src sh
rm -Rf ./venv
virtualenv-3.6 ./venv
#+end_src

**** 2. Instalar dependencias con =pip=

#+begin_src sh
pip-3.6 install -r requirements.txt
#+end_src

* France Inter
** Módulos

Vamos a organizar el código en paquetes (carpetas), lo que nos permite usar namespaces para importar las funcionalidades. Para ello, necesitamos crear un archivo =__init__.py= en cada carpeta para declarar los módulos que forman parte nuestro paquete y que Python pueda encontrarlos cuando los referenciamos en el =import=.

El módulo actual es =franceinter=, y tiene los siguientes submódulos:

- podcasts
- episodes

#+begin_src python :tangle franceinter/__init__.py
__all__ = ["podcasts", "episodes"]
#+end_src

** Podcasts
*** Diseño

France Inter publica en una sola página (enorme) el listado de todas sus emisiones. El html está bastante fácil de parsear, dado que los datos cada emisión se encuentran dentro de un =div= con la clase =rich-section-list-item-content=. Revisando el contenido de ese div, podemos obtener el título del podcast, su URL y el autor (que es opcional).

Queremos obtener el listado de los podcasts desde un URL y también desde un archivo local. Además queremos poder filtrar el listado buscando los podcasts que contengan una palabra clave en el autor o en el título.

**** Wishlist

- [X] Obtener el listado de los podcasts de France Inter
- [X] Para cada podcast obtener el nombre, el url y el autor
- [X] Filtrar el listado de podcasts por una palabra clave

***** Obtener el listado de los podcasts de France Inter

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcasts_from_url import podcasts_from_url

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
first_five = itertools.islice(podcasts, 5)
for podcast in first_five:
    print(podcast)
    print("\n")
#+end_src

#+RESULTS:
:results:
Podcast(title='1001 mondes', url='https://www.franceinter.fr/emissions/mille-et-un-mondes')


Podcast(title='116 rue Albert-Londres', url='https://www.franceinter.fr/emissions/116-rue-albert-londres')


Podcast(title='18 bis, boulevard Hache-Coeur', url='https://www.franceinter.fr/emissions/18-bis-boulevard-hache-coeur')


Podcast(title='1914/1918 : la grande guerre, cent ans après', url='https://www.franceinter.fr/emissions/1914-1918-la-grande-guerre-cent-ans-apres')


Podcast(title='1918, un monde en révolutions', url='https://www.franceinter.fr/emissions/1918-un-monde-en-revolutions')


:end:

***** Para cada podcast obtener el nombre, el url y el autor

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcasts_from_url import podcasts_from_url

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
first_five = list(itertools.islice(podcasts, 5))
first = first_five[0]
print(" Podcast title: " + first.title)
print("   Podcast URL: " + first.url)
print("Podcast author: " + first.author)
#+end_src

#+RESULTS:
:results:
 Podcast title: 1001 mondes
   Podcast URL: https://www.franceinter.fr/emissions/mille-et-un-mondes
Podcast author: Laura El Makki
:end:

***** Filtrar el listado de podcasts por una palabra clave

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcasts_from_url import podcasts_from_url
from franceinter.podcasts.podcasts_from_query import podcasts_from_query

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
music_podcasts = podcasts_from_query(podcasts, "musique")
first_five = itertools.islice(music_podcasts, 5)
for podcast in first_five:
    print(podcast)
    print("\n")
#+end_src

#+RESULTS:
:results:
Podcast(title='Je veux de la musique !', url='https://www.franceinter.fr/emissions/je-veux-de-la-musique')


Podcast(title='Michel Berger, tout pour la musique', url='https://www.franceinter.fr/emissions/michel-berger-tout-pour-la-musique')


Podcast(title='La musique d'Inter', url='https://www.franceinter.fr/emissions/la-musique-d-inter')


Podcast(title='On parle musique', url='https://www.franceinter.fr/emissions/parle-musique')


Podcast(title='Quand la musique donne (été 2012)', url='https://www.franceinter.fr/emissions/quand-la-musique-donne-ete-2012')


:end:

**** TODO Mejoras

- [ ] =podcasts_from_filename= :: Se podrían matchear los errores de lectura del archivo con los códigos de la respuesta HTTP (404 si no se encuentra, 500 si hubo un error de I/O, etc)

- [ ] =podcasts_from_query= :: Analizar el cambio de nombre por =podcasts_matching_query=, que expresa mejor que la función es un filtro de podcasts usando una palabra clave. Pensándolo bien, el nombre de que mejor expresa lo que hace la función es =podcasts_with_keyword=

- [ ] =podcasts_from_query= :: Agregar que no distinga entre los caracteres acentuados (á vs a) al buscar. Por ejemplo, si la palabra buscada es =té= debería devolver los podcasts que contengan tanto =té= como =te=

*** Submódulos
**** Podcasts

#+begin_src python :tangle franceinter/podcasts/__init__.py
__all__ = [
    "author_from_tag", 
    "title_from_tag", 
    "url_from_tag", 
    "podcast_from_tag", 
    "tags_from_html", 
    "podcasts_from_tags", 
    "podcasts_from_response", 
    "podcasts_from_url", 
    "podcasts_from_filename", 
    "podcasts_from_query",
    "podcast"
]
#+end_src

**** Tests

#+begin_src python :tangle franceinter/podcasts/tests/__init__.py
__all__ = [
    "test_author_from_tag", 
    "test_title_from_tag", 
    "test_url_from_tag", 
    "test_podcast_from_tag", 
    "test_tags_from_html", 
    "test_podcasts_from_tags", 
    "test_podcasts_from_response", 
    "test_podcasts_from_url", 
    "test_podcasts_from_filename", 
    "test_podcasts_from_query",
    "examples_author_from_tag", 
    "examples_title_from_tag",
    "examples_url_from_tag",
    "examples_podcast_from_tag",
    "examples_tags_from_html",
    "examples_podcasts_from_tags",
    "examples_podcasts_from_response",
    "examples_podcasts_from_url",
    "examples_podcasts_from_filename",
    "examples_podcasts_from_query"
]
#+end_src

*** title_from_tag
**** 1. Objetivo

Obtener el título del podcast de un fragmento de html.

El título se encuentra en el atributo =title= de un =<a>= que tiene la clase =rich-section-list-item-content-title=

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, Un tag que contiene un =<a>= con la clase correcta y el atributo =title=
- Un tag que no tiene el =<a>=
- Un tag que tiene el =<a>= pero éste no tiene la clase =rich-section...=
- Un tag que tiene el =<a>= pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_title_from_tag.py
from bs4 import BeautifulSoup

def tag_with_title():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    title="Sur les epaules de Darwin">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a title="Sur les epaules de Darwin">
</a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    title="Sur les epaules de Darwin">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def title_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    title = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable title
    return title
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/title_from_tag.py
import bs4

def title_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "title" in link.attrs:
        title = link.attrs["title"]
    return title

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el título
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene la clase correcta, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_title_from_tag.py
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

def test_author_ok():
    tag = tag_with_title()
    assert ("Sur les epaules de Darwin" == title_from_tag(tag))

def test_invalid_tag():
    try:
        title_from_tag(5)
    except AssertionError:
        assert True

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == title_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == title_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == title_from_tag(tag))

#+end_src

#+begin_src python
from bs4 import BeautifulSoup
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

tag = tag_with_title()
title = title_from_tag(tag)
print(title)
#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_title_from_tag.py
#+end_src

*** url_from_tag
**** 1. Objetivo

Obtener el URL del podcast de un fragmento de html.

El URL se encuentra en el atributo =href= de un tag =<a>= que tiene la clase =rich-section-list-item-content-title=. 

El URL es relativo, por lo que hay que agregarle baseUrl de France Inter (https://www.franceinter.fr).

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag que contiene un =<a>= con la clase =rich-section-list-item-content-title= y el atributo =href=
- Un tag que no tiene el =<a>=
- Un tag que tiene el =<a>= pero el link no tiene clase
- Un tag que tiene el =<a>= pero el link no tiene el atributo =href=

#+begin_src python :tangle franceinter/podcasts/tests/examples_url_from_tag.py
from bs4 import BeautifulSoup

def tag_with_url():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</p>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a href="emissions/la-tete-au-carre"></a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_href():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def url_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    url = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el <a> hay que revisar si tiene el atributo href
    # si tiene el atributo href 
    #     - se le agrega "https://www.franceinter.fr/" adelante
    #     - se guarda en la variable url
    return url
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/url_from_tag.py
import bs4

def url_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    url = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "href" in link.attrs:
        url = "https://www.franceinter.fr/" + link.attrs["href"]
    return url

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el url
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene la clase buscada, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene el atributo =href=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_url_from_tag.py
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.tests.examples_url_from_tag import *

def test_url_ok():
    tag = tag_with_url()
    url = "https://www.franceinter.fr/emissions/la-tete-au-carre"
    assert (url == url_from_tag(tag))

def test_invalid_tag():
    try:
        url_from_tag(5)
    except AssertionError:
        assert True

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == url_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == url_from_tag(tag))

def test_title_not_found():
    tag = tag_without_href()
    assert ("" == url_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_url_from_tag.py
#+end_src

*** author_from_tag
**** 1. Objetivo

Obtener el autor del podcast de un fragmento de html. 

El autor se encuentra en el atributo =title= de un =<a>= que está dentro de un =<span>= que tiene la clase =rich-section-list-item-content-infos-author=

**** 2. Firma

La funcion recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, el tag tiene un =<span>= con la clase =rich-section-list-item-content-infos-author= que contiene un =<a>= con el atributo =title=
- El tag no tiene un =<span>=
- El tag tiene un =<span>=, pero éste no tiene un =<a>=
- El tag tiene un =<span>= que contiene un =<a>=, pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_author_from_tag.py
from bs4 import BeautifulSoup

def tag_with_author():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a title="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_span():
    html = '''<div class="boldest">
Extremely bold
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<p title="William Shakespeare"></p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a subtitle="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

#+RESULTS:
:results:
True
:end:

**** 4. Boceto

#+begin_src python

def author_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    author = ""
    # hay que buscar un span con la clase "rich-section..."
    # si existe el span hay que buscar un a
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable author
    return author
    
#+end_src

#+RESULTS:
:results:
None
:end:

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/author_from_tag.py
import bs4

def author_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    cls = "rich-section-list-item-content-infos-author"
    span = tag.find("span", class_=cls)
    author = ""
    if span:
        link = span.find("a")
        if link and "title" in link.attrs:
            author = link.attrs["title"]
    return author

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el autor
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no tiene un tag =<span>= con la clase buscada, devuelve un string vacío
- Cuando recibe un tag que tiene el =<span>= pero éste no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<span>= y el =<a>= pero éste último no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_author_from_tag.py
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.tests.examples_author_from_tag import *

def test_author_ok():
    tag = tag_with_author()
    assert ("William Shakespeare" == author_from_tag(tag))

def test_invalid_tag():
    try:
        author_from_tag(5)
    except AssertionError:
        assert True

def test_span_not_found():
    tag = tag_without_span()
    assert ("" == author_from_tag(tag))

def test_a_not_found():
    tag = tag_without_link()
    assert ("" == author_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == author_from_tag(tag))

#+end_src

#+RESULTS:
:results:
None
:end:

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_author_from_tag.py
#+end_src

*** podcast_from_tag
**** 1. Objetivo

Obtener un podcast de un fragmento de html.

Un podcast tiene tres propiedades, a saber:

- título :: es un =str= y es obligatorio
- url :: es un =str=, es obligatorio y debe ser un URL válido
- autor :: es un =str=, pero puede estar vacío

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un objeto =franceinter.podcasts.podcast=

Necesitamos entonces definir la clase =podcast=

#+begin_src python :tangle franceinter/podcasts/podcast.py

class Podcast:
    def __init__(self, title, url, author=""):
        self.title = title
        self.url = url
        self.author = author

    def __repr__(self):
        return "Podcast(title='%s', url='%s')" % (self.title, self.url)

#+end_src

**** 3. Ejemplos

- Un tag que tiene todos los elementos para generar un podcast válido (título, URL y autor)
- Un tag que no es un =bs4.element.Tag=
- Un tag que no tiene el elemento del título
- Un tag que no tiene el elemento del URL
- Un tag que tiene el elemento del URL, pero el URL no es válido
- Un tag que no tiene el elemento del autor

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcast_from_tag.py
from bs4 import BeautifulSoup

def tag_ok():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def invalid_tag():
    return "I am not a tag"

def tag_without_title():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_with_invalid_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="this://isnot[?=>avalid[[/\\url"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_author():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def podcast_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag

    # extraer el título con title_from_tag
    # validar que el título no sea un string vacío

    # extraer el url con url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer el autor usando author_from_tag

    # crear una instancia de franceinter.podcasts.podcast
    # con el título, el url y el autor
    return podcast

#+end_src

**** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceinter/podcasts/podcast_from_tag.py
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.podcast import Podcast
from validators.url import url as is_valid_url
import bs4

def podcast_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = title_from_tag(tag)
    assert (title != ""), no_title(tag)

    url = url_from_tag(tag)
    assert (url != ""), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)

    author = author_from_tag(tag)

    return Podcast(title, url, author)

def no_url(tag):
    return "received tag does not have a podcast URL\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid podcast URL\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have a podcast title\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve un podcast
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no tiene título, lanza un =AssertionError=
- Cuando recibe un tag que no tiene url, lanza un =AssertionError=
- Cuando recibe un tag que tiene un url pero es inválido, lanza un =AssertionError=
- Cuando recibe un tag que no tiene autor, devuelve un podcast con un =str= vacío en la propiedad author

#+begin_src python :tangle franceinter/podcasts/tests/test_podcast_from_tag.py
from franceinter.podcasts import podcast
from franceinter.podcasts.podcast_from_tag import podcast_from_tag
from franceinter.podcasts.tests.examples_podcast_from_tag import *

def test_podcast_ok():
    tag = tag_ok()
    podcast = podcast_from_tag(tag)
    assert (len(podcast.title) > 0)
    assert (len(podcast.url) > 0)
    assert (len(podcast.author) >0)
    assert (len(str(podcast)) > 0)

def test_podcast_without_title():
    tag = tag_without_title()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_url():
    tag = tag_without_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    tag = tag_with_invalid_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_author():
    tag = tag_without_author()
    podcast = podcast_from_tag(tag)
    assert len(podcast.title) > 0
    assert len(podcast.url) > 0
    assert len(podcast.author) == 0

def test_invalid_tag():
    tag = invalid_tag()
    try:
        podcast_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcast_from_tag.py
#+end_src

*** tags_from_html
**** 1. Objetivo

Obtener un array de tags con el fragmento de html que tiene el detalle del podcast (título, URL y autor) a partir del html de la página con el listado de podcasts

Hay que extraer todos los =<div>= que tengan la clase =rich-section-list-item-content=

**** 2. Firma

La función recibe un =str= con el html de la página y devuelve un =GeneratorType= de elementos =bs4.element.Tag=

**** 3. Ejemplos

- Un html que tiene varios =<div>= con la clase buscada
- Un html que no es un =str=
- Un html que no tiene ningún =<div>=
- Un html que tiene varios =<div>= pero que ninguno tenga la clase =rich-section-list-item-content=
- Un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen

#+begin_src python :tangle franceinter/podcasts/tests/examples_tags_from_html.py
from bs4 import BeautifulSoup
import random

def html_with_divs(how_many):
    class_name = "rich-section-list-item-content"
    divs = map(lambda x: div(class_name), range(how_many))
    return html(divs)

def html_is_not_string():
    return 42

def html_without_divs():
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>'''
    return html

def html_divs_without_class(how_many):
    divs = map(lambda x: div(), range(how_many))
    return html(divs)

def html_some_divs_with_class(how_many_with, how_many_without):
    class_name = "rich-section-list-item-content"
    divs_with = list(map(lambda x: div(class_name), range(how_many_with)))
    divs_without = list(map(lambda x: div(), range(how_many_without)))
    divs = divs_with + divs_without
    random.shuffle(divs)
    return html(divs)

def div(class_name=""):
    attr = ""
    if class_name:
        attr = "class=%s" % class_name
    html = '''<div %s>
    here goes the div body
</div>''' % attr
    soup = BeautifulSoup(html, "html.parser")
    return soup.div

def html(divs):
    div_str = "".join(map(lambda div: str(div), divs))
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
%s
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    ''' % div_str
    return html
    
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup

def tags_from_html(html):
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # filtrar los tag <div> que tienen la clase "rich-section-list-item-content"
    return tags

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/tags_from_html.py
from bs4 import BeautifulSoup

def tags_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    cls = "rich-section-list-item-content"
    tags = soup.find_all("div", class_=cls)
    for tag in tags:
        yield tag

def invalid_html(html):
    return "html parameter must be a string, received %s instead" % type(html)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un html que tiene varios =<div>= con la clase buscada, devuelve un =GeneratorType= de tantos elementos como =<div>= hay en el html
- Cuando recibe un html que no es un string, lanza un =AssertionError=
- Cuando recibe un html que no tiene ningún =<div>=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene varios =<div>= pero ninguno tiene la clase =rich-section-list-item-content=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen, devuelve un =GeneratorType= con solamente los =<div>= que tienen la clase

#+begin_src python :tangle franceinter/podcasts/tests/test_tags_from_html.py
import types
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *

def test_html_with_divs():
    html = html_with_divs(5)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 5)

def test_html_is_not_string():
    try:
        html = html_is_not_string()
        tags = list(tags_from_html(html))
    except AssertionError:
        assert True

def test_html_without_divs():
    html = html_without_divs()
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_divs_without_class():
    html = html_divs_without_class(4)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_some_divs_with_class():
    html = html_some_divs_with_class(2,3)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 2)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_tags_from_html.py
#+end_src

*** podcasts_from_tags
**** 1. Objetivo

Generar un listado de podcasts a partir de un listado de fragmentos de HTML tomados de la página

**** 2. Firma

La función recibe un listado de objetos =bs4.element.Tag= y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

Vamos a aceptar tanto un =list= como un =GeneratorType=

**** 3. Ejemplos

- Un objeto que no es iterable
- Una lista vacía
- Una lista con tags válidos
- Una lista con objetos que no son del tipo =bs4.element.Tag=
- Una lista con tags válidos y un tag inválido (sin el título o el URL)

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_tags.py
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *
from franceinter.podcasts.tests.examples_podcast_from_tag import (
    tag_ok, 
    tag_without_url
)

def invalid_list():
    return 123

def empty_list():
    return []

def list_without_tags():
    return [1, 2, 3, 4, 5]

def list_with_valid_tags(how_many):
    html = ""
    for item in range(1, how_many):
        html+= str(tag_ok())
    tags = tags_from_html(html)
    return tags

def list_with_invalid_tag(how_many):
    tags = list(list_with_valid_tags(how_many - 1))
    tags+= tag_without_url()
    return tags

#+end_src

**** 4. Boceto

#+begin_src python
from franceinter.podcasts.tags_from_html import tags_from_html

def podcasts_from_tags(tags):
    # validar que tags sea un GeneratorType
    # para cada tag de la lista
    # usar podcast_from_tag() para obtener un podcast
    # yield posdcast

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_tags.py
from franceinter.podcasts.podcast_from_tag import podcast_from_tag

def podcasts_from_tags(tags):
    try:
        it = iter(tags)
    except TypeError:
        assert False, invalid_tags(tags)
    for tag in tags:
        yield podcast_from_tag(tag)

def invalid_tags(tags):
    return "tags parameter must be iterable, received %s instead" % type(tags)
#+end_src

**** 6. Casos de prueba

- Si recibe un objeto que no es iterable, lanza un =AssertionError=
- Si recibe una lista vacía, devuelve un =GeneratorType= vacío
- Si recibe una lista de tags válidos, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Si recibe una lista con objetos que no son del tipo =bs4.element.Tag=, lanza un =AssertionError=
- Si recibe una lista con algún tag inválido (que no tenga el título o el URL), lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_tags.py
import types
from franceinter.podcasts.podcasts_from_tags import podcasts_from_tags
from franceinter.podcasts.tests.examples_podcasts_from_tags import *
from franceinter.podcasts.podcast import Podcast

def test_invalid_list():
    tags = invalid_list()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_empty_list():
    tags = empty_list()
    podcasts = podcasts_from_tags(tags)
    assert isinstance(podcasts, types.GeneratorType)
    assert (len(list(podcasts))==0)

def test_list_with_valid_tags():
    tags = list_with_valid_tags(6)
    podcasts = podcasts_from_tags(tags)
    assert isinstance(podcasts, types.GeneratorType)
    for p in podcasts:
        assert (isinstance(p, Podcast))

def test_list_without_tags():
    tags = list_without_tags()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_list_with_invalid_tag():
    tags = list_with_invalid_tag(6)
    podcasts = podcasts_from_tags(tags)
    try:
        for p in podcasts:
            assert (isinstance(p, Podcast))
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_tags.py
#+end_src

*** podcasts_from_response
**** 1. Objetivo

Extraer el listado de podcasts de la respuesta de una petición HTTP

**** 2. Firma

La función recibe una =requests.model.Response= y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Una respuesta válida, con el HTML de la página del listado de podcasts
- Una respuesta inválida, que no es de la clase =requests.model.Response=
- Una respuesta válida, pero que tiene el HTML de otra página

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_response.py
from requests.models import Response

def response_ok():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/podcast-list-short.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

def invalid_response():
    return "i am not a Response"

def wrong_page_response():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/wrong-page.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

#+end_src

#+RESULTS:
:results:
:end:

**** 4. Boceto

#+begin_src python
import requests

def podcasts_from_response(resp):
    # validar la respuesta
    # obtener el HTML de resp.text
    # extraer los tags usando tags_from_html
    # obtener los podcasts usando podcasts_from_html

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_response.py
import requests
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.podcasts_from_tags import podcasts_from_tags

def podcasts_from_response(resp):
    assert isinstance(resp, requests.models.Response), invalid_type(resp)
    html = resp.text
    tags = tags_from_html(html)
    podcasts = podcasts_from_tags(tags)
    return podcasts
    
def invalid_type(resp):
    return "resp parameter must be a requests.models.Response, received %s instead" % type(resp)

#+end_src

**** 6. Casos de prueba

- Cuando recibe una respuesta válida, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Cuando recibe una respuesta que no es de la clase =requests.model.Response=, lanza un =AssertionError=
- Cuando recibe una respuesta válida que tiene el HTML de otra página, devuelve un =GeneratorType= vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_response.py
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_response import podcasts_from_response
from franceinter.podcasts.tests.examples_podcasts_from_response import *

def test_response_ok():
    resp = response_ok()
    podcasts = podcasts_from_response(resp)
    assert isinstance(podcasts, types.GeneratorType)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_invalid_response():
    resp = invalid_response()
    try:
        podcasts = podcasts_from_response(resp)
    except AssertionError:
        assert True
    
def test_wrong_page_response():
    resp = wrong_page_response()
    podcasts = podcasts_from_response(resp)
    assert isinstance(podcasts, types.GeneratorType)
    assert (len(list(podcasts)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_response.py
#+end_src

*** podcasts_from_url
**** 1. Objetivo

Extraer el listado de podcasts desde un URL

**** 2. Firma

La función recibe un URL y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Un URL con el listado de podcasts
- Un URL de otra página, que no tiene podcasts
- Un URL de una página inexistente, que dispare un error 404 (not found)
- Un URL de un sitio inexistente, que dispare un error de DNS
- Un URL inválido

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_url.py

def url_ok():
    url = "http://localhost:3000/podcast-list-short.html"
    return url

def wrong_page_url():
    url = "http://localhost:3000/wrong-page.html"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def wrong_site_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

def invalid_url():
    url = "ht pt:\\hostlocal:3000/this-url-is-not-valid.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_url(url):
    # validar el url
    # realizar una petición al url
    # obtener la respuesta del url
    # obtener los podcasts llamando a podcasts_from_url
    # revisar si da un error de conexión
    return podcasts

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_url.py
import requests
from validators.url import url as is_valid_url
from franceinter.podcasts.podcasts_from_response import podcasts_from_response

def podcasts_from_url(url):
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        podcasts = podcasts_from_response(response)
        return podcasts
    except requests.ConnectionError:
        assert False, connection_error(url)

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url
#+end_src

**** 6. Casos de prueba

Bueno, aquí tenemos un caso de prueba un poco más complejo que lo normal. Para poder testear nuestra función necesitamos realizar una petición HTTP. El problema es que no queremos depender de un sitio web externo, o de que haya conectividad a Internet cuando se ejecuten los casos de prueba. La solución es levantar un servidor HTTP desde una carpeta local y en nuestro caso vamos a usar los archivos HTML de ejemplo que tenemos en =franceinter/html=.

Ahora bien, necesitamos que el servidor HTTP esté levantado antes de correr nuestros casos de prueba y sería ideal poder bajarlo luego de ejecutar todos los tests que lo necesiten. Para ello vamos a usar un [[https://docs.pytest.org/en/latest/fixture.html][fixture]] (=@pytest.fixture=), que es una funcionalidad de pytest que permite que los casos de prueba reciban un argumento con algún recurso, en este caso, el servidor HTTP ya levantado y sirviendo los archivos desde la carpeta local.

El atributo ~scope="module"~ indica que el fixture =http_server= será invocado una sola vez por módulo, que es lo que queremos para que todos los tests de nuestra función compartan el mismo servidor HTTP y no tener que levantarlo y bajarlo para cada test. Cuando no se indica un =scope=, pytest invoca el fixture para cada caso de prueba.

Un fixture es una función común y corriente como cualquier otra, a la que pytest llama cuando comienza a procesar el módulo, se guarda el valor retornado, y se lo inyecta a los casos de prueba que declaren ese fixture como parámetro.

Nótese en el código del fixture =http_server= que se levanta el servidor HTTP en otro thread para no bloquear la ejecución de los tests y que se utiliza =yield= para poder bajar el servidor luego de su uso.

- Cuando recibe un URL con el listado de podcasts, devuelve un =GeneratorType= de objetos =Podcast=
- Cuando recibe un URL de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de una página inexistente, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de un sitio inexistente (error de DNS), lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_url.py
import pytest
import threading
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_url import podcasts_from_url
from franceinter.podcasts.tests.examples_podcasts_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = url_ok()
    gen = podcasts_from_url(url)
    assert isinstance(gen, types.GeneratorType)
    podcasts = list(gen)
    assert (len(podcasts) > 0)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_wrong_page_url(http_server):
    url = wrong_page_url()
    podcasts = list(podcasts_from_url(url))
    assert (len(podcasts) == 0)

def test_not_found_url(http_server):
    url = not_found_url()
    podcasts = list(podcasts_from_url(url))
    assert (len(podcasts) == 0)

@pytest.mark.skip(reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = wrong_site_url()
    try:
        podcasts = list(podcasts_from_url(url))
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        podcasts = podcasts_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_url.py
#+end_src

*** podcasts_from_filename
**** 1. Objetivo

Extraer un listado de podcasts desde un archivo

**** 2. Firma

La función recibe un =str= con el nombre del archivo y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Un archivo HTML que tiene un listado de podcasts
- Un archivo HTML de otra página, que no tiene podcasts
- Un archivo que no existe
- Un nombre de archivo que no es un =str=

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_filename.py

def ok_filename():
    return "./franceinter/html/podcast-list-short.html"

def wrong_filename():
    return "./franceinter/html/wrong-page.html"

def not_found_filename():
    return "./franceinter/html/this-file-does-not-exist.html"

def invalid_filename():
    return [1, 2, 3]

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_filename(filename):
    # validar que filename sea un str
    # validar que el archivo exista
    podcasts = []
    # crear un requests.models.Response con el contenido del archivo
    # obtener los podcasts llamando a podcasts_from_response
    return podcasts
     
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_filename.py
from requests.models import Response
from franceinter.podcasts.podcasts_from_response import podcasts_from_response

def podcasts_from_filename(filename):
    assert isinstance(filename, str), invalid_filename(filename)
    resp = Response()
    podcasts = []
    try:
        with open(filename, "rb") as f:
            resp._content = f.read()
            podcasts = podcasts_from_response(resp)
    except (OSError, IOError) as error:
        assert False, not_found(filename, error)
    return podcasts

def invalid_filename(filename):
    return "filename parameter must be a str, %s received instead" % filename

def not_found(filename, error):
    return "filename %s cannot be read, thrown error :\n%s" % (filename, error)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un archivo HTML que tiene un listado de podcasts, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Cuando recibe un archivo HTML de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un archivo que no existe, lanza un =AssertionError=
- Cuando recibe un nombre de archivo que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_filename.py
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_filename import podcasts_from_filename
from franceinter.podcasts.tests.examples_podcasts_from_filename import *

def test_ok_filename():
    filename = ok_filename()
    podcasts = podcasts_from_filename(filename)
    assert isinstance(podcasts, types.GeneratorType)
    podcasts = list(podcasts)
    assert (len(podcasts) > 0)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_wrong_filename():
    filename = wrong_filename()
    podcasts = podcasts_from_filename(filename)
    assert isinstance(podcasts, types.GeneratorType)
    podcasts = list(podcasts)
    assert (len(podcasts) == 0)

def test_not_found_filename():
    filename = not_found_filename()
    try:
        podcasts = podcasts_from_filename(filename)
    except AssertionError:
        assert True

def test_invalid_filename():
    filename = invalid_filename()
    try:
        podcasts = podcasts_from_filename(filename)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_podcasts_from_filename.py
#+end_src

*** podcasts_from_query
**** 1. Objetivo

Filtrar un listado de podcasts y obtener solamente los que contienen una palabra clave en el título o en el autor

Se debe buscar la palabra clave sin tener encuenta las mayúsculas o minúsculas (case insensitive match)

**** 2. Firma

La función recibe un listado de objetos =franceinter.podcasts.Podcast= y un =str=, y devuelve un =filter= de objetos =franceinter.podcasts.Podcast=

Para el listado de podcasts vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 podcasts en el que hay 2 que tienen la palabra "radio" en el título 
- Un listado de 5 podcasts en el que hay 3 que tienen la palabra "radio" en el autor
- Un listado de 5 podcasts en el que ninguno tiene la palabra "radio" en el título y/o autor
- Un listado de podcasts que no es iterable
- Un listado de podcasts que no tiene objetos =franceinter.podcasts.Podcast=
- Una query que no es un =str=

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_query.py
import random
from franceinter.podcasts.podcast import Podcast

def podcasts_with_word_in_title(word):
    podcasts = []
    for i in range(0, 3):
        podcasts.append(new_podcast())
    p = new_podcast()
    p.title+= " " + word
    podcasts.append(p)
    podcasts.append(p)
    random.shuffle(podcasts)
    return podcasts

def podcasts_with_word_in_author(word):
    podcasts = []
    for i in range(0, 2):
        podcasts.append(new_podcast())
    p = new_podcast()
    p.author+= " " + word
    podcasts.append(p)
    podcasts.append(p)
    podcasts.append(p)
    random.shuffle(podcasts)
    return podcasts

def some_podcasts(how_many):
    for i in range(0, how_many):
        yield new_podcast()

def podcasts_not_iterable():
    return 42
        
def invalid_podcasts():
    return range(0,10)

def invalid_query():
    return 42

def new_podcast():
    title = "Este es un podcast de ejemplo"
    url = "http://podcastplace.com/shows"
    author = "Juan Perez"
    return Podcast(title, url, author)

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_query(podcasts, query):
    # validar que los podcasts sean iterables
    # validar que la query sea un str
    # validar que cada podcast sea un Podcast
    # filtrar los podcasts con una función que devuelva true 
    # si el título o el autor contienen la query

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_query.py
import re
from franceinter.podcasts.podcast import Podcast

def podcasts_from_query(podcasts, query):
    # validar que los podcasts sean iterables
    try:
        it = iter(podcasts)
    except TypeError:
        assert False, invalid_podcasts(podcasts)
    # validar que la query sea un str
    assert isinstance(query, str), invalid_query(query)
    # validar que cada podcast sea un Podcast
    valid_podcasts = filter(is_podcast, podcasts)
    # filtrar los podcasts que contienen la query
    contains_query = query_matcher(query)
    return filter(contains_query, valid_podcasts)

def is_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    return True
    
def query_matcher(query):
    def matcher(podcast):
        return (re.search(query, podcast.title, re.IGNORECASE) 
                or re.search(query, podcast.author, re.IGNORECASE))
    return matcher
    
def invalid_podcasts(podcasts):
    return "podcasts parameter must be iterable, received %s instead" % type(podcasts)

def invalid_query(query):
    return "query parameter must be a string, received %s instead" % type(query)

def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % type(podcast)

#+end_src

**** 6. Casos de prueba

- Cuando recibe un listado de 5 podcasts en el que hay 2 que tienen la palabra "radio" en el título, devuelve un =filter= con los 2 podcasts que cumplen la condición
- Cuando recibe un listado de 5 podcasts en el que hay 3 que tienen la palabra "radio" en el autor, devuelve un =filter= con los 3 podcasts que cumplen la condición
- Cuando recibe un listado de 5 podcasts en el que ninguno tiene la palabra "radio" en el título y/o autor, devuelve un =filter= vacío
- Cuando recibe un listado de podcasts que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de podcasts que no tiene objetos =franceinter.podcasts.Podcast=, lanza un =AssertionError=
- Cuando recibe una query que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_query.py
import types
from franceinter.podcasts.podcasts_from_query import podcasts_from_query
from franceinter.podcasts.tests.examples_podcasts_from_query import *

def test_podcasts_with_word_in_title():
    podcasts = podcasts_with_word_in_title("radio")
    result = podcasts_from_query(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_podcasts_with_word_in_author():
    podcasts = podcasts_with_word_in_author("radio")
    result = podcasts_from_query(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 3)

def test_podcasts_without_word():
    podcasts = some_podcasts(8)
    result = podcasts_from_query(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_podcasts_not_iterable():
    podcasts = podcasts_not_iterable()
    try:
        result = podcasts_from_query(podcasts, "radio")
    except AssertionError:
        assert True

def test_invalid_podcasts():
    podcasts = invalid_podcasts()
    try:
        result = podcasts_from_query(podcasts, "radio")
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_query():
    podcasts = some_podcasts(10)
    query = invalid_query()
    try:
        result = podcasts_from_query(podcasts, query)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_query.py
#+end_src

** Episodios
*** Diseño

En el URL de un podcast vemos el listado de los últimos episodios disponibles. Al final del listado hay un selector de páginas para acceder al historial de episodios. Para poder obtener el historial completo necesitamos la cantidad de páginas, que está en un tag =<li>= que tiene la clase =last=. 

Una vez que tengamos la cantidad de páginas podemos obtener el listado de episodios, parseando cada una de las páginas del historial. Como hicimos en el módulo de podcasts, necesitamos poder obtener los episodios tanto desde un URL como desde un archivo local.

Cada episodio tiene un título, una fecha de emisión y un URL para descargar el audio. Podemos ver en el HTML de la página (ver el archivo =./franceinter/html/episode-list.html=) que se puede obtener también la duración en segundos del episodio, dato que puede ser útil más adelante para detectar problemas en la descarga de los archivos.

Por lo que se puede ver en el HTML, muchos de los datos que necesitamos se encuentran en un tag =<button>= que tiene la clase =replay-button=

**** Wishlist

- [X] Obtener el listado de los episodios de un podcast
- [X] Para cada episodio obtener el título, la fecha, el URL del audio y su duración
- [X] Filtrar el listado por una palabra clave
- [X] Filtrar el listado por año, mes, día o intervalo de fechas

***** Obtener el listado de los episodios de un podcast

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first_five = itertools.islice(episodes, 5)
for episode in first_five:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Les chants des abeilles', date='2019-02-16')


Episode(title='L'Apiculteur aveugle', date='2019-02-09')


Episode(title='Les chants du monde', date='2019-02-02')


Episode(title='Une année dans le monde', date='2019-01-26')


Episode(title='Aux origines du chocolat (8)', date='2019-01-19')


:end:

***** Para cada episodio obtener el título, la fecha, el URL del audio y su duración

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first = list(itertools.islice(episodes, 5))[0]
print ("   Title: " + first.title)
print ("    Date: " + first.date)
print ("     URL: " + first.url)
print ("Duration: " + str(first.duration))

#+end_src

#+RESULTS:
:results:
   Title: Les chants des abeilles
    Date: 2019-02-16
     URL: https://media.radiofrance-podcast.net/podcast09/11549-16.02.2019-ITEMA_21984001-0.mp3
Duration: 3253
:end:

***** Filtrar el listado por una palabra clave

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast
from franceinter.episodes.episodes_from_query import episodes_from_query

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
choco_episodes = episodes_from_query(episodes, "chocolat")
first_five = itertools.islice(choco_episodes, 5)
for episode in first_five:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Aux origines du chocolat (8)', date='2019-01-19')


Episode(title='Aux Origines du Chocolat (7)', date='2019-01-12')


Episode(title='Aux Origines du Chocolat (6)', date='2019-01-05')


Episode(title='Aux origines du chocolat (5)', date='2018-12-15')


Episode(title='Aux origines du chocolat (4)', date='2018-12-08')


:end:

***** Filtrar el listado por año, mes, día o intervalo de fechas

#+begin_src python
import itertools
import requests
import requests_cache
from datetime import date as Date
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast
from franceinter.episodes.episodes_between_dates import episodes_between_dates

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first_100 = itertools.islice(episodes, 100)
june_episodes = episodes_between_dates(first_100, Date(2018, 6, 1), Date(2018, 6, 30))
for episode in june_episodes:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Dans les ombres rêveuses', date='2018-06-30')


Episode(title='Le plomb et l'argent (4)', date='2018-06-23')


Episode(title='Le plomb et l'argent (3)', date='2018-06-16')


Episode(title='Le plomb et l'argent (2)', date='2018-06-09')


Episode(title='Le plomb et l'argent', date='2018-06-02')


:end:

**** TODO Mejoras

- [ ] Crear una nueva función =attribute_from_tag= para extraer un atributo de un tag con una clase determinada

Luego de la implementación de varias funciones vemos que hay un patrón de código que se repite: Se busca un tag HTML con una clase determinada, y de ese tag se extrae un atributo específico. Podemos ver ejemplos de este patrón en las funciones =title_from_tag=, =url_from_tag= y =author_from_tag= del módulo podcasts y otros tantos en las funciones de este módulo que extraen los atributos del episodio (p.ej. =title_from_tag=). Quizás sea necesario crear un nuevo módulo /Tags/ que contenga la lógica que se encarga de extraer datos de los tags HTML.

Una ventaja adicional de crear un nuevo módulo para manipular los tags es que podemos encapsular el uso de la biblioteca =BeautifulSoup=, y eso nos haría más sencillo el poder reemplazarla llegado el caso. Idealmente, no deberíamos hacer referencia a los objetos o clases de =BeautifulSoup= (p.ej. =bs4.elements.Tag=) en el resto de la aplicación.

- [ ] Crear un nuevo módulo =HTML= dentro de =Utils= que tenga la función =html_from_url=

A primera vista, la función =html_from_url= parecería ser una función trivial que quizás no debiera existir. Sin embargo, al encapsular las peticiones HTTP en esta función ganamos la posibilidad de cambiar la dependencia de la biblioteca =requests= en caso que sea necesario. Por ahora la colocamos en el módulo episodes, pero la idea es extraerla en un nuevo módulo =HTML= dentro de =Utils= para poder utilizarla en otras partes de la aplicación. Así podríamos utilizarla, por ejemplo, en la función =podcasts_from_url=.

- [ ] Extraer la función =tags_from_html= al nuevo módulo =utils.html=

Notamos que la función =tags_from_html= está repetida en los módulos Podcasts y Episodes. Esto nos sugiere que habría que hacer un cambio en el diseño para extraer esa lógica común a otro módulo, para eliminar la duplicación de ese código.

- [ ] Cambiar el tipo de dato de la fecha del episodio =Episode.date= para que sea un =datetime.date=

- [ ] Revisar el listado de episodios de "Sur les épaules de Darwin" porque está dando URL inválido para un episodio de 2011

#+begin_src txt
AssertionError: received tag has an invalid episode URL
 <button class="replay-button playable" data-clip-type="reecoute" data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-25-juin-2011" data-diffusion-title='"Entendre leurs voix" avec Florence Aubenas' data-diffusion-uuid="136e81f2-a7b2-11e0-b8ee-842b2b72cd1d" data-duration="54 min" data-duration-seconds="3241" data-emission-business-reference="16177" data-emission-title="Sur les épaules de Darwin" data-emission-uuid="6f540125-eb9f-11e1-a7b7-782bcb76618d" data-end-time="1551032275" data-extract-id="" data-extract-title="" data-is-aod="1" data-next-media-info="/get_next_audio/136e81f2-a7b2-11e0-b8ee-842b2b72cd1d" data-start-time="1551029034" data-theme="" data-theme-uuid="" data-url="https://s3-eu-west-1.amazonaws.com/cruiser-production/static/inter/sons/2011/07/s27/carrefour (2).mp3" data-uuid="0962e356-a7b2-11e0-b8ee-842b2b72cd1d" data-xiti-action="C" data-xiti-id="0962e356" data-xiti-level="4" data-xiti-libelle='Reecouter::Sur les épaules de Darwin-"Entendre leurs voix" avec Florence Aubenas-0962e356' data-xiti-trackable="true" data-xiti-type="A" title='réecouter "Entendre leurs voix" avec Florence Aubenas'><svg class="icon replay-button-icon icon-play-player"><use xlink:href="#icon_player-play" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-pause-player"><use xlink:href="#icon_player-pause" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-play"><use xlink:href="#icon_play" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-pause"><use xlink:href="#icon_pause" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-play-disabled"><use xlink:href="#icon_playdisabled" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-direct-audio"><use xlink:href="#icon_direct-audio" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg></button>
#+end_src

*** Submódulos
**** Episodes

#+begin_src python :tangle franceinter/episodes/__init__.py
__all__ = [
    "title_from_tag",
    "url_from_tag",
    "date_from_tag",
    "duration_from_tag",
    "episode_from_tag",
    "html_from_url",
    "lastpage_from_html",
    "pages_from_podcast",
    "tags_from_html",
    "episodes_from_response",
    "episodes_from_url",
    "episodes_from_filename",
    "episodes_from_podcast",
    "episodes_from_query",
    "episodes_between_dates"
]
#+end_src

**** Tests

#+begin_src python :tangle franceinter/episodes/tests/__init__.py
__all__ = [
    "test_title_from_tag", 
    "test_url_from_tag", 
    "test_date_from_tag", 
    "test_duration_from_tag", 
    "test_episode_from_tag", 
    "test_html_from_url",
    "test_lastpage_from_html",
    "test_pages_from_podcast",
    "test_tags_from_html",
    "test_episodes_from_response", 
    "test_episodes_from_url", 
    "test_episodes_from_filename", 
    "test_episodes_from_podcast", 
    "test_episodes_from_query", 
    "test_episodes_between_dates", 
    "examples_title_from_tag",
    "examples_url_from_tag",
    "examples_date_from_tag",
    "examples_duration_from_tag",
    "examples_episode_from_tag",
    "examples_html_from_url",
    "examples_lastpage_from_html",
    "examples_pages_from_podcast",
    "examples_tags_from_html",
    "examples_episodes_from_response",
    "examples_episodes_from_url",
    "examples_episodes_from_filename",
    "examples_episodes_from_podcast",
    "examples_episodes_from_query",
    "examples_episodes_between_dates"
]
#+end_src

*** title_from_tag
**** 1. Objetivo

Obtener el título de un episodio de un fragmento de HTML.

El título se puede obtener en dos lugares: 

- En el atributo =data-diffusion-title= de un =<button>= que tiene la clase =replay-button=
- En el atributo =title= de un =<a>= que tiene la clase =rich-section-list-item-content-title=

Elegimos sacarlo del button porque tiene todos los atributos que necesitamos obtener (titlulo, url, fecha y duración) en el mismo tag

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y el atributo =data-diffusion-title=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-diffusion-title=

#+begin_src python :tangle franceinter/episodes/tests/examples_title_from_tag.py
from bs4 import BeautifulSoup

def tag_with_title():
    html = '''<button class="replay-button" 
    data-diffusion-title="Sur les epaules de Darwin">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<p class="replay-button" 
    data-diffusion-title="Sur les epaules de Darwin">
</p>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.p
    return tag

def tag_without_class():
    html = '''<button data-diffusion-title="Sur les epaules de Darwin">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_title():
    html = '''<button class="replay-buttton"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def title_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    title = ""
    # validar que sea un <button>
    # validar que tenga la clase "replay-button"
    # revisar si tiene el atributo "data-diffusion-title"
    # si tiene el atributo se guarda en la variable title
    return title
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/title_from_tag.py
import bs4

def title_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = ""
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-diffusion-title" in tag.attrs):
        title = tag.attrs["data-diffusion-title"]
    return title

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y el atributo =data-diffusion-title=, devuelve el título
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve un string vacío
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve un string vacío
- Cuando recibe un =<button>= que no tiene el atributo =data-diffusion-title=, devuelve un string vacío

#+begin_src python :tangle franceinter/episodes/tests/test_title_from_tag.py
from franceinter.episodes.title_from_tag import title_from_tag
from franceinter.episodes.tests.examples_title_from_tag import *

def test_author_ok():
    tag = tag_with_title()
    assert ("Sur les epaules de Darwin" == title_from_tag(tag))

def test_invalid_tag():
    try:
        title_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert ("" == title_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == title_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == title_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_title_from_tag.py
#+end_src

*** url_from_tag
**** 1. Objetivo

Obtener el URL de descarga de un episodio a partir de un fragmento de html.

El URL se encuentra en el atributo =data-url= de un tag =<button>= que tiene la clase =replay-button=. 

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y un URL en el atributo =data-url=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-url=

#+begin_src python :tangle franceinter/episodes/tests/examples_url_from_tag.py
from bs4 import BeautifulSoup

def tag_with_url():
    html = '''<button class="replay-button" 
    data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_class():
    html = '''<button data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<a class="replay-button" 
    data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</a>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.a
    return tag

def tag_without_url():
    html = '''<button class="replay-button">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def url_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    url = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-url"
    # se guarda el valor del atributo en la variable url
    return url
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/url_from_tag.py
import bs4

def url_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    url = ""
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-url" in tag.attrs):
        url = tag.attrs["data-url"]
    return url

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y un URL en el atributo =data-url=, devuelve el URL
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve un string vacío
- Cuando recibe un tag =<button>= que no tiene la clase =replay-button=, devuelve un string vacío
- Cuando recibe un tag =<button>= que no tiene el atributo =data-url=, devuelve un string vacío

#+begin_src python :tangle franceinter/episodes/tests/test_url_from_tag.py
from franceinter.episodes.url_from_tag import url_from_tag
from franceinter.episodes.tests.examples_url_from_tag import *

def test_url_ok():
    tag = tag_with_url()
    assert (len(url_from_tag(tag)) > 0)

def test_invalid_url():
    try:
        url_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert ("" == url_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == url_from_tag(tag))

def test_url_not_found():
    tag = tag_without_url()
    assert ("" == url_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_url_from_tag.py
#+end_src

*** date_from_tag
**** 1. Objetivo

Obtener la fecha de emisión de un episodio a partir de un fragmento de html.

La fecha de emisión se encuentra en el atributo =data-diffusion-path= de un tag =<button>= que tiene la clase =replay-button=. En ese atributo, la fecha se encuentra al final del path en formato =día-mes-año=, con el mes en palabras.

Ejemplo: ~data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"~. 

Tenemos que extraer la fecha del path y devolverla en formato =YYYY-MM-DD=

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un =<button>= con la clase =replay-button= y una fecha en el atributo =data-diffusion-path=
- Un tag que no es un =<button>=
- Un =<button>= que no tiene la clase =replay-button=
- Un =<button>= que no tiene el atributo =data-diffusion-path=

#+begin_src python :tangle franceinter/episodes/tests/examples_date_from_tag.py
from bs4 import BeautifulSoup

def tag_with_date():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_class():
    html = '''<button 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<a class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</a>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.a
    return tag

def tag_without_date():
    html = '''<button class="replay-button">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

# la fecha es inválida porque el mes debe estar en francés
def tag_with_invalid_month():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-january-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

# la fecha es inválida porque el día es > 31
def tag_with_invalid_day():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-42-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def date_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    date = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-diffusion-path"
    # se guarda el valor del atributo en la variable attr

    # usar una expresión regular para extraer del atributo:
    # - dos números para el día [0-9] 
    # - seguidos de un guión
    # - seguido de una o más letras para el mes [a-z]
    # - seguidos de un guión
    # - seguidos de cuatro números para el año [0-9]
    # - seguidos del fin del string ($)

    # transformar el mes en números con una función auxiliar
    # darle formato YYYY-MM-DD
    # validar la fecha
    
    return date
    
def month_from_name(month_name):
    # recibe el nombre (janvier, fevrier, etc)
    # y devuelve el número (01, 02, etc)
    return month_num

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/date_from_tag.py
import bs4
import re
import datetime

def date_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    date = ""
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-diffusion-path" in tag.attrs):

        attr = tag.attrs["data-diffusion-path"]
        match = re.search("([0-9]{2})-([a-z]+)-([0-9]{4})$", attr)
        if match:
            date = "%s-%s-%s" % (
                match.group(3), 
                month_from_name(match.group(2)), 
                match.group(1))
            try:
                datetime.datetime.strptime(date, '%Y-%m-%d')
            except ValueError:
                assert False, invalid_date(date, tag)
    return date

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_date(date, tag):
    return "received tag has an invalid date [%s]\n %s" % (date, str(tag))

def month_from_name(month_name):
    try:
        return {
            'janvier': "01",
            'fevrier': "02",
            'mars': "03",
            'avril': "04",
            'mai': "05",
            'juin': "06",
            'juillet': "07",
            'aout': "08",
            'septembre': "09",
            'octobre': "10",
            'novembre': "11",
            'decembre': "12"
        }[month_name]
    except KeyError:
        assert False, invalid_month(month_name)

def invalid_month(month_name):
    return "invalid month name, %s received" % month_name

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un =<button>= con la clase =replay-button= y una fecha en el atributo =data-diffusion-path=, devuelve la fecha
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve un string vacío
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve un string vacío
- Cuando recibe un =<button>= que no tiene el atributo =data-diffusion-path=, devuelve un string vacío
- Cuando recibe un =<button>= que tiene una fecha inválida en el atributo =data-diffusion-path=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_date_from_tag.py
from franceinter.episodes.date_from_tag import date_from_tag
from franceinter.episodes.tests.examples_date_from_tag import *

def test_url_ok():
    tag = tag_with_date()
    assert ("2019-01-26" == date_from_tag(tag))

def test_invalid_tag():
    try:
        date_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert ("" == date_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == date_from_tag(tag))

def test_date_not_found():
    tag = tag_without_date()
    assert ("" == date_from_tag(tag))

def test_invalid_month():
    tag = tag_with_invalid_month()
    try:
        date_from_tag(tag)
    except AssertionError:
        assert True

def test_invalid_day():
    tag = tag_with_invalid_day()
    try:
        date_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_date_from_tag.py
#+end_src

*** duration_from_tag
**** 1. Objetivo

Obtener la duración en segundos de un episodio a partir de un fragmento de html.

La duración se encuentra en el atributo =data-duration-seconds= de un tag =<button>= que tiene la clase =replay-button=. 

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =int=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y una duración válida en el atributo =data-duration-seconds=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-duration-seconds=
- Un tag =<button>= con la clase =replay-button= pero que no contiene un número entero en el atributo =data-duration-seconds=

#+begin_src python :tangle franceinter/episodes/tests/examples_duration_from_tag.py
from bs4 import BeautifulSoup

def tag_with_duration():
    html = '''<button class="replay-button" 
data-duration-seconds="3256">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<p class="replay-button" 
data-duration-seconds="3256">
</p>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.p
    return tag

def tag_without_class():
    html = '''<button data-duration-seconds="3256"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_duration():
    html = '''<button class="replay-button"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_duration():
    html = '''<button class="replay-button" 
data-duration-seconds="six seconds">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def duration_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un integer
    duration = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-duration-seconds"
    # se guarda el valor del atributo en la variable duration

    # validar que la duración sea un número entero
    return duration

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/duration_from_tag.py
import bs4

def duration_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    duration = 0
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-duration-seconds" in tag.attrs):

        value = tag.attrs["data-duration-seconds"]
        try:
            duration = int(value)
        except ValueError:
            assert False, invalid_duration(value, tag)
    return duration

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_duration(duration, tag):
    return "data-duration-seconds attribute must be int, received %s instead\n%s" % (str(type(duration)), tag)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y una duración válida en el atributo =data-duration-seconds=, devuelve la duración
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe tag que no es un =<button>=, devuelve =0=
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve =0=
- Cuando recibe un =<button>= que no tiene el atributo =data-url=, devuelve =0=
- Cuando recibe un =<button>= con la clase =replay-button= pero que no contiene un número entero en el atributo =data-duration-seconds=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_duration_from_tag.py
from franceinter.episodes.duration_from_tag import duration_from_tag
from franceinter.episodes.tests.examples_duration_from_tag import *

def test_duration_ok():
    tag = tag_with_duration()
    assert (3256 == duration_from_tag(tag))

def test_invalid_url():
    try:
        duration_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert (0 == duration_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert (0 == duration_from_tag(tag))

def test_duration_not_found():
    tag = tag_without_duration()
    assert (0 == duration_from_tag(tag))

def test_invalid_duration():
    tag = tag_with_invalid_duration()
    try:
        duration_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_duration_from_tag.py
#+end_src

*** episode_from_tag
**** 1. Objetivo

Obtener un episodio de un fragmento de html.

Un episodio tiene cuatro propiedades, a saber:

- título :: es un =str= y es obligatorio
- url :: es un =str=, es obligatorio y debe ser un URL válido
- fecha de emisión :: es un =str=, es obligatoria y debe ser una fecha válida en formato =YYYY-MM-DD=
- duración en segundos :: es un =int= y es obligatoria

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un objeto =franceinter.episodes.episode=

Necesitamos entonces definir la clase =episode=

#+begin_src python :tangle franceinter/episodes/episode.py

class Episode:
    def __init__(self, title, url, date, duration):
        self.title = title
        self.url = url
        self.date = date
        self.duration = duration

    def __repr__(self):
        return "Episode(title='%s', date='%s')" % (
            self.title, self.date
        )

#+end_src

**** 3. Ejemplos

- Un tag que tiene todos los elementos para generar un episodio válido (título, URL, fecha y duración)
- Un tag que no es un =bs4.element.Tag=
- Un tag que no tiene el elemento del título
- Un tag que no tiene el elemento del URL
- Un tag que no tiene el elemento de la fecha
- Un tag que no tiene el elemento de la duración
- Un tag que tiene el elemento del URL, pero el URL no es válido
- Un tag que tiene el elemento de la fecha, pero ésta no es válida
- Un tag que tiene el elemento de la duración, pero ésta no es válida

#+begin_src python :tangle franceinter/episodes/tests/examples_episode_from_tag.py
from bs4 import BeautifulSoup

def tag_ok():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def invalid_tag():
    return "I am not a tag"

def tag_without_title():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_url():
    html = '''<button class="replay-button playable"
            data-diffusion-title="Une année dans le monde"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_date():
    html = '''<button class="replay-button playable"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_duration():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_url():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="this://isnot[?=>avalid[[/\\url"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_date():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-mercredi-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_duration():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="forty minutes"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def episode_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag

    # extraer el título con title_from_tag
    # validar que el título no sea un string vacío

    # extraer el url con url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer la fecha con date_from_tag
    # validar la fecha

    # extraer la duración con duration_from_tag
    # validar que la duración sea > 0

    # crear una instancia de franceinter.epidsodes.Episode
    # con el título, el url, la fecha y la duración
    return episode

#+end_src

**** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceinter/episodes/episode_from_tag.py
from franceinter.episodes.title_from_tag import title_from_tag
from franceinter.episodes.url_from_tag import url_from_tag
from franceinter.episodes.date_from_tag import date_from_tag
from franceinter.episodes.duration_from_tag import duration_from_tag
from franceinter.episodes.episode import Episode
from validators.url import url as is_valid_url
import datetime
import bs4

def episode_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = title_from_tag(tag)
    assert (title != ""), no_title(tag)

    url = url_from_tag(tag)
    assert (url != ""), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)

    date = date_from_tag(tag)
    assert (date != ""), no_date(tag)

    duration = duration_from_tag(tag)
    assert (duration != 0), invalid_duration(tag)

    return Episode(title, url, date, duration)

def no_url(tag):
    return "received tag does not have an episode URL\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid episode URL\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have an episode title\n %s" % str(tag)

def no_date(tag):
    return "received tag does not have an episode publication date\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_duration(tag):
    return "received tag has an invalid duration\n %s" % str(tag)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve un episodio (=franceinter.episodes.Episode=)
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento del título, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento del URL, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento de la fecha, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento de la duración, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento del URL, pero el URL no es válido, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento de la fecha, pero ésta no es válida, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento de la duración, pero ésta no es válida, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episode_from_tag.py
from franceinter.episodes.episode import Episode
from franceinter.episodes.episode_from_tag import episode_from_tag
from franceinter.episodes.tests.examples_episode_from_tag import *

def test_episode_ok():
    tag = tag_ok()
    episode = episode_from_tag(tag)
    assert isinstance(episode, Episode)
    assert (len(str(episode)) > 0)

def test_tag_without_title():
    tag = tag_without_title()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_url():
    tag = tag_without_url()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_date():
    tag = tag_without_date()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_duration():
    tag = tag_without_duration()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_url():
    tag = tag_with_invalid_url()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_date():
    tag = tag_with_invalid_date()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_duration():
    tag = tag_with_invalid_duration()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_invalid_tag():
    tag = invalid_tag()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episode_from_tag.py
#+end_src

*** html_from_url
**** 1. Objetivo

Obtener el HTML de un URL

**** 2. Firma

La función recibe un =str= con un URL válido y devuelve otro =str= con el HTML del URL

**** 3. Ejemplos

- Caso exitoso, un URL válido
- Un URL que no es un =str=
- Un URL inválido
- Un URL válido, pero que causa un =ConnectionError= porque el host no existe
- Un URL válido, pero de una página que no existe

#+begin_src python :tangle franceinter/episodes/tests/examples_html_from_url.py

def valid_url():
    url = "http://localhost:3000/episode-list.html"
    return url

def not_str_url():
    url = 1234
    return url

def invalid_url():
    url = "ghu:\\{this]url^is((not?valid.com"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def connection_error_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def html_from_url(url):
    # validar el URL
    # ejecutar la petición HTTP
    # si no hay error de conexión
    # devolver el texto de la respuesta

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/html_from_url.py
import requests
from validators.url import url as is_valid_url

def html_from_url(url):
    assert isinstance(url, str), invalid_str(url)
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        return response.text
    except requests.ConnectionError:
        assert False, connection_error(url)
        
def invalid_str(url):
    return "url parameter must be string, received %s instead" % str(type(url))

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un URL válido devuelve el HTML de la página
- Cuando recibe un URL que no es un =str=, lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=
- Cuando recibe un URL válido pero cuyo host no existe, lanza un =AssertionError=
- Cuando recibe un URL válido pero cuya página, devuelve un =str= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_html_from_url.py
import re
import pytest
import threading
from franceinter.episodes.html_from_url import html_from_url
from franceinter.episodes.tests.examples_html_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = valid_url()
    html = html_from_url(url)
    assert isinstance(html, str)
    assert (len(html) > 0)

def test_not_str_url(http_server):
    url = not_str_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True

def test_not_found_url(http_server):
    url = not_found_url()
    html = html_from_url(url)
    assert re.search("NOT_FOUND", html)

@pytest.mark.skip(reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = connection_error_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_html_from_url.py
#+end_src

*** lastpage_from_html
**** 1. Objetivo

Obtener la cantidad de páginas del HTML del listado de episodios.

En el HTML del listado de episodios de un podcast hay un paginador donde podemos encontrar la cantidad total de páginas, buscando un tag =<li>= que tiene la clase =last=. Dentro de ese =<li>= hay un link a la última página, que se encuentra en el atributo =href=. 

**** 2. Firma

La función recibe un =str= con el HTML y devuelve un =int= con el número de la última página.

**** 3. Ejemplos

- Caso exitoso, un HTML con el tag =<li>= que tiene la clase =last= y el =<a>= con el atributo =href= correcto
- Un HTML que no es un =str=
- Un HTML que no tiene el tag =<li>=
- Un HTML que tiene el tag =<li>=, pero éste no tiene la clase =last=
- Un HTML que tiene el tag =<li>= con la clase =last=, pero éste no tiene el =<a>=

#+begin_src python :tangle franceinter/episodes/tests/examples_lastpage_from_html.py

def html_ok():
    html = '''<div>
<li class="pager-item last">
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

def invalid_html():
    return 4321

def html_without_item():
    html = '''<div>
<span class="pager-item last">
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</span>
    </div>'''
    return html

def html_without_class():
    html = '''<div>
<li>
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

def html_without_link():
    html = '''<div>
<li>
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

#+end_src

**** 4. Boceto

#+begin_src python

def lastpage_from_html(html):
    # validar que el html sea un str
    # buscar un <li> con la clase =last=
    # si existe buscar dentro un <a> y extraer el atributo "href"
    # extraer al final del href uno o más números [0-9]
    lastpage = 1
    return lastpage

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/lastpage_from_html.py
from bs4 import BeautifulSoup
import re

def lastpage_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    lastpage = 1
    item = soup.find("li", class_="last")
    if item:
        href = item.find("a").attrs["href"]
        match = re.search("([0-9]+)$", href)
        if match:
            lastpage = int(match.groups()[0])
    return lastpage
     
def invalid_html(html):
    return "html parameter must be a string, %s received" % str(type(html))

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un HTML con el tag =<li>= que tiene la clase =last=, devuelve el número de la última página
- Cuando recibe un HTML que no es un =str=, lanza un =AssertionError=
- Cuando recibe un HTML que no tiene el tag =<li>=, devuelve la primera página (=1=)
- Cuando recibe un HTML que tiene el tag =<li>=, pero éste no tiene la clase =last=, devuelve la primera página (=1=)
- Cuando recibe un HTML que tiene el tag =<li>= con la clase =last=, pero éste no tiene el =<a>=, devuelve la primera página (=1=)

#+begin_src python :tangle franceinter/episodes/tests/test_lastpage_from_html.py
from franceinter.episodes.lastpage_from_html import lastpage_from_html
from franceinter.episodes.tests.examples_lastpage_from_html import *

def test_html_ok():
    html = html_ok()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 22)

def test_invalid_html():
    html = invalid_html()
    try:
        lastpage = lastpage_from_html(html)
    except AssertionError:
        assert True

def test_html_without_item():
    html = html_without_item()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

def test_html_without_class():
    html = html_without_class()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

def test_html_without_link():
    html = html_without_link()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_lastpage_from_html.py
#+end_src

*** pages_from_podcast
**** 1. Objetivo

Obtener un listado de URLs de las páginas del listado de episodios a partir de los datos de un podcast.

**** 2. Firma

La función recibe un objeto =franceinter.podcasts.Podcast= y devuelve un =GeneratorType= con los URLs de las páginas del historial de episodios.

**** 3. Ejemplos

- Caso exitoso, un podcast válido
- Un podcast con el URL vacío
- Un podcast con el URL inválido
- Un objeto que no es un =franceinter.podcasts.Podcast=

#+begin_src python :tangle franceinter/episodes/tests/examples_pages_from_podcast.py
from franceinter.podcasts.podcast import Podcast

def valid_podcast():
    title = "Sur les epaules de Darwin"
    url = "http://localhost:3000/episode-list.html"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_empty_url():
    title = "Sur les epaules de Darwin"
    url = ""
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_invalid_url():
    title = "Sur les epaules de Darwin"
    url = "ghu:\\{this]url^is((not?valid.com"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def invalid_podcast():
    return "this is not a podcast object"

#+end_src

**** 4. Boceto

#+begin_src python

def pages_from_podcast(podcast):
    # validar que el podcast sea una instancia de Podcast
    # validar el url
    # obtener el HTML del URL
    # obtener el número de la última página del HTML
    # generar los URLs de las páginas agregando ?p=XX al URL del podcast
    yield page_url

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/pages_from_podcast.py
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.html_from_url import html_from_url
from franceinter.episodes.lastpage_from_html import lastpage_from_html

def pages_from_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    html = html_from_url(podcast.url)
    lastpage = lastpage_from_html(html)
    for page_number in range(1, lastpage + 1):
        page_url = podcast.url + "?p=" + str(page_number)
        yield page_url

def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % str(type(podcast))

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un podcast válido, devuelve un =GeneratorType= con los URLs de las páginas del podcast
- Cuando recibe un podcast con el URL vacío, lanza un =AssertionError=
- Cuando recibe un podcast con el URL inválido, lanza un =AssertionError=
- Cuando recibe un objeto que no es un =franceinter.podcasts.Podcast=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_pages_from_podcast.py
import types
import pytest
import threading
from validators.url import url as is_valid_url
from franceinter.episodes.pages_from_podcast import pages_from_podcast
from franceinter.episodes.tests.examples_pages_from_podcast import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    podcast = valid_podcast()
    pages = pages_from_podcast(podcast)
    assert isinstance(pages, types.GeneratorType)
    for page in pages:
        assert is_valid_url(page)

def test_podcast_with_empty_url():
    podcast = podcast_with_empty_url()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    podcast = podcast_with_invalid_url()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

def test_invalid_podcast():
    podcast = invalid_podcast()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_pages_from_podcast.py
#+end_src

*** tags_from_html
**** 1. Objetivo

Obtener un array de tags con los fragmentos de html que tienen el detalle del episodio (título, URL, fecha de emisión y duración) a partir del html de la página con el listado de episodios.

Hay que extraer todos los =<button>= que tengan la clase =replay-button= y que estén dentro de un =<div>= que tiene clase =diffusions-list=. Necesitamos extraer solamente los botones que están dentro de este div porque en el HTML de la página hay otros botones que son de otros podcasts.

**** 2. Firma

La función recibe un =str= con el html de la página y devuelve un =GeneratorType= de elementos =bs4.element.Tag=

**** 3. Ejemplos

- Un html que tiene un =<div>= con la clase buscada y que contiene varios =<button>= con la clase =replay-button=
- Un html que no es un =str=
- Un html que no tiene ningún =<div>=
- Un html que tiene varios =<div>= pero que ninguno tiene la clase =diffusions-list=
- Un html que tiene un =<div>= con la clase buscada y que contiene algunos =<buttons>= con la clase =replay-button= y otros que no la tienen

#+begin_src python :tangle franceinter/episodes/tests/examples_tags_from_html.py
from bs4 import BeautifulSoup
import random

def html_with_buttons(how_many):
    btn_class = "replay-button"
    buttons = map(lambda x: button("click here", btn_class), range(how_many))
    cls_name = "diffusions-list"
    return html(buttons, cls_name)

def html_is_not_string():
    return 42

def html_without_divs():
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>'''
    return html

def html_divs_without_class(how_many):
    content = "blablabla"
    divs = map(lambda x: div(content), range(how_many))
    return html(divs)

def html_some_buttons_with_class(how_many_with, how_many_without):
    cls = "replay-button"
    buttons_with = list(map(lambda x: button("click here", cls), range(how_many_with)))
    buttons_without = list(map(lambda x: button("click here"), range(how_many_without)))
    buttons = buttons_with + buttons_without
    random.shuffle(buttons)
    class_name = "diffusions-list"
    return html(buttons, class_name)

def button(content, class_name=""):
    attr = ""
    if class_name:
        attr = 'class="%s"' % class_name
    html = '''<button %s>%s</button>''' % (attr, content)
    soup = BeautifulSoup(html, "html.parser")
    return soup.button

def div(content):
    html = '''<div>%s</div>''' % content
    soup = BeautifulSoup(html, "html.parser")
    return soup.div

def html(elements, class_name=""):
    attr = ""
    if class_name:
        attr = 'class="%s"' % class_name
    content = "".join(map(lambda e: str(e), elements))
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<div %s>
%s
</div>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    ''' % (attr, content)
    return html
    
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup

def tags_from_html(html):
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # buscar el <div> que tiene la clase "diffusions-list"
    # dentro de ese <div> filtrar todos los <button> 
    # que tienen la clase =replay-button=
    yield tag

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/tags_from_html.py
from bs4 import BeautifulSoup

def tags_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    div = soup.find("div", class_="diffusions-list")
    if div:
        buttons = div.find_all("button", class_="replay-button")
        for tag in buttons:
            yield tag

def invalid_html(html):
    return "html parameter must be a string, received %s instead" % type(html)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un html que tiene un =<div>= con la clase buscada y que contiene varios =<button>= con la clase =replay-button=, devuelve un =GeneratorType= que tiene tantos elementos como =<button>= haya en el html
- Cuando recibe un html que no es un string, lanza un =AssertionError=
- Cuando recibe un html que no tiene ningún =<div>=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene varios =<div>= pero ninguno tiene la clase =rich-section-list-item-content=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen, devuelve un =GeneratorType= con solamente los =<div>= que tienen la clase

#+begin_src python :tangle franceinter/episodes/tests/test_tags_from_html.py
import types
from franceinter.episodes.tags_from_html import tags_from_html
from franceinter.episodes.tests.examples_tags_from_html import *

def test_html_with_buttons():
    html = html_with_buttons(5)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 5)

def test_html_is_not_string():
    try:
        html = html_is_not_string()
        tags = list(tags_from_html(html))
    except AssertionError:
        assert True

def test_html_without_divs():
    html = html_without_divs()
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_divs_without_class():
    html = html_divs_without_class(4)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_some_buttons_with_class():
    html = html_some_buttons_with_class(2,3)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 2)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_tags_from_html.py
#+end_src

*** episodes_from_tags
**** 1. Objetivo

Generar un listado de episodios a partir de un listado de fragmentos de HTML tomados de la página

**** 2. Firma

La función recibe un listado de objetos =bs4.element.Tag= y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

Vamos a aceptar tanto un =list= como un =GeneratorType=

**** 3. Ejemplos

- Un objeto que no es iterable
- Una lista vacía
- Una lista con tags válidos
- Una lista con objetos que no son del tipo =bs4.element.Tag=
- Una lista con tags válidos y un tag inválido (sin el título o el URL)

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_tags.py
import random
from franceinter.episodes.tags_from_html import tags_from_html
from franceinter.episodes.tests.examples_episode_from_tag import (
    tag_ok,
    tag_without_title
)

def invalid_list():
    return 123

def empty_list():
    return []

def list_without_tags():
    return [1, 2, 3, 4, 5]

def list_with_valid_tags(how_many):
    html = "<div class='diffusions-list'>"
    for i in range(1, how_many):
        html+= str(tag_ok())
    html+= "</div>"
    tags = tags_from_html(html)
    return tags

def list_with_invalid_tag(how_many):
    tags = list(list_with_valid_tags(how_many - 1))
    tags.append(tag_without_title())
    random.shuffle(tags)
    return tags

#+end_src

**** 4. Boceto

#+begin_src python
from franceinter.episodes.tags_from_html import tags_from_html

def podcasts_from_tags(tags):
    # validar que tags sea un GeneratorType
    # para cada tag de la lista
    # usar episode_from_tag() para obtener un podcast
    # yield posdcast

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_tags.py
from franceinter.episodes.episode_from_tag import episode_from_tag

def episodes_from_tags(tags):
    try:
        it = iter(tags)
    except TypeError:
        assert False, invalid_tags(tags)
    for tag in tags:
        yield episode_from_tag(tag)

def invalid_tags(tags):
    return "tags parameter must be iterable, received %s instead" % type(tags)
#+end_src

**** 6. Casos de prueba

- Si recibe un objeto que no es iterable, lanza un =AssertionError=
- Si recibe una lista vacía, devuelve un =GeneratorType= vacío
- Si recibe una lista de tags válidos, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Si recibe una lista con objetos que no son del tipo =bs4.element.Tag=, lanza un =AssertionError=
- Si recibe una lista con algún tag inválido (que no tenga el título o el URL), lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_tags.py
import types
from franceinter.episodes.episodes_from_tags import episodes_from_tags
from franceinter.episodes.tests.examples_episodes_from_tags import *
from franceinter.episodes.episode import Episode

def test_invalid_list():
    tags = invalid_list()
    try:
        episodes = list(episodes_from_tags(tags))
    except AssertionError:
        assert True

def test_empty_list():
    tags = empty_list()
    episodes = episodes_from_tags(tags)
    assert isinstance(episodes, types.GeneratorType)
    assert (len(list(episodes))==0)

def test_list_with_valid_tags():
    tags = list_with_valid_tags(6)
    episodes = episodes_from_tags(tags)
    assert isinstance(episodes, types.GeneratorType)
    for e in episodes:
        assert (isinstance(e, Episode))

def test_list_without_tags():
    tags = list_without_tags()
    try:
        episodes = list(episodes_from_tags(tags))
    except AssertionError:
        assert True

def test_list_with_invalid_tag():
    tags = list_with_invalid_tag(6)
    episodes = episodes_from_tags(tags)
    try:
        for e in episodes:
            assert (isinstance(e, Episode))
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_tags.py
#+end_src

*** episodes_from_response
**** 1. Objetivo

Extraer el listado de episodios de la respuesta de una petición HTTP

**** 2. Firma

La función recibe una =requests.model.Response= y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Una respuesta válida, con el HTML de una página del listado de episodios
- Una respuesta inválida, que no es de la clase =requests.model.Response=
- Una respuesta válida, pero que tiene el HTML de otra página

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_response.py
from requests.models import Response

def response_ok():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/episode-list.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

def invalid_response():
    return "i am not a Response"

def wrong_page_response():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/wrong-page.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

#+end_src

**** 4. Boceto

#+begin_src python
import requests

def episodes_from_response(resp):
    # validar la respuesta
    # obtener el HTML de resp.text
    # extraer los tags usando tags_from_html
    # obtener los podcasts usando episodes_from_tags

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_response.py
import requests
from franceinter.episodes.tags_from_html import tags_from_html
from franceinter.episodes.episodes_from_tags import episodes_from_tags

def episodes_from_response(resp):
    assert isinstance(resp, requests.models.Response), invalid_type(resp)
    html = resp.text
    tags = tags_from_html(html)
    episodes = episodes_from_tags(tags)
    return episodes
    
def invalid_type(resp):
    return "resp parameter must be a requests.models.Response, received %s instead" % type(resp)

#+end_src

**** 6. Casos de prueba

- Cuando recibe una respuesta válida, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Cuando recibe una respuesta que no es de la clase =requests.model.Response=, lanza un =AssertionError=
- Cuando recibe una respuesta válida que tiene el HTML de otra página, devuelve un =GeneratorType= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_response.py
import types
from franceinter.episodes.episode import Episode
from franceinter.episodes.episodes_from_response import episodes_from_response
from franceinter.episodes.tests.examples_episodes_from_response import *

def test_response_ok():
    resp = response_ok()
    episodes = episodes_from_response(resp)
    assert isinstance(episodes, types.GeneratorType)
    for e in episodes:
        assert isinstance(e, Episode)

def test_invalid_response():
    resp = invalid_response()
    try:
        episodes = episodes_from_response(resp)
    except AssertionError:
        assert True
    
def test_wrong_page_response():
    resp = wrong_page_response()
    episodes = episodes_from_response(resp)
    assert isinstance(episodes, types.GeneratorType)
    assert (len(list(episodes)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_response.py
#+end_src

*** episodes_from_url
**** 1. Objetivo

Extraer el listado de episodios desde un URL

**** 2. Firma

La función recibe un URL y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un URL con el listado de episodios
- Un URL de otra página, que no tiene episodios
- Un URL de una página inexistente, que dispare un error 404 (not found)
- Un URL de un sitio inexistente, que dispare un error de DNS
- Un URL inválido

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_url.py

def url_ok():
    url = "http://localhost:3000/episode-list.html"
    return url

def wrong_page_url():
    url = "http://localhost:3000/wrong-page.html"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def wrong_site_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

def invalid_url():
    url = "ht pt:\\hostlocal:3000/this-url-is-not-valid.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_url(url):
    # validar el url
    # realizar una petición al url
    # obtener la respuesta del url
    # obtener los episodes llamando a episodes_from_response
    # revisar si da un error de conexión
    return episodes

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_url.py
import requests
from validators.url import url as is_valid_url
from franceinter.episodes.episodes_from_response import episodes_from_response

def episodes_from_url(url):
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        episodes = episodes_from_response(response)
        return episodes
    except requests.ConnectionError:
        assert False, connection_error(url)

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url
#+end_src

**** 6. Casos de prueba

- Cuando recibe un URL con el listado de episodios, devuelve un =GeneratorType= de objetos =Episode=
- Cuando recibe un URL de otra página, que no tiene episodios, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de una página inexistente, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de un sitio inexistente (error de DNS), lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_url.py
import pytest
import threading
import types
from franceinter.episodes.episode import Episode
from franceinter.episodes.episodes_from_url import episodes_from_url
from franceinter.episodes.tests.examples_episodes_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = url_ok()
    gen = episodes_from_url(url)
    assert isinstance(gen, types.GeneratorType)
    episodes = list(gen)
    assert (len(episodes) > 0)
    for e in episodes:
        assert isinstance(e, Episode)

def test_wrong_page_url(http_server):
    url = wrong_page_url()
    episodes = list(episodes_from_url(url))
    assert (len(episodes) == 0)

def test_not_found_url(http_server):
    url = not_found_url()
    episodes = list(episodes_from_url(url))
    assert (len(episodes) == 0)

@pytest.mark.skip(reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = wrong_site_url()
    try:
        episodes = list(episodes_from_url(url))
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        episodes = episodes_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_url.py
#+end_src

*** episodes_from_filename
**** 1. Objetivo

Extraer un listado de episodios desde un archivo

**** 2. Firma

La función recibe un =str= con el nombre del archivo y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un archivo HTML que tiene un listado de episodios
- Un archivo HTML de otra página, que no tiene episodios
- Un archivo que no existe
- Un nombre de archivo que no es un =str=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_filename.py

def ok_filename():
    return "./franceinter/html/episode-list.html"

def wrong_filename():
    return "./franceinter/html/wrong-page.html"

def not_found_filename():
    return "./franceinter/html/this-file-does-not-exist.html"

def invalid_filename():
    return [1, 2, 3]

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_filename(filename):
    # validar que filename sea un str
    # validar que el archivo exista
    episodes = []
    # crear un requests.models.Response con el contenido del archivo
    # obtener los episodios llamando a episodes_from_response
    return episodes
     
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_filename.py
from requests.models import Response
from franceinter.episodes.episodes_from_response import episodes_from_response

def episodes_from_filename(filename):
    assert isinstance(filename, str), invalid_filename(filename)
    resp = Response()
    episodes = []
    try:
        with open(filename, "rb") as f:
            resp._content = f.read()
            episodes = episodes_from_response(resp)
    except (OSError, IOError) as error:
        assert False, not_found(filename, error)
    return episodes

def invalid_filename(filename):
    return "filename parameter must be a str, %s received instead" % filename

def not_found(filename, error):
    return "filename %s cannot be read, thrown error :\n%s" % (filename, error)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un archivo HTML que tiene un listado de podcasts, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Cuando recibe un archivo HTML de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un archivo que no existe, lanza un =AssertionError=
- Cuando recibe un nombre de archivo que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_filename.py
import types
from franceinter.episodes.episode import Episode
from franceinter.episodes.episodes_from_filename import episodes_from_filename
from franceinter.episodes.tests.examples_episodes_from_filename import *

def test_ok_filename():
    filename = ok_filename()
    episodes = episodes_from_filename(filename)
    assert isinstance(episodes, types.GeneratorType)
    episodes = list(episodes)
    assert (len(episodes) > 0)
    for e in episodes:
        assert isinstance(e, Episode)

def test_wrong_filename():
    filename = wrong_filename()
    episodes = episodes_from_filename(filename)
    assert isinstance(episodes, types.GeneratorType)
    episodes = list(episodes)
    assert (len(episodes) == 0)

def test_not_found_filename():
    filename = not_found_filename()
    try:
        episodes = episodes_from_filename(filename)
    except AssertionError:
        assert True

def test_invalid_filename():
    filename = invalid_filename()
    try:
        episodes = episodes_from_filename(filename)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_episodes_from_filename.py
#+end_src

#+RESULTS:
:results:
:end:

*** episodes_from_podcast
**** 1. Objetivo

Obtener el listado de episodios de un podcast.

Con el podcast obtiene el listado de páginas y de cada página extrae el listado de episodios.

**** 2. Firma

La función recibe un =franceinter.podcast.Podcast= y devuelve un =GeneratorType= de =franceinter.episodes.Episode=

**** 3. Ejemplos

- Caso exitoso, un podcast válido
- Un podcast con el URL vacío
- Un podcast con el URL inválido
- Un objeto que no es un =franceinter.podcasts.Podcast=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_podcast.py
from franceinter.podcasts.podcast import Podcast

def valid_podcast():
    title = "Sur les epaules de Darwin"
    url = "http://localhost:3000/episode-list.html"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_empty_url():
    title = "Sur les epaules de Darwin"
    url = ""
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_invalid_url():
    title = "Sur les epaules de Darwin"
    url = "ghu:\\{this]url^is((not?valid.com"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def invalid_podcast():
    return "this is not a podcast object"

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_podcast(podcast):
    # validar el podcast
    # obtener el listado de URLs usando pages_from_podcast
    # para cada URL obtener los episodios usando episodes_from_url
    yield episode

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_podcast.py
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.pages_from_podcast import pages_from_podcast
from franceinter.episodes.episodes_from_url import episodes_from_url

def episodes_from_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    pages = pages_from_podcast(podcast)
    for url in pages:
        episodes = episodes_from_url(url)
        for episode in episodes:
            yield episode

def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % str(type(podcast))

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un podcast válido, devuelve un =GeneratorType= con los episodios del podcast
- Cuando recibe un podcast con el URL vacío, lanza un =AssertionError=
- Cuando recibe un podcast con el URL inválido, lanza un =AssertionError=
- Cuando recibe un objeto que no es un =franceinter.podcasts.Podcast=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_podcast.py
import types
import pytest
import threading
from franceinter.episodes.episode import Episode
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast
from franceinter.episodes.tests.examples_episodes_from_podcast import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    podcast = valid_podcast()
    episodes = episodes_from_podcast(podcast)
    assert isinstance(episodes, types.GeneratorType)
    for episode in episodes:
        assert isinstance(episode, Episode)

def test_podcast_with_empty_url():
    podcast = podcast_with_empty_url()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    podcast = podcast_with_invalid_url()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

def test_invalid_podcast():
    podcast = invalid_podcast()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_episodes_from_podcast.py
#+end_src

*** episodes_from_query
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que contienen una palabra clave en el título

Se debe buscar la palabra clave sin tener encuenta las mayúsculas o minúsculas (case insensitive match)

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y un =str=, y devuelve un =filter= de objetos =franceinter.episodes.Episode=

Para el listado de episodios vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que tienen la palabra clave el título 
- Un listado de 5 episodios en el que ninguno tiene la palabra clave en el título
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Una query que no es un =str=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_query.py
import random
from franceinter.episodes.episode import Episode

def episodes_with_word_in_title(word):
    episodes = list(some_episodes(3))
    ep = new_episode()
    ep.title+= " " + word
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def some_episodes(how_many):
    for i in range(0, how_many):
        yield new_episode()

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_query():
    return 42

def new_episode():
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = "2018-09-12"
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_query(episodes, query):
    # validar que los episodios sean iterables
    # validar que la query sea un str
    # validar que cada episodio sea un Episode
    # filtrar los episodios con una función que devuelva true 
    # si el título contiene la query

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_query.py
import re
from franceinter.episodes.episode import Episode

def episodes_from_query(episodes, query):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(query, str), invalid_query(query)
    valid_episodes = filter(is_episode, episodes)
    contains_query = query_matcher(query)
    return filter(contains_query, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def query_matcher(query):
    def matcher(episode):
        return re.search(query, episode.title, re.IGNORECASE)
    return matcher
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_query(query):
    return "query parameter must be a string, received %s instead" % type(query)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que tienen la palabra clave el título, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno tiene la palabra clave en el título, devuelve un =filter= vacío
- Cuando recibe un listado de podcasts que no es iterable, lanza un =AssertionError=
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Una query que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_query.py
import types
from franceinter.episodes.episodes_from_query import episodes_from_query
from franceinter.episodes.tests.examples_episodes_from_query import *

def test_episodes_with_word_in_title():
    episodes = episodes_with_word_in_title("radio")
    result = episodes_from_query(episodes, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_without_word():
    episodes = some_episodes(5)
    result = episodes_from_query(episodes, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        result = episodes_from_query(episodes, "radio")
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        result = episodes_from_query(episodes, "radio")
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_query():
    episodes = some_episodes(10)
    query = invalid_query()
    try:
        result = episodes_from_query(episodes, query)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_query.py
#+end_src

*** episodes_between_dates
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados entre dos fechas

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y dos objetos =datetime.date= (de inicio y fin del intervalo), y devuelve un =filter= de objetos =franceinter.episodes.Episode=

Para el listado de episodios vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados entre las fechas dadas
- Un listado de 5 episodios en el que ninguno fue publicado entre las fechas dadas
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Una fecha de inicio que no es un =datetime.date=
- Una fecha de fin que no es un =datetime.date=
- Una fecha de inicio que es posterior a la fecha de fin

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_between_dates.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episode import Episode

def some_episodes_between_dates(starting_at, ending_at):
    date_outside = ending_at + TimeDelta(days=5)
    episodes = list(some_episodes_with_date(3, date_outside))
    date_between = random_date_between(starting_at, ending_at)
    ep = new_episode(date_between)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def random_date_between(date1, date2):
    days = (date2 - date1).days
    random_days = random.randint(0, days)
    random_date = date1 + TimeDelta(days=random_days)
    return random_date

def some_episodes_with_date(how_many, episode_date):
    for i in range(0, how_many):
        yield new_episode(episode_date)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_date():
    return 42

def new_episode(episode_date):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = str(episode_date)
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_between_dates(episodes, starting_at, ending_at):
    # validar que los episodios sean iterables
    # validar que las fechas sean datetime.date
    # validar que cada episodio sea un Episode
    # filtrar los episodios con una función que devuelva true 
    # si la fecha está entre starting_at y ending_at

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_between_dates.py
from datetime import date as Date, datetime as DateTime
from franceinter.episodes.episode import Episode

def episodes_between_dates(episodes, starting_at, ending_at):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(starting_at, Date), invalid_date(starting_at)
    assert isinstance(ending_at, Date), invalid_date(ending_at)
    valid_episodes = filter(is_episode, episodes)
    is_between_dates = date_filter(starting_at, ending_at)
    return filter(is_between_dates, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def date_filter(starting_at, ending_at):
    def matcher(episode):
        episode_date = DateTime.strptime(episode.date, "%Y-%m-%d").date()
        return ((starting_at <= episode_date) 
                and (episode_date <= ending_at))
    return matcher
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_date(date):
    return "starting_at and ending_at parameters must be a date, received %s instead" % type(date)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados entre las fechas dadas, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado entre las fechas dadas, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe una fecha de inicio que no es un =datetime.date=, lanza un =AssertionError=
- Cuando recibe una fecha de fin que no es un =datetime.date=, lanza un =AssertionError=
- Cuando recibe una fecha de inicio que es posterior a la fecha de fin, devuelve un =filter= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_between_dates.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episodes_between_dates import episodes_between_dates
from franceinter.episodes.tests.examples_episodes_between_dates import *

def test_episodes_between_dates():
    starting_at = Date.today()
    ending_at = Date.today() + TimeDelta(days=5)
    episodes = some_episodes_between_dates(starting_at, ending_at)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_outside_interval():
    date_outside = Date.today() - TimeDelta(days=30)
    episodes = some_episodes_with_date(5, date_outside)
    starting_at = Date.today()
    ending_at = Date.today() + TimeDelta(days=5)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        starting_at = Date.today()
        ending_at = Date.today() + TimeDelta(days=5)
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        starting_at = Date.today()
        ending_at = Date.today() + TimeDelta(days=5)
        result = episodes_between_dates(episodes, starting_at, ending_at)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_starting_date():
    episode_date = Date.today() + TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = invalid_date()
    ending_at = Date.today() + TimeDelta(days=5)
    try:
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_ending_date():
    episode_date = Date.today() + TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = Date.today()
    ending_at = invalid_date()
    try:
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_interval():
    episode_date = Date.today() - TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = Date.today()
    ending_at = Date.today() - TimeDelta(days=5)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_between_dates.py
#+end_src

** HTML

Vamos a usar cURL para descargar el HTML de las diferentes páginas que necesitamos parsear, así podemos desarrollar y ejecutar los casos de prueba sin tener conexión a Internet. Guardamos los archivos en la carpeta =franceinter/html=.

#+begin_src sh
mkdir -p ./franceinter/html
curl -o ./franceinter/html/podcast-list.html https://www.franceinter.fr/emissions
head -n 1000 ./franceinter/html/podcast-list.html > franceinter/html/podcast-list-short.html
curl -o ./franceinter/html/episode-list.html https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin
curl -o ./franceinter/html/wrong-page.html https://www.pagina12.com.ar
ls -alh ./franceinter/html
#+end_src

#+RESULTS:
:results:
total 10968
drwxr-xr-x  5 martin  staff   160B Feb  8 17:18 .
drwxr-xr-x  7 martin  staff   224B Feb  8 17:18 ..
-rw-r--r--  1 martin  staff   276K Feb  8 17:18 episode-list.html
-rw-r--r--  1 martin  staff   4.1M Feb  8 17:18 podcast-list.html
-rw-r--r--  1 martin  staff    20K Feb  8 17:18 wrong-page.html
:end:

* Herramientas
** Módulos

#+begin_src python :tangle utils/__init__.py
__all__ = ["http_server"]
#+end_src

** LocalFolderHTTPServer

Para poder ejecutar los casos de prueba que realizan peticiones HTTP, necesitamos levantar un servidor HTTP desde una carpeta local.

https://stackoverflow.com/questions/39801718/how-to-run-a-http-server-which-serve-a-specific-path/46332163#46332163

#+begin_src python :tangle utils/http_server.py
import os
try:
    # python 2
    from SimpleHTTPServer import SimpleHTTPRequestHandler
    from BaseHTTPServer import HTTPServer as BaseHTTPServer
except ImportError:
    # python 3
    from http.server import HTTPServer as BaseHTTPServer, SimpleHTTPRequestHandler

class HTTPHandler(SimpleHTTPRequestHandler):
    """This handler uses server.base_path instead of always using os.getcwd()"""
    def translate_path(self, path):
        path = SimpleHTTPRequestHandler.translate_path(self, path)
        relpath = os.path.relpath(path, os.getcwd())
        fullpath = os.path.join(self.server.base_path, relpath)
        return fullpath

class LocalFolderHTTPServer(BaseHTTPServer):
    """The main server, you pass in base_path which is the path you want to serve requests from"""
    def __init__(self, base_path, server_address, RequestHandlerClass=HTTPHandler):
        self.base_path = base_path
        BaseHTTPServer.__init__(self, server_address, RequestHandlerClass)   
#+end_src

* Tests
*** Ejecutar los casos de prueba

#+begin_src sh
pytest
#+end_src

*** Generar el reporte de cobertura

#+begin_src sh
pytest --cov-report html:coverage --cov ./franceinter/ 
#+end_src

Para visualizar el reporte se debe abrir el archivo =./coverage/index.html= con el navegador

#+begin_src sh
firefox --new-tab ./coverage/index.html
#+end_src

* Apéndices
*** listar podcasts

#+begin_src python :python python-3.6 :results drawer
import franceinter.podcasts_old as fr

podcasts = fr.podcasts_from_file('./downloads/emissions.html')
#podcasts = fr.podcasts_from_url('https://www.franceinter.fr/emissions')

#return list(podcasts)[39]
print(list(fr.podcast_search("darwin", podcasts)))
#+end_src

#+RESULTS:
:results:
[{'author': 'Jean Claude Ameisen', 'title': 'Sur les épaules de Darwin', 'url': 'https://franceinter.fr/emissions/sur-les-epaules-de-darwin'}]
:end:

*** implementación de referencia

#+begin_src python :python python-3.6 :results output
from bs4 import BeautifulSoup
from urllib.request import urlopen
import re

def slugify(string):
    return re.sub(r'[-\s]+', '-',
                  (re.sub(r'[^\w\s-]', '',string).strip().lower()))

def linkToDate(link):
    date = ""
    rd = re.search("([0-9]{2})-([a-z]+)-([0-9]{4})$", link)
    if rd:
        date = rd.group(3) + "-" + monthNumber(rd.group(2)) + "-" + rd.group(1)
    return date
        
def monthNumber(month):
    return {
        'janvier': "01",
        'fevrier': "02",
        'mars': "03",
        'avril': "04",
        'mai': "05",
        'juin': "06",
        'juillet': "07",
        'aout': "08",
        'septembre': "09",
        'octobre': "10",
        'novembre': "11",
        'decembre': "12"
    }[month]

    
r = urlopen('https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin?p=2').read()
soup = BeautifulSoup(r, "html.parser")
#print(soup.prettify())
buttons = soup.find_all("button", class_="replay-button")

for button in buttons:
    if "data-url" in button.attrs:
        #print(button.attrs)
        link = button.attrs["data-diffusion-path"]
        date = linkToDate(link)
        filename = date + "-" + slugify(button.attrs["data-diffusion-title"]) + ".mp3"
        #print(filename)
        print("curl -o " + filename + " " + button.attrs["data-url"])
        #print("")

#+end_src

#+RESULTS:
:results:
:end:

