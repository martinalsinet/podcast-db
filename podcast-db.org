#+title: Podcast Database
#+author: Martín Alsinet
#+date: 2019
#+options: ^:nil num:nil ':t
#+language: es
#+property: header-args:python :python python-3.6 :results output drawer :mkdirp yes
#+property: header-args:sh :results raw drawer
#+todo: TODO DOING | DONE

* Indice                                                                :TOC:
- [[#motivación][Motivación]]
  - [[#literate-programming][Literate Programming]]
  - [[#how-to-design-programs][How to Design Programs]]
- [[#diseño][Diseño]]
  - [[#fuentes-de-podcasts][Fuentes de podcasts]]
  - [[#funcionalidades][Funcionalidades]]
- [[#versionado][Versionado]]
  - [[#changelog][ChangeLog]]
  - [[#roadmap][Roadmap]]
- [[#setup][Setup]]
  - [[#dependencias][Dependencias]]
  - [[#requirementstxt][requirements.txt]]
  - [[#instalar-las-dependencias][Instalar las dependencias]]
  - [[#generar-el-ejecutable][Generar el ejecutable]]
  - [[#gitignore][=.gitignore=]]
- [[#sources][Sources]]
  - [[#diseño-1][Diseño]]
  - [[#implementación][Implementación]]
- [[#france-inter][France Inter]]
  - [[#módulos][Módulos]]
  - [[#podcasts][Podcasts]]
  - [[#episodes][Episodes]]
  - [[#html][HTML]]
- [[#france-culture][France Culture]]
  - [[#diseño-2][Diseño]]
  - [[#módulos-1][Módulos]]
  - [[#podcasts-1][Podcasts]]
  - [[#episodes-1][Episodes]]
  - [[#html-1][HTML]]
- [[#interface-desde-línea-de-comandos][Interface desde línea de comandos]]
  - [[#diseño-3][Diseño]]
  - [[#wishlist][Wishlist]]
  - [[#mejoras][Mejoras]]
  - [[#implementación-1][Implementación]]
- [[#herramientas][Herramientas]]
  - [[#módulos-2][Módulos]]
  - [[#localfolderhttpserver][LocalFolderHTTPServer]]
  - [[#html-2][HTML]]
- [[#tests][Tests]]
  - [[#ejecutar-los-casos-de-prueba][Ejecutar los casos de prueba]]
  - [[#generar-el-reporte-de-cobertura][Generar el reporte de cobertura]]
  - [[#generar-el-reporte-de-complejidad-ciclomática][Generar el reporte de complejidad ciclomática]]
  - [[#integración-continua][Integración continua]]
- [[#licencia][Licencia]]
  - [[#gplv3][GPLv3]]
- [[#apéndices][Apéndices]]
  - [[#prueba-de-concepto-podcast-id][Prueba de concepto: Podcast ID]]
  - [[#implementación-de-referencia][Implementación de referencia]]
  - [[#historial-de-mejoras-y-correcciones][Historial de mejoras y correcciones]]

* Motivación

Me gusta escuchar podcasts de [[https://franceinter.fr][France Inter]] cuando salgo a caminar, y en su momento me armé un script que me genera los links para descargar los episodios usando cURL.

Quiero mejorar ese script y transformarlo en una aplicación que me permita buscar podcasts, generar una base de datos con podcasts de distintas fuentes (p.ej. YouTube) y armar una cola de descargas.

Además, me gustaría usar este proyecto para probar dos enfoques de programación que me están interesando últimamente:

- [[http://www.literateprogramming.com/][Literate Programming]] :: Es una manera de programar en la que el código de la aplicación es un subproducto del documento que explica cómo está hecha

- [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]] :: En este libro se define una receta para la construcción de programas en forma iterativa usando el paradigma de programación funcional

** Literate Programming

Para escribir este documento estoy usando [[https://www.gnu.org/software/emacs][Emacs]] y [[https://orgmode.org][Org mode]], que es un modo de Emacs que tiene funcionalidades para literate programming.

La idea de la programación literaria consiste en que el código fuente de la aplicación sale de la documentación. Esto quiere decir que para poder generar un ejecutable (un /build/) de una aplicación hecha "literariamente" es necesario procesar la documentación, extraer de ella los fragmentos de código fuente que la constituyen (en org-mode este proceso se denomina /tangle/) y luego generar el ejecutable correspondiente con ese código.

En nuestro caso, la documentación a procesar es /este documento/. Todo el código fuente de la aplicación está contenido en este documento, dentro de los fragmentos de código delimitados por las etiquetas =#+begin_src= y =#+end_src=. Los bloques de código que tienen el parámetro =:tangle path/to/file= en el tag de inicio son exportados al archivo que indica el path. De esta manera, podemos generar todos los archivos del código fuente de la aplicación /tangleando/ la documentación. El comando =org-babel-tangle= dispara la generación de los archivos en cualquier momento.

El hecho de generar el código fuente desde este documento permite que no sea necesario guardarlo en el repositorio. Cada vez que es necesario ejecutar la aplicación, o generar un build para una versión determinada, se exporta el código fuente desde este documento. Como podemos ver usando el comando =git ls-tree=, los únicos archivos que están comiteados en el repositorio son el =.gitignore=, =LICENSE= y =podcast-db.org= (este archivo). El archivo =README.org= es un link simbólico a =podcast-db.org= para que aparezca como índice en github.

#+begin_src sh
# listar los archivos comiteados en el repositorio
git ls-tree --full-tree -r --name-only HEAD
#+end_src

#+RESULTS:
:results:
.gitignore
README.org
podcast-db.org
:end:

*** ¿Y qué hago si no sé (o no quiero) usar emacs?

Dado que el código fuente está en este documento, para poder obtener los fuentes es necesario procesarlo (tanglearlo) con emacs. Así, podemos extraer el código de la aplicación desde el documento y ejecutarlo como haríamos con cualquier otro programa. 

Vamos a usar [[https://www.docker.com/][Docker]] para bajar una imagen de Emacs y usar esa imagen para tanglear nuestro documento. 

#+begin_src sh :eval never
# descarga la imagen de emacs
docker pull silex/emacs:26-alpine

# lanza emacs en modo batch, 
# carga el archivo ./podcast-db.org del directorio actual,
# y ejecuta org-babel tangle
docker run --rm -i -v $(pwd):/app -w /app silex/emacs:26-alpine emacs --batch -l org podcast-db.org -f org-babel-tangle
#+end_src

Vemos que los fuentes se generan en las carpetas =cli=, =franceinter=, =sources= y =utils=

#+begin_src sh :eval never
find ./franceinter
#+end_src

En teoría podríamos modificar el documento con otro editor de texto y regenerar los fuentes usando este método luego de editarlo, pero el procedimiento sería demasiado engorroso como para usarlo en la práctica.

** How to Design Programs

La otra fuente de inspiración para la metodología utilizada en este proyecto es el libro [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]]. Hay un video---[[https://media.ccc.de/v/35c3-9800-how_to_teach_programming_to_your_loved_ones][How to teach programming to your loved ones]]---en el que Mike Sperber explica la técnica utilizada para construir programas que se describe en el libro.

La idea es desarrollar una aplicación a partir de funciones elementales que se usan como piezas para ir armando componentes más complejos. El libro ofrece una receta para elaborar una función, que es la unidad mínima de código recomendada. Vamos a escribir cada una de las funciones de nuestra aplicación de acuerdo a los pasos de la siguiente receta:

- 1. Objetivo :: Identificar brevemente el propósito de la función. Nombrar las estructuras de datos que va a manipular
- 2. Firma :: Definir formalmente los parámetros de entrada y la salida de la función
- 3. Ejemplos :: Confeccionar un listado de ejemplos de parámetros de entrada que podría recibir la función y analizar cuál debería ser la salida para cada uno
- 4. Boceto :: Traducir la firma de la función en un boceto de la implementación
- 5. Definición :: Completar el boceto teniendo en cuenta el análisis y los ejemplos para lograr cumplir el propósito de la función
- 6. Casos de prueba :: Transformar los ejemplos en casos de prueba y asegurarse de que la función los pase a todos

En este caso, vamos a desarrollar nuestra aplicación en el lenguaje [[https://python.org][Python]] usando el paradigma de programación funcional. Esto quiere decir que nuestra aplicación va a estar mayormente compuesta de funciones (=def my_func():=) que vamos a ir combinando para realizar tareas complejas.

* Diseño
** Fuentes de podcasts

Quiero que mi base de datos pueda consultar las siguientes fuentes de podcasts:

- [X] FranceInter
- [ ] FranceCulture
- [ ] RFI
- [ ] Youtube
- [ ] PBS
- [ ] BBC
- [ ] Team Human
- [ ] Radiolab
- [ ] RSS feeds

** Funcionalidades
*** Consulta de podcasts y episodios

- [X] Listar las fuentes de podcasts disponibles
- [X] Listar los podcasts de una fuente
- [X] Consultar el detalle de un podcast
- [X] Listar los episodios de un podcast
- [X] Consultar el detalle de un episodio
- [X] Filtrar los episodios de un podcast según algún criterio (año, mes, palabra clave)

*** Descarga y almacenamiento local

- [ ] Guardar las fuentes, los podcasts y sus episodios en una base de datos local
- [ ] Generar una playlist o feed RSS a partir de un listado de episodios
- [ ] Crear una cola de descarga a partir de una playlist
- [ ] Procesar los archivos descargados (p.ej, cambiar el bitrate a 64k)

*** Interfaces de usuario

- [X] Linea de comandos (CLI)
- [ ] Interface web

* Versionado
** ChangeLog
*** 0.2.0 - 2019-03-31

- Interface desde línea de comandos (CLI)
- Generar un ejecutable en un solo archivo

*** 0.1.0 - 2019-03-01

- Versión inicial
- Consulta de fuentes disponibles
- Consulta de podcasts y episodios
- Fuente FranceInter

** Roadmap
*** 0.3.0

- Agregar fuente France Culture
- Agregar fuente RSS (Team Human)

*** 0.4.0

- Guardar las fuentes, los podcasts y sus episodios en una base de datos local

*** 0.5.0

- Agregar fuente YouTube
- Agregar fuente RadioLab

*** 0.6.0

- Generar una playlist o feed RSS a partir de un listado de episodios
- Crear una cola de descarga a partir de una playlist
- Procesar los archivos descargados (p.ej, cambiar el bitrate a 64k)

*** 0.9.0

- Interface Web

*** 1.0.0

- Makefile
- Integración continua

* Setup
** Dependencias

Vamos a usar las siguientes bibliotecas

- requests :: Para realizar las peticiones http
- requests-cache :: Para cachear las peticiones http
- beautifulsoup4 :: Para parsear html
- slugify :: Para generar el nombre del archivo a descargar
- pytest :: Para ejecutar los casos de prueba
- pytest-cov :: Para generar el reporte de cobertura de tests
- radon :: Para generar el reporte de complejidad de código
- validators :: Para validar URLs
- unidecode :: Para comparar strings sin los acentos (á == a)

**** TODO evaluar [[https://html.python-requests.org/][Requests-HTML]]

Parece que sería una alternativa interesante a BeautifulSoup4. 

Ventajas:

- Automatic following of redirects
- Pagination support
- Mocked user-agent (like a real web browser)

Desventajas:

- Solamente funciona con Python >= 3.6
- Tiene apenas un año de desarrollo (bs4 está /battle-tested/)
- Depende de muchos módulos (bloated?)

** requirements.txt

#+begin_src txt :tangle requirements.txt
beautifulsoup4
slugify
requests
requests-cache
pyinstaller
pytest
pytest-cov
radon
validators
unidecode
#+end_src

** Instalar las dependencias
**** 1. Inicializar la carpeta =./venv=

#+begin_src sh
rm -Rf ./venv
virtualenv-3.6 ./venv
#+end_src

**** 2. Instalar dependencias con =pip=

#+begin_src sh
pip-3.6 install -r requirements.txt
#+end_src

** Generar el ejecutable

- [X] Usar [[https://www.pyinstaller.org][PyInstaller]] para generar un ejecutable en un solo archivo
- [ ] Crear un Makefile con el proceso completo de build

*** PyInstaller

La versión 19.0.1 de pip [[https://github.com/pypa/pip/issues/6163][tiene un bug]] que causa que no se pueda instalar pyinstaller. Hay que actualizar a 19.0.3 o sino bajar a la versión 18.1. Sorteado ese problema, instalamos pyinstaller y ya podemos generar el ejecutable usando el comando =pyinstaller -F podcast-db=, que nos deja el archivo en la carpeta =./dist=

#+begin_src sh :eval never
source ./venv/bin/activate
pip install --upgrade pip
pip install pyinstaller
pyinstaller -F ./podcast-db
ls -alh ./dist/podcast-db
./dist/pocast-db --help
#+end_src

*** TODO Makefile

El Makefile tiene que poder buildear la aplicación completa desde el archivo =podcast-db.org=. Esto implica realizar las siguientes tareas

- [ ] Verificar que python esté instalado
- [ ] Verificar que emacs esté instalado (o sino usar docker)
- [ ] Generar los fuentes con =org-babel-tangle=
- [ ] Inicializar el virtualenv e instalar las dependencias
- [ ] Ejecutar los casos de prueba
- [ ] Generar el reporte de cobertura de tests
- [ ] Generar el archivo ejecutable
- [ ] Instalar el ejecutable en =/usr/local/bin=

** =.gitignore=

#+begin_src text :tangle .gitignore
.DS_Store
.pytest_cache
__pycache__
.coverage
cache.sqlite
cli
coverage
dist
downloads
franceculture
franceinter
podcast-db
podcast-db.spec
requirements.txt
sources
utils
venv
#+end_src

* Sources
** Diseño

- [X] Listar las fuentes de podcasts disponibles

Hay dos fuentes disponibles:

- France Inter
- Testing (podcasts France Inter desde archivos locales)

** Implementación
*** =__init.py__=
**** Funciones

#+begin_src python :tangle sources/__init__.py
from sources.list_sources import list_sources
from sources.source import Source
#+end_src

**** Tests

#+begin_src python :tangle sources/tests/__init__.py

#+end_src

*** list_sources
**** 1. Objetivo

Obtener el listado de fuentes de podcasts disponibles.

**** 2. Firma

La función no recibe argumentos y devuelve una lista de objetos =sources.Source=

#+begin_src python :tangle sources/source.py
class Source:
    def __init__(self, name, code, url):
        self.name = name
        self.code = code
        self.url = url

    def __repr__(self):
        return "Source(name='%s', code='%s')" % (self.name, self.code)
#+end_src

**** 3. Ejemplos

Dado que la función no recibe argumentos, no es necesario confeccionar ejemplos.

**** 4. Boceto

#+begin_src python
def list_sources():
    # devuelve un list
    sources = []
    # Agregar la lista de fuentes de podcasts
    return sources
#+end_src

**** 5. Definición

#+begin_src python :tangle sources/list_sources.py
from sources.source import Source


def list_sources():
    sources = [franceinter(), testing()]
    return sources


def franceinter():
    name = "franceinter"
    code = "fri"
    url = "https://www.franceinter.fr/emissions"
    return Source(name, code, url)


def franceculture():
    name = "franceculture"
    code = "frc"
    url = "https://www.franceculture.fr/emissions"
    return Source(name, code, url)


def testing():
    name = "testing"
    code = "tst"
    url = "http://localhost:3000/podcast-list-short.html"
    return Source(name, code, url)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve una lista de dos elementos (franceinter y testing).

#+begin_src python :tangle sources/tests/test_list_sources.py
from sources import list_sources
from sources import Source

def test_sources_ok():
    sources = list_sources()
    assert (len(sources) == 2)
    assert (sources[0].name == "franceinter")
    assert (sources[0].code == "fri")
    assert (sources[1].name == "testing")
    assert (sources[1].code == "tst")
    for source in sources:
        assert isinstance(source, Source)
        assert len(str(source)) > 0
#+end_src

****** Run tests

#+begin_src sh
pytest sources/tests/test_list_sources.py
#+end_src

* France Inter
** Módulos

#+begin_src python :tangle franceinter/__init__.py

#+end_src

** Podcasts
*** Diseño

France Inter publica en una sola página (enorme) el listado de todas sus emisiones. El html está bastante fácil de parsear, dado que los datos cada emisión se encuentran dentro de un =div= con la clase =rich-section-list-item-content=. Revisando el contenido de ese div, podemos obtener el título del podcast, su URL y el autor (que es opcional).

Queremos obtener el listado de los podcasts desde un URL y también desde un archivo local. Además queremos poder filtrar el listado buscando los podcasts que contengan una palabra clave en el autor o en el título.

Para poder consultar los podcasts y los episodios desde la línea de comandos necesitamos asignarle un identificador único a cada podcast. Lo más sencillo de implementar sería asignarle a cada podcast un código numérico o un hash a partir de su nombre o de su URL. El problema es que eso no es muy amigable para el usuario, que debería primero listar los podcasts que le interesan, tomar nota o recordar el código o hash y luego usar ese código para consultar los episodios. 

Sería mejor utilizar el título y el autor del podcast para generar un identificador que sea sencillo de recordar (o por lo menos, más fácil de recordar que un hash). La idea es extraer las palabras del título y del autor de cada podcast y generar un listado con las frecuencias de aparición de cada palabra. Luego, si entre las palabras de un podcast hay una que tenga frecuencia igual a uno (1), esa debería ser la palabra que debemos usar como identificador.

*** Wishlist

- [X] Obtener el listado de los podcasts de France Inter
- [X] Para cada podcast obtener el nombre, el url y el autor
- [X] Filtrar el listado de podcasts por una palabra clave
- [X] Asignarle un identificador a cada podcast

**** Obtener el listado de los podcasts de France Inter

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts import podcasts_from_url

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
first_five = itertools.islice(podcasts, 5)
for podcast in first_five:
    print(podcast)
    print("\n")
#+end_src

#+RESULTS:
:results:
Podcast(title='1001 mondes', url='https://www.franceinter.fr/emissions/mille-et-un-mondes')


Podcast(title='116 rue Albert-Londres', url='https://www.franceinter.fr/emissions/116-rue-albert-londres')


Podcast(title='18 bis, boulevard Hache-Coeur', url='https://www.franceinter.fr/emissions/18-bis-boulevard-hache-coeur')


Podcast(title='1914/1918 : la grande guerre, cent ans après', url='https://www.franceinter.fr/emissions/1914-1918-la-grande-guerre-cent-ans-apres')


Podcast(title='1918, un monde en révolutions', url='https://www.franceinter.fr/emissions/1918-un-monde-en-revolutions')


:end:

**** Para cada podcast obtener el nombre, el url y el autor

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts import podcasts_from_url

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
first_five = list(itertools.islice(podcasts, 5))
first = first_five[0]
print(" Podcast title: " + first.title)
print("   Podcast URL: " + first.url)
print("Podcast author: " + first.author)
#+end_src

#+RESULTS:
:results:
 Podcast title: 1001 mondes
   Podcast URL: https://www.franceinter.fr/emissions/mille-et-un-mondes
Podcast author: Laura El Makki
:end:

**** Filtrar el listado de podcasts por una palabra clave

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts import podcasts_from_url, podcasts_with_keyword

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
music_podcasts = podcasts_with_keyword(podcasts, "musique")
first_five = itertools.islice(music_podcasts, 5)
for podcast in first_five:
    print(podcast)
    print("\n")
#+end_src

#+RESULTS:
:results:
Podcast(title='Je veux de la musique !', url='https://www.franceinter.fr/emissions/je-veux-de-la-musique')


Podcast(title='Michel Berger, tout pour la musique', url='https://www.franceinter.fr/emissions/michel-berger-tout-pour-la-musique')


Podcast(title='La musique d'Inter', url='https://www.franceinter.fr/emissions/la-musique-d-inter')


Podcast(title='On parle musique', url='https://www.franceinter.fr/emissions/parle-musique')


Podcast(title='Quand la musique donne (été 2012)', url='https://www.franceinter.fr/emissions/quand-la-musique-donne-ete-2012')


:end:

**** Asignarle un identificador a cada podcast

Realizamos una [[#podcast-id-poc][prueba de concepto]] para determinar si se puede utilizar la frecuencia de las palabras que componen el título y el autor para asignarle un identificador único a cada podcast que no sea un código difícil de recordar. Encontramos que casi la mitad de los podcasts no tienen una palabra única que se pueda usar como identificador.

Pensando un poco encontramos una alternativa mejor, teniendo en cuenta que URL es una propiedad única de cada podcast, dado que dos podcasts no pueden tener el mismo URL. En el caso de France Inter, la parte única del URL de cada podcast es lo que le sigue a =https://www.franceinter.fr/emissions/=.

Vamos a usar la parte única del URL para identificar al podcast, agregándole una propiedad =identifier= a la clase =franceinter.podcasts.Podcast= que extrae el identificador desde el URL.

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts import podcasts_from_url

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
first_five = list(itertools.islice(podcasts, 5))
for podcast in first_five:
    print(" Podcast title: " + podcast.title)
    print("   Podcast URL: " + podcast.url)
    print("Podcast author: " + podcast.author)
    print("    Podcast ID: " + podcast.identifier)
    print("\n")
#+end_src

#+RESULTS:
:results:
 Podcast title: 1001 mondes
   Podcast URL: https://www.franceinter.fr/emissions/mille-et-un-mondes
Podcast author: Laura El Makki
    Podcast ID: mille-et-un-mondes


 Podcast title: 116 rue Albert-Londres
   Podcast URL: https://www.franceinter.fr/emissions/116-rue-albert-londres
Podcast author: Alexandre Héraud
    Podcast ID: 116-rue-albert-londres


 Podcast title: 18 bis, boulevard Hache-Coeur
   Podcast URL: https://www.franceinter.fr/emissions/18-bis-boulevard-hache-coeur
Podcast author: Frédéric Pommier
    Podcast ID: 18-bis-boulevard-hache-coeur


 Podcast title: 1914/1918 : la grande guerre, cent ans après
   Podcast URL: https://www.franceinter.fr/emissions/1914-1918-la-grande-guerre-cent-ans-apres
Podcast author: 
    Podcast ID: 1914-1918-la-grande-guerre-cent-ans-apres


 Podcast title: 1918, un monde en révolutions
   Podcast URL: https://www.franceinter.fr/emissions/1918-un-monde-en-revolutions
Podcast author: Ali Baddou
    Podcast ID: 1918-un-monde-en-revolutions


:end:

*** TODO Mejoras

- [ ] =autopep8= :: Aplicar el estándar PEP8 a todas las funciones

- [ ] =podcasts_from_filename= :: Se podrían matchear los errores de lectura del archivo con los códigos de la respuesta HTTP (404 si no se encuentra, 500 si hubo un error de I/O, etc)

*** =__init.py__=
**** Funciones

#+begin_src python :tangle franceinter/podcasts/__init__.py
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.podcast_from_tag import podcast_from_tag
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.podcasts_from_tags import podcasts_from_tags
from franceinter.podcasts.podcasts_from_response import podcasts_from_response
from franceinter.podcasts.podcasts_from_url import podcasts_from_url
from franceinter.podcasts.podcasts_from_filename import podcasts_from_filename
from franceinter.podcasts.podcasts_with_keyword import podcasts_with_keyword
#+end_src

**** Tests

#+begin_src python :tangle franceinter/podcasts/tests/__init__.py

#+end_src

*** podcasts_from_url
**** 1. Objetivo

Extraer el listado de podcasts desde un URL

**** 2. Firma

La función recibe un URL y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Un URL con el listado de podcasts
- Un URL de otra página, que no tiene podcasts
- Un URL de una página inexistente, que dispare un error 404 (not found)
- Un URL de un sitio inexistente, que dispare un error de DNS
- Un URL inválido

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_url.py

def url_ok():
    url = "http://localhost:3000/podcast-list-short.html"
    return url

def wrong_page_url():
    url = "http://localhost:3000/wrong-page.html"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def wrong_site_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

def invalid_url():
    url = "ht pt:\\hostlocal:3000/this-url-is-not-valid.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_url(url):
    # validar el url
    # realizar una petición al url
    # obtener la respuesta del url
    # obtener los podcasts llamando a podcasts_from_url
    # revisar si da un error de conexión
    return podcasts

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_url.py
import requests
from validators.url import url as is_valid_url
from franceinter.podcasts import podcasts_from_response

def podcasts_from_url(url):
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        podcasts = podcasts_from_response(response)
        return podcasts
    except requests.ConnectionError:
        assert False, connection_error(url)

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url
#+end_src

**** 6. Casos de prueba

Bueno, aquí tenemos un caso de prueba un poco más complejo que lo normal. Para poder testear nuestra función necesitamos realizar una petición HTTP. El problema es que no queremos depender de un sitio web externo, o de que haya conectividad a Internet cuando se ejecuten los casos de prueba. La solución es levantar un servidor HTTP desde una carpeta local y en nuestro caso vamos a usar los archivos HTML de ejemplo que tenemos en =franceinter/html=.

Ahora bien, necesitamos que el servidor HTTP esté levantado antes de correr nuestros casos de prueba y sería ideal poder bajarlo luego de ejecutar todos los tests que lo necesiten. Para ello vamos a usar un [[https://docs.pytest.org/en/latest/fixture.html][fixture]] (=@pytest.fixture=), que es una funcionalidad de pytest que permite que los casos de prueba reciban un argumento con algún recurso, en este caso, el servidor HTTP ya levantado y sirviendo los archivos desde la carpeta local.

El atributo ~scope="module"~ indica que el fixture =http_server= será invocado una sola vez por módulo, que es lo que queremos para que todos los tests de nuestra función compartan el mismo servidor HTTP y no tener que levantarlo y bajarlo para cada test. Cuando no se indica un =scope=, pytest invoca el fixture para cada caso de prueba.

Un fixture es una función común y corriente como cualquier otra, a la que pytest llama cuando comienza a procesar el módulo, se guarda el valor retornado, y se lo inyecta a los casos de prueba que declaren ese fixture como parámetro.

Nótese en el código del fixture =http_server= que se levanta el servidor HTTP en otro thread para no bloquear la ejecución de los tests y que se utiliza =yield= para poder bajar el servidor luego de su uso.

- Cuando recibe un URL con el listado de podcasts, devuelve un =GeneratorType= de objetos =Podcast=
- Cuando recibe un URL de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de una página inexistente, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de un sitio inexistente (error de DNS), lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_url.py
import os
import pytest
import threading
import types
from franceinter.podcasts import Podcast, podcasts_from_url
from franceinter.podcasts.tests.examples_podcasts_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = url_ok()
    gen = podcasts_from_url(url)
    assert isinstance(gen, types.GeneratorType)
    podcasts = list(gen)
    assert (len(podcasts) > 0)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_wrong_page_url(http_server):
    url = wrong_page_url()
    podcasts = list(podcasts_from_url(url))
    assert (len(podcasts) == 0)

def test_not_found_url(http_server):
    url = not_found_url()
    podcasts = list(podcasts_from_url(url))
    assert (len(podcasts) == 0)

@pytest.mark.skipif(os.environ.get('ENV') == 'DEV', reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = wrong_site_url()
    try:
        podcasts = list(podcasts_from_url(url))
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        podcasts = podcasts_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_url.py
#+end_src

*** podcasts_with_keyword
**** 1. Objetivo

Filtrar un listado de podcasts y obtener solamente los que contienen una palabra clave en el título o en el autor

Se debe buscar la palabra clave sin tener encuenta las mayúsculas o minúsculas (case insensitive match)

**** 2. Firma

La función recibe un listado de objetos =franceinter.podcasts.Podcast= y un =str=, y devuelve un =filter= de objetos =franceinter.podcasts.Podcast=

Para el listado de podcasts vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 podcasts en el que hay 2 que tienen la palabra "radio" en el título 
- Un listado de 5 podcasts en el que hay 3 que tienen la palabra "radio" en el autor
- Un listado de 5 podcasts en el que ninguno tiene la palabra "radio" en el título y/o autor
- Un listado de podcasts que no es iterable
- Un listado de podcasts que no tiene objetos =franceinter.podcasts.Podcast=
- Una query que no es un =str=

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_with_keyword.py
import random
from franceinter.podcasts import Podcast

def podcasts_with_word_in_title(word):
    podcasts = []
    for i in range(0, 3):
        podcasts.append(new_podcast())
    p = new_podcast()
    p.title+= " " + word
    podcasts.append(p)
    podcasts.append(p)
    random.shuffle(podcasts)
    return podcasts

def podcasts_with_word_in_author(word):
    podcasts = []
    for i in range(0, 2):
        podcasts.append(new_podcast())
    p = new_podcast()
    p.author+= " " + word
    podcasts.append(p)
    podcasts.append(p)
    podcasts.append(p)
    random.shuffle(podcasts)
    return podcasts

def some_podcasts(how_many):
    for i in range(0, how_many):
        yield new_podcast()

def podcasts_not_iterable():
    return 42
        
def invalid_podcasts():
    return range(0,10)

def invalid_keyword():
    return 42

def new_podcast():
    title = "Este es un podcast de ejemplo"
    url = "http://podcastplace.com/shows"
    author = "Juan Perez"
    return Podcast(title, url, author)

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_with_keyword(podcasts, query):
    # validar que los podcasts sean iterables
    # validar que la query sea un str
    # validar que cada podcast sea un Podcast
    # filtrar los podcasts con una función que devuelva true 
    # si el título o el autor contienen la query

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_with_keyword.py
import re
from unidecode import unidecode
from franceinter.podcasts import Podcast


def podcasts_with_keyword(podcasts, keyword):
    # validar que los podcasts sean iterables
    try:
        it = iter(podcasts)
    except TypeError:
        assert False, invalid_podcasts(podcasts)
    # validar que la keyword sea un str
    assert isinstance(keyword, str), invalid_keyword(keyword)
    # validar que cada podcast sea un Podcast
    valid_podcasts = filter(is_podcast, podcasts)
    # filtrar los podcasts que contienen la query
    contains_keyword = keyword_matcher(keyword)
    return filter(contains_keyword, valid_podcasts)


def is_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    return True


def keyword_matcher(keyword):
    def matcher(podcast):
        kw = unidecode(keyword)
        title = unidecode(podcast.title)
        author = unidecode(podcast.author)
        identifier = podcast.identifier
        return (re.search(kw, title, re.IGNORECASE)
                or re.search(kw, author, re.IGNORECASE)
                or re.search(kw, identifier, re.IGNORECASE))
    return matcher


def invalid_podcasts(podcasts):
    return "podcasts parameter must be iterable, received %s instead" % type(podcasts)


def invalid_keyword(keyword):
    return "keyword parameter must be a string, received %s instead" % type(keyword)


def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % type(podcast)
#+end_src

**** 6. Casos de prueba

- Cuando recibe un listado de 5 podcasts en el que hay 2 que tienen la palabra "radio" en el título, devuelve un =filter= con los 2 podcasts que cumplen la condición
- Cuando recibe un listado de 5 podcasts en el que hay 3 que tienen la palabra "radio" en el autor, devuelve un =filter= con los 3 podcasts que cumplen la condición
- Cuando recibe un listado de 5 podcasts en el que ninguno tiene la palabra "radio" en el título y/o autor, devuelve un =filter= vacío
- Cuando recibe un listado de podcasts que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de podcasts que no tiene objetos =franceinter.podcasts.Podcast=, lanza un =AssertionError=
- Cuando recibe una query que no es un =str=, lanza un =AssertionError=
- Cuando recibe listado de 5 podcasts en el que hay 2 que tienen la palabra "café" en el título, y la palabra buscada es "cafe", devuelve un =filter= con los dos podcasts que tienen la palabra "café"
- Cuando recibe listado de 5 podcasts en el que hay 1 cuyo URL es "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin", y se busca la palabra "sur-les-epaules-de-darwin", devuelve un =filter= con el podcast que tiene ese identificador

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_with_keyword.py
import types
from franceinter.podcasts import podcasts_with_keyword
from franceinter.podcasts.tests.examples_podcasts_with_keyword import *

def test_podcasts_with_word_in_title():
    podcasts = podcasts_with_word_in_title("radio")
    result = podcasts_with_keyword(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_podcasts_with_word_in_author():
    podcasts = podcasts_with_word_in_author("radio")
    result = podcasts_with_keyword(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 3)

def test_podcasts_without_word():
    podcasts = some_podcasts(8)
    result = podcasts_with_keyword(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_podcasts_not_iterable():
    podcasts = podcasts_not_iterable()
    try:
        result = podcasts_with_keyword(podcasts, "radio")
    except AssertionError:
        assert True

def test_invalid_podcasts():
    podcasts = invalid_podcasts()
    try:
        result = podcasts_with_keyword(podcasts, "radio")
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_query():
    podcasts = some_podcasts(10)
    keyword = invalid_keyword()
    try:
        result = podcasts_with_keyword(podcasts, keyword)
    except AssertionError:
        assert True

def test_podcasts_with_accented_word():
    podcasts = podcasts_with_word_in_title("café")
    result = podcasts_with_keyword(podcasts, "cafe")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_podcasts_with_identifier():
    podcasts = list(some_podcasts(5))
    title = "Sur les épaules de Darwin"
    author = "Jean-Claude Ameisen"
    url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
    podcasts[2].title = title
    podcasts[2].url = url
    podcasts[2].author = author
    identifier = "sur-les-epaules-de-darwin"
    result = list(podcasts_with_keyword(podcasts, identifier))
    assert (len(result) == 1)
    assert (result[0].title == title)
    assert (result[0].url == url)
    assert (result[0].author == author)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_with_keyword.py
#+end_src

*** podcasts_from_response
**** 1. Objetivo

Extraer el listado de podcasts de la respuesta de una petición HTTP

**** 2. Firma

La función recibe una =requests.model.Response= y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Una respuesta válida, con el HTML de la página del listado de podcasts
- Una respuesta inválida, que no es de la clase =requests.model.Response=
- Una respuesta válida, pero que tiene el HTML de otra página

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_response.py
from requests.models import Response

def response_ok():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/podcast-list-short.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

def invalid_response():
    return "i am not a Response"

def wrong_page_response():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/wrong-page.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

#+end_src

#+RESULTS:
:results:
:end:

**** 4. Boceto

#+begin_src python
import requests

def podcasts_from_response(resp):
    # validar la respuesta
    # obtener el HTML de resp.text
    # extraer los tags usando tags_from_html
    # obtener los podcasts usando podcasts_from_html

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_response.py
import requests
from franceinter.podcasts import tags_from_html, podcasts_from_tags

def podcasts_from_response(resp):
    assert isinstance(resp, requests.models.Response), invalid_type(resp)
    html = resp.text
    tags = tags_from_html(html)
    podcasts = podcasts_from_tags(tags)
    return podcasts
    
def invalid_type(resp):
    return "resp parameter must be a requests.models.Response, received %s instead" % type(resp)

#+end_src

**** 6. Casos de prueba

- Cuando recibe una respuesta válida, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Cuando recibe una respuesta que no es de la clase =requests.model.Response=, lanza un =AssertionError=
- Cuando recibe una respuesta válida que tiene el HTML de otra página, devuelve un =GeneratorType= vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_response.py
import types
from franceinter.podcasts import podcasts_from_response, Podcast
from franceinter.podcasts.tests.examples_podcasts_from_response import *

def test_response_ok():
    resp = response_ok()
    podcasts = podcasts_from_response(resp)
    assert isinstance(podcasts, types.GeneratorType)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_invalid_response():
    resp = invalid_response()
    try:
        podcasts = podcasts_from_response(resp)
    except AssertionError:
        assert True
    
def test_wrong_page_response():
    resp = wrong_page_response()
    podcasts = podcasts_from_response(resp)
    assert isinstance(podcasts, types.GeneratorType)
    assert (len(list(podcasts)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_response.py
#+end_src

*** podcasts_from_tags
**** 1. Objetivo

Generar un listado de podcasts a partir de un listado de fragmentos de HTML tomados de la página

**** 2. Firma

La función recibe un listado de objetos =bs4.element.Tag= y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

Vamos a aceptar tanto un =list= como un =GeneratorType=

**** 3. Ejemplos

- Un objeto que no es iterable
- Una lista vacía
- Una lista con tags válidos
- Una lista con objetos que no son del tipo =bs4.element.Tag=
- Una lista con tags válidos y un tag inválido (sin el título o el URL)

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_tags.py
from franceinter.podcasts import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *
from franceinter.podcasts.tests.examples_podcast_from_tag import (
    tag_ok, 
    tag_without_url
)

def invalid_list():
    return 123

def empty_list():
    return []

def list_without_tags():
    return [1, 2, 3, 4, 5]

def list_with_valid_tags(how_many):
    html = ""
    for item in range(1, how_many):
        html+= str(tag_ok())
    tags = tags_from_html(html)
    return tags

def list_with_invalid_tag(how_many):
    tags = list(list_with_valid_tags(how_many - 1))
    tags+= tag_without_url()
    return tags

#+end_src

**** 4. Boceto

#+begin_src python
from franceinter.podcasts import tags_from_html

def podcasts_from_tags(tags):
    # validar que tags sea un GeneratorType
    # para cada tag de la lista
    # usar podcast_from_tag() para obtener un podcast
    # yield posdcast

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_tags.py
from franceinter.podcasts import podcast_from_tag

def podcasts_from_tags(tags):
    try:
        it = iter(tags)
    except TypeError:
        assert False, invalid_tags(tags)
    for tag in tags:
        yield podcast_from_tag(tag)

def invalid_tags(tags):
    return "tags parameter must be iterable, received %s instead" % type(tags)
#+end_src

**** 6. Casos de prueba

- Si recibe un objeto que no es iterable, lanza un =AssertionError=
- Si recibe una lista vacía, devuelve un =GeneratorType= vacío
- Si recibe una lista de tags válidos, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Si recibe una lista con objetos que no son del tipo =bs4.element.Tag=, lanza un =AssertionError=
- Si recibe una lista con algún tag inválido (que no tenga el título o el URL), lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_tags.py
import types
from franceinter.podcasts import podcasts_from_tags, Podcast
from franceinter.podcasts.tests.examples_podcasts_from_tags import *

def test_invalid_list():
    tags = invalid_list()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_empty_list():
    tags = empty_list()
    podcasts = podcasts_from_tags(tags)
    assert isinstance(podcasts, types.GeneratorType)
    assert (len(list(podcasts))==0)

def test_list_with_valid_tags():
    tags = list_with_valid_tags(6)
    podcasts = podcasts_from_tags(tags)
    assert isinstance(podcasts, types.GeneratorType)
    for p in podcasts:
        assert (isinstance(p, Podcast))

def test_list_without_tags():
    tags = list_without_tags()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_list_with_invalid_tag():
    tags = list_with_invalid_tag(6)
    podcasts = podcasts_from_tags(tags)
    try:
        for p in podcasts:
            assert (isinstance(p, Podcast))
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_tags.py
#+end_src

*** podcasts_from_filename
**** 1. Objetivo

Extraer un listado de podcasts desde un archivo

**** 2. Firma

La función recibe un =str= con el nombre del archivo y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Un archivo HTML que tiene un listado de podcasts
- Un archivo HTML de otra página, que no tiene podcasts
- Un archivo que no existe
- Un nombre de archivo que no es un =str=

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_filename.py

def ok_filename():
    return "./franceinter/html/podcast-list-short.html"

def wrong_filename():
    return "./franceinter/html/wrong-page.html"

def not_found_filename():
    return "./franceinter/html/this-file-does-not-exist.html"

def invalid_filename():
    return [1, 2, 3]

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_filename(filename):
    # validar que filename sea un str
    # validar que el archivo exista
    podcasts = []
    # crear un requests.models.Response con el contenido del archivo
    # obtener los podcasts llamando a podcasts_from_response
    return podcasts
     
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_filename.py
from requests.models import Response
from franceinter.podcasts import podcasts_from_response

def podcasts_from_filename(filename):
    assert isinstance(filename, str), invalid_filename(filename)
    resp = Response()
    podcasts = []
    try:
        with open(filename, "rb") as f:
            resp._content = f.read()
            podcasts = podcasts_from_response(resp)
    except (OSError, IOError) as error:
        assert False, not_found(filename, error)
    return podcasts

def invalid_filename(filename):
    return "filename parameter must be a str, %s received instead" % filename

def not_found(filename, error):
    return "filename %s cannot be read, thrown error :\n%s" % (filename, error)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un archivo HTML que tiene un listado de podcasts, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Cuando recibe un archivo HTML de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un archivo que no existe, lanza un =AssertionError=
- Cuando recibe un nombre de archivo que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_filename.py
import types
from franceinter.podcasts import podcasts_from_filename, Podcast
from franceinter.podcasts.tests.examples_podcasts_from_filename import *

def test_ok_filename():
    filename = ok_filename()
    podcasts = podcasts_from_filename(filename)
    assert isinstance(podcasts, types.GeneratorType)
    podcasts = list(podcasts)
    assert (len(podcasts) > 0)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_wrong_filename():
    filename = wrong_filename()
    podcasts = podcasts_from_filename(filename)
    assert isinstance(podcasts, types.GeneratorType)
    podcasts = list(podcasts)
    assert (len(podcasts) == 0)

def test_not_found_filename():
    filename = not_found_filename()
    try:
        podcasts = podcasts_from_filename(filename)
    except AssertionError:
        assert True

def test_invalid_filename():
    filename = invalid_filename()
    try:
        podcasts = podcasts_from_filename(filename)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_podcasts_from_filename.py
#+end_src

*** tags_from_html
**** 1. Objetivo

Obtener un array de tags con el fragmento de html que tiene el detalle del podcast (título, URL y autor) a partir del html de la página con el listado de podcasts

Hay que extraer todos los =<div>= que tengan la clase =rich-section-list-item-content=

**** 2. Firma

La función recibe un =str= con el html de la página y devuelve un =GeneratorType= de elementos =bs4.element.Tag=

**** 3. Ejemplos

- Un html que tiene varios =<div>= con la clase buscada
- Un html que no es un =str=
- Un html que no tiene ningún =<div>=
- Un html que tiene varios =<div>= pero que ninguno tenga la clase =rich-section-list-item-content=
- Un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen

#+begin_src python :tangle franceinter/podcasts/tests/examples_tags_from_html.py
from bs4 import BeautifulSoup
import random

def html_with_divs(how_many):
    class_name = "rich-section-list-item-content"
    divs = map(lambda x: div(class_name), range(how_many))
    return html(divs)

def html_is_not_string():
    return 42

def html_without_divs():
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>'''
    return html

def html_divs_without_class(how_many):
    divs = map(lambda x: div(), range(how_many))
    return html(divs)

def html_some_divs_with_class(how_many_with, how_many_without):
    class_name = "rich-section-list-item-content"
    divs_with = list(map(lambda x: div(class_name), range(how_many_with)))
    divs_without = list(map(lambda x: div(), range(how_many_without)))
    divs = divs_with + divs_without
    random.shuffle(divs)
    return html(divs)

def div(class_name=""):
    attr = ""
    if class_name:
        attr = "class=%s" % class_name
    html = '''<div %s>
    here goes the div body
</div>''' % attr
    soup = BeautifulSoup(html, "html.parser")
    return soup.div

def html(divs):
    div_str = "".join(map(lambda div: str(div), divs))
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
%s
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    ''' % div_str
    return html
    
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup

def tags_from_html(html):
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # filtrar los tag <div> que tienen la clase "rich-section-list-item-content"
    return tags

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/tags_from_html.py
from bs4 import BeautifulSoup

def tags_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    cls = "rich-section-list-item-content"
    tags = soup.find_all("div", class_=cls)
    for tag in tags:
        yield tag

def invalid_html(html):
    return "html parameter must be a string, received %s instead" % type(html)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un html que tiene varios =<div>= con la clase buscada, devuelve un =GeneratorType= de tantos elementos como =<div>= hay en el html
- Cuando recibe un html que no es un string, lanza un =AssertionError=
- Cuando recibe un html que no tiene ningún =<div>=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene varios =<div>= pero ninguno tiene la clase =rich-section-list-item-content=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen, devuelve un =GeneratorType= con solamente los =<div>= que tienen la clase

#+begin_src python :tangle franceinter/podcasts/tests/test_tags_from_html.py
import types
from franceinter.podcasts import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *

def test_html_with_divs():
    html = html_with_divs(5)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 5)

def test_html_is_not_string():
    try:
        html = html_is_not_string()
        tags = list(tags_from_html(html))
    except AssertionError:
        assert True

def test_html_without_divs():
    html = html_without_divs()
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_divs_without_class():
    html = html_divs_without_class(4)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_some_divs_with_class():
    html = html_some_divs_with_class(2,3)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 2)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_tags_from_html.py
#+end_src

*** podcast_from_tag
**** 1. Objetivo

Obtener un podcast de un fragmento de html.

Un podcast tiene tres propiedades principales, a saber:

- título :: es un =str= y es obligatorio
- url :: es un =str=, es obligatorio y debe ser un URL válido
- autor :: es un =str=, pero puede estar vacío

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un objeto =franceinter.podcasts.podcast=

Necesitamos entonces definir la clase =podcast=

#+begin_src python :tangle franceinter/podcasts/podcast.py

class Podcast:
    def __init__(self, title, url, author=""):
        self.title = title
        self.url = url
        self.author = author

    @property
    def identifier(self):
        return self.url.lower().replace(
            "https://www.franceinter.fr/emissions/", ""
        )

    def __repr__(self):
        return "Podcast(title='%s', url='%s')" % (self.title, self.url)

#+end_src

**** 3. Ejemplos

- Un tag que tiene todos los elementos para generar un podcast válido (título, URL y autor)
- Un tag que no es un =bs4.element.Tag=
- Un tag que no tiene el elemento del título
- Un tag que no tiene el elemento del URL
- Un tag que tiene el elemento del URL, pero el URL no es válido
- Un tag que no tiene el elemento del autor

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcast_from_tag.py
from bs4 import BeautifulSoup

def tag_ok():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def invalid_tag():
    return "I am not a tag"

def tag_without_title():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_with_invalid_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="this://isnot[?=>avalid[[/\\url"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_author():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def podcast_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag

    # extraer el título con title_from_tag
    # validar que el título no sea un string vacío

    # extraer el url con url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer el autor usando author_from_tag

    # crear una instancia de franceinter.podcasts.podcast
    # con el título, el url y el autor
    return podcast

#+end_src

**** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceinter/podcasts/podcast_from_tag.py
from franceinter.podcasts import (
    title_from_tag, 
    url_from_tag, 
    author_from_tag, 
    Podcast
)
from validators.url import url as is_valid_url
import bs4

def podcast_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = title_from_tag(tag)
    assert (title != ""), no_title(tag)

    url = url_from_tag(tag)
    assert (url != ""), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)

    author = author_from_tag(tag)

    return Podcast(title, url, author)

def no_url(tag):
    return "received tag does not have a podcast URL\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid podcast URL\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have a podcast title\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve un podcast
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no tiene título, lanza un =AssertionError=
- Cuando recibe un tag que no tiene url, lanza un =AssertionError=
- Cuando recibe un tag que tiene un url pero es inválido, lanza un =AssertionError=
- Cuando recibe un tag que no tiene autor, devuelve un podcast con un =str= vacío en la propiedad author

#+begin_src python :tangle franceinter/podcasts/tests/test_podcast_from_tag.py
from franceinter.podcasts import podcast_from_tag
from franceinter.podcasts.tests.examples_podcast_from_tag import *

def test_podcast_ok():
    tag = tag_ok()
    podcast = podcast_from_tag(tag)
    assert (len(podcast.title) > 0)
    assert (len(podcast.url) > 0)
    assert (len(podcast.author) > 0)
    assert (len(podcast.identifier) > 0)
    assert (len(str(podcast)) > 0)

def test_podcast_without_title():
    tag = tag_without_title()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_url():
    tag = tag_without_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    tag = tag_with_invalid_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_author():
    tag = tag_without_author()
    podcast = podcast_from_tag(tag)
    assert len(podcast.title) > 0
    assert len(podcast.url) > 0
    assert len(podcast.identifier) > 0
    assert len(podcast.author) == 0

def test_invalid_tag():
    tag = invalid_tag()
    try:
        podcast_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcast_from_tag.py
#+end_src

*** title_from_tag
**** 1. Objetivo

Obtener el título del podcast de un fragmento de html.

El título se encuentra en el atributo =title= de un =<a>= que tiene la clase =rich-section-list-item-content-title=

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, Un tag que contiene un =<a>= con la clase correcta y el atributo =title=
- Un tag que no tiene el =<a>=
- Un tag que tiene el =<a>= pero éste no tiene la clase =rich-section...=
- Un tag que tiene el =<a>= pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_title_from_tag.py
from bs4 import BeautifulSoup

def tag_with_title():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    title="Sur les epaules de Darwin">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a title="Sur les epaules de Darwin">
</a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    title="Sur les epaules de Darwin">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def title_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    title = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable title
    return title
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/title_from_tag.py
import bs4

def title_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "title" in link.attrs:
        title = link.attrs["title"]
    return title

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el título
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene la clase correcta, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_title_from_tag.py
from franceinter.podcasts import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

def test_author_ok():
    tag = tag_with_title()
    assert ("Sur les epaules de Darwin" == title_from_tag(tag))

def test_invalid_tag():
    try:
        title_from_tag(5)
    except AssertionError:
        assert True

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == title_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == title_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == title_from_tag(tag))

#+end_src

#+begin_src python
from bs4 import BeautifulSoup
from franceinter.podcasts import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

tag = tag_with_title()
title = title_from_tag(tag)
print(title)
#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_title_from_tag.py
#+end_src

*** url_from_tag
**** 1. Objetivo

Obtener el URL del podcast de un fragmento de html.

El URL se encuentra en el atributo =href= de un tag =<a>= que tiene la clase =rich-section-list-item-content-title=. 

El URL es relativo, por lo que hay que agregarle baseUrl de France Inter (https://www.franceinter.fr).

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag que contiene un =<a>= con la clase =rich-section-list-item-content-title= y el atributo =href=
- Un tag que no tiene el =<a>=
- Un tag que tiene el =<a>= pero el link no tiene clase
- Un tag que tiene el =<a>= pero el link no tiene el atributo =href=

#+begin_src python :tangle franceinter/podcasts/tests/examples_url_from_tag.py
from bs4 import BeautifulSoup

def tag_with_url():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</p>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a href="emissions/la-tete-au-carre"></a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_href():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def url_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    url = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el <a> hay que revisar si tiene el atributo href
    # si tiene el atributo href 
    #     - se le agrega "https://www.franceinter.fr/" adelante
    #     - se guarda en la variable url
    return url
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/url_from_tag.py
import bs4

def url_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    url = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "href" in link.attrs:
        url = "https://www.franceinter.fr/" + link.attrs["href"]
    return url

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el url
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene la clase buscada, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene el atributo =href=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_url_from_tag.py
from franceinter.podcasts import url_from_tag
from franceinter.podcasts.tests.examples_url_from_tag import *

def test_url_ok():
    tag = tag_with_url()
    url = "https://www.franceinter.fr/emissions/la-tete-au-carre"
    assert (url == url_from_tag(tag))

def test_invalid_tag():
    try:
        url_from_tag(5)
    except AssertionError:
        assert True

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == url_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == url_from_tag(tag))

def test_title_not_found():
    tag = tag_without_href()
    assert ("" == url_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_url_from_tag.py
#+end_src

*** author_from_tag
**** 1. Objetivo

Obtener el autor del podcast de un fragmento de html. 

El autor se encuentra en el atributo =title= de un =<a>= que está dentro de un =<span>= que tiene la clase =rich-section-list-item-content-infos-author=

**** 2. Firma

La funcion recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, el tag tiene un =<span>= con la clase =rich-section-list-item-content-infos-author= que contiene un =<a>= con el atributo =title=
- El tag no tiene un =<span>=
- El tag tiene un =<span>=, pero éste no tiene un =<a>=
- El tag tiene un =<span>= que contiene un =<a>=, pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_author_from_tag.py
from bs4 import BeautifulSoup

def tag_with_author():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a title="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_span():
    html = '''<div class="boldest">
Extremely bold
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<p title="William Shakespeare"></p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a subtitle="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

#+RESULTS:
:results:
True
:end:

**** 4. Boceto

#+begin_src python

def author_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    author = ""
    # hay que buscar un span con la clase "rich-section..."
    # si existe el span hay que buscar un a
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable author
    return author
    
#+end_src

#+RESULTS:
:results:
None
:end:

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/author_from_tag.py
import bs4

def author_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    cls = "rich-section-list-item-content-infos-author"
    span = tag.find("span", class_=cls)
    author = ""
    if span:
        link = span.find("a")
        if link and "title" in link.attrs:
            author = link.attrs["title"]
    return author

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el autor
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no tiene un tag =<span>= con la clase buscada, devuelve un string vacío
- Cuando recibe un tag que tiene el =<span>= pero éste no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<span>= y el =<a>= pero éste último no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_author_from_tag.py
from franceinter.podcasts import author_from_tag
from franceinter.podcasts.tests.examples_author_from_tag import *

def test_author_ok():
    tag = tag_with_author()
    assert ("William Shakespeare" == author_from_tag(tag))

def test_invalid_tag():
    try:
        author_from_tag(5)
    except AssertionError:
        assert True

def test_span_not_found():
    tag = tag_without_span()
    assert ("" == author_from_tag(tag))

def test_a_not_found():
    tag = tag_without_link()
    assert ("" == author_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == author_from_tag(tag))

#+end_src

#+RESULTS:
:results:
None
:end:

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_author_from_tag.py
#+end_src

** Episodes
*** Diseño

En el URL de un podcast vemos el listado de los últimos episodios disponibles. Al final del listado hay un selector de páginas para acceder al historial de episodios. Para poder obtener el historial completo necesitamos la cantidad de páginas, que está en un tag =<li>= que tiene la clase =last=. 

Una vez que tengamos la cantidad de páginas podemos obtener el listado de episodios, parseando cada una de las páginas del historial. Como hicimos en el módulo de podcasts, necesitamos poder obtener los episodios tanto desde un URL como desde un archivo local.

Cada episodio tiene un título, una fecha de emisión y un URL para descargar el audio. Podemos ver en el HTML de la página (ver el archivo =./franceinter/html/episode-list.html=) que se puede obtener también la duración en segundos del episodio, dato que puede ser útil más adelante para detectar problemas en la descarga de los archivos.

Por lo que se puede ver en el HTML, muchos de los datos que necesitamos se encuentran en un tag =<button>= que tiene la clase =replay-button=

*** Wishlist

- [X] Obtener el listado de los episodios de un podcast
- [X] Para cada episodio obtener el título, la fecha, el URL del audio y su duración
- [X] Filtrar el listado por una palabra clave
- [X] Filtrar el listado por intervalo de fechas
- [X] Filtrar el listado por año
- [X] Filtrar el listado por mes
- [X] Filtrar el listado por día

***** Obtener el listado de los episodios de un podcast

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts import Podcast
from franceinter.episodes import episodes_from_podcast

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first_five = itertools.islice(episodes, 5)
for episode in first_five:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Les chants des abeilles', date='2019-02-16')


Episode(title='L'Apiculteur aveugle', date='2019-02-09')


Episode(title='Les chants du monde', date='2019-02-02')


Episode(title='Une année dans le monde', date='2019-01-26')


Episode(title='Aux origines du chocolat (8)', date='2019-01-19')


:end:

***** Para cada episodio obtener el título, la fecha, el URL del audio y su duración

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts import Podcast
from franceinter.episodes import episodes_from_podcast

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first = list(itertools.islice(episodes, 5))[0]
print ("   Title: " + first.title)
print ("    Date: " + str(first.date))
print ("     URL: " + first.url)
print ("Duration: " + str(first.duration))

#+end_src

#+RESULTS:
:results:
   Title: Les chants des abeilles
    Date: 2019-02-16
     URL: https://media.radiofrance-podcast.net/podcast09/11549-16.02.2019-ITEMA_21984001-0.mp3
Duration: 3253
:end:

***** Filtrar el listado por una palabra clave

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts import Podcast
from franceinter.episodes import (
    episodes_from_podcast, 
    episodes_with_keyword
)

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
choco_episodes = episodes_with_keyword(episodes, "chocolat")
first_five = itertools.islice(choco_episodes, 5)
for episode in first_five:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Aux origines du chocolat (8)', date='2019-01-19')


Episode(title='Aux Origines du Chocolat (7)', date='2019-01-12')


Episode(title='Aux Origines du Chocolat (6)', date='2019-01-05')


Episode(title='Aux origines du chocolat (5)', date='2018-12-15')


Episode(title='Aux origines du chocolat (4)', date='2018-12-08')


:end:

***** Filtrar el listado por año, mes, día o intervalo de fechas

#+begin_src python
import itertools
import requests
import requests_cache
from datetime import date as Date
from franceinter.podcasts import Podcast
from franceinter.episodes import (
    episodes_from_podcast, 
    episodes_between_dates
)

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first_100 = itertools.islice(episodes, 100)
june_episodes = episodes_between_dates(first_100, Date(2018, 6, 1), Date(2018, 6, 30))
for episode in june_episodes:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Dans les ombres rêveuses', date='2018-06-30')


Episode(title='Le plomb et l'argent (4)', date='2018-06-23')


Episode(title='Le plomb et l'argent (3)', date='2018-06-16')


Episode(title='Le plomb et l'argent (2)', date='2018-06-09')


Episode(title='Le plomb et l'argent', date='2018-06-02')


:end:

*** TODO Mejoras

- [ ] =autopep8= :: Aplicar el estándar PEP8 a todas las funciones

- [X] Módulo =HTML= :: Crear un nuevo módulo =HTML= dentro de =Utils= que tenga la función =html_from_url=

A primera vista, la función =html_from_url= parecería ser una función trivial que quizás no debiera existir. Sin embargo, al encapsular las peticiones HTTP en esta función ganamos la posibilidad de cambiar la dependencia de la biblioteca =requests= en caso que sea necesario. Por ahora la colocamos en el módulo episodes, pero la idea es extraerla en un nuevo módulo =HTML= dentro de =Utils= para poder utilizarla en otras partes de la aplicación. Así podríamos utilizarla, por ejemplo, en la función =podcasts_from_url=.

- [ ] =tags_from_html= :: Extraer la función =tags_from_html= al nuevo módulo =utils.html=

Notamos que la función =tags_from_html= está repetida en los módulos Podcasts y Episodes. Esto nos sugiere que habría que hacer un cambio en el diseño para extraer esa lógica común a otro módulo, para eliminar la duplicación de ese código.

*** =__init.py__=
**** Funciones

#+begin_src python :tangle franceinter/episodes/__init__.py
from franceinter.episodes.episode import Episode
from franceinter.episodes.title_from_tag import title_from_tag
from franceinter.episodes.url_from_tag import url_from_tag
from franceinter.episodes.date_from_tag import date_from_tag
from franceinter.episodes.duration_from_tag import duration_from_tag
from franceinter.episodes.episode_from_tag import episode_from_tag
from franceinter.episodes.lastpage_from_html import lastpage_from_html
from franceinter.episodes.pages_from_podcast import pages_from_podcast
from franceinter.episodes.tags_from_html import tags_from_html
from franceinter.episodes.episodes_from_tags import episodes_from_tags
from franceinter.episodes.episodes_from_response import episodes_from_response
from franceinter.episodes.episodes_from_url import episodes_from_url
from franceinter.episodes.episodes_from_filename import episodes_from_filename
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast
from franceinter.episodes.episodes_with_keyword import episodes_with_keyword
from franceinter.episodes.episodes_between_dates import episodes_between_dates
from franceinter.episodes.episodes_from_year import episodes_from_year
from franceinter.episodes.episodes_from_month import episodes_from_month
from franceinter.episodes.episodes_from_day import episodes_from_day
#+end_src

**** Tests

#+begin_src python :tangle franceinter/episodes/tests/__init__.py

#+end_src

*** episodes_from_podcast
**** 1. Objetivo

Obtener el listado de episodios de un podcast.

Con el podcast obtiene el listado de páginas y de cada página extrae el listado de episodios.

**** 2. Firma

La función recibe un =franceinter.podcast.Podcast= y devuelve un =GeneratorType= de =franceinter.episodes.Episode=

**** 3. Ejemplos

- Caso exitoso, un podcast válido
- Un podcast con el URL vacío
- Un podcast con el URL inválido
- Un objeto que no es un =franceinter.podcasts.Podcast=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_podcast.py
from franceinter.podcasts import Podcast

def valid_podcast():
    title = "Sur les epaules de Darwin"
    url = "http://localhost:3000/episode-list.html"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_empty_url():
    title = "Sur les epaules de Darwin"
    url = ""
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_invalid_url():
    title = "Sur les epaules de Darwin"
    url = "ghu:\\{this]url^is((not?valid.com"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def invalid_podcast():
    return "this is not a podcast object"

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_podcast(podcast):
    # validar el podcast
    # obtener el listado de URLs usando pages_from_podcast
    # para cada URL obtener los episodios usando episodes_from_url
    yield episode

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_podcast.py
from franceinter.podcasts import Podcast
from franceinter.episodes import pages_from_podcast, episodes_from_url


def episodes_from_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    pages = pages_from_podcast(podcast)
    for url in pages:
        episodes = episodes_from_url(url)
        for episode in episodes:
            yield episode


def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % str(type(podcast))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un podcast válido, devuelve un =GeneratorType= con los episodios del podcast
- Cuando recibe un podcast con el URL vacío, lanza un =AssertionError=
- Cuando recibe un podcast con el URL inválido, lanza un =AssertionError=
- Cuando recibe un objeto que no es un =franceinter.podcasts.Podcast=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_podcast.py
import types
import pytest
import threading
from franceinter.episodes import Episode, episodes_from_podcast
from franceinter.episodes.tests.examples_episodes_from_podcast import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    podcast = valid_podcast()
    episodes = episodes_from_podcast(podcast)
    assert isinstance(episodes, types.GeneratorType)
    for episode in episodes:
        assert isinstance(episode, Episode)

def test_podcast_with_empty_url():
    podcast = podcast_with_empty_url()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    podcast = podcast_with_invalid_url()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

def test_invalid_podcast():
    podcast = invalid_podcast()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_episodes_from_podcast.py
#+end_src

*** episodes_with_keyword
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que contienen una palabra clave en el título

Se debe buscar la palabra clave sin tener encuenta las mayúsculas o minúsculas (case insensitive match)

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y un =str=, y devuelve un =filter= de objetos =franceinter.episodes.Episode=

Para el listado de episodios vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que tienen la palabra clave el título 
- Un listado de 5 episodios en el que ninguno tiene la palabra clave en el título
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Una query que no es un =str=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_with_keyword.py
import random
from franceinter.episodes import Episode

def episodes_with_word_in_title(word):
    episodes = list(some_episodes(3))
    ep = new_episode()
    ep.title+= " " + word
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def some_episodes(how_many):
    for i in range(0, how_many):
        yield new_episode()

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_keyword():
    return 42

def new_episode():
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = "2018-09-12"
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_with_keyword(episodes, keyword):
    # validar que los episodios sean iterables
    # validar que la keyword sea un str
    # validar que cada episodio sea un Episode
    # filtrar los episodios con una función que devuelva true 
    # si el título contiene la palabra clave

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_with_keyword.py
import re
from unidecode import unidecode
from franceinter.episodes import Episode

def episodes_with_keyword(episodes, keyword):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(keyword, str), invalid_keyword(keyword)
    valid_episodes = filter(is_episode, episodes)
    contains_keyword = keyword_matcher(keyword)
    return filter(contains_keyword, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def keyword_matcher(keyword):
    def matcher(episode):
        kw = unidecode(keyword)
        title = unidecode(episode.title)
        return (re.search(kw, title, re.IGNORECASE) 
                or (keyword == episode.identifier))
    return matcher
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_keyword(keyword):
    return "keyword parameter must be a string, received %s instead" % type(keyword)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que tienen la palabra clave el título, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno tiene la palabra clave en el título, devuelve un =filter= vacío
- Cuando recibe un listado de podcasts que no es iterable, lanza un =AssertionError=
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Una query que no es un =str=, lanza un =AssertionError=
- Cuando recibe un listado de 5 episodios en el que hay 2 que tienen la palabra "canción" el título y se busca "cancion", devuelve un =filter= con los 2 episodios sin importar la diferencia en la letra "o" acentuada
- Cuando recibe un listado de 5 episodios en el que hay 1 con fecha de publicación "2007-12-23" y se busca la palabra clave "2007-12-23", devuelve un =filter= con ese episodio

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_with_keyword.py
import types
import datetime
from franceinter.episodes import episodes_with_keyword
from franceinter.episodes.tests.examples_episodes_with_keyword import *

def test_episodes_with_word_in_title():
    episodes = episodes_with_word_in_title("radio")
    result = episodes_with_keyword(episodes, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_without_word():
    episodes = some_episodes(5)
    result = episodes_with_keyword(episodes, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        result = episodes_with_keyword(episodes, "radio")
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        result = episodes_with_keyword(episodes, "radio")
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_query():
    episodes = some_episodes(10)
    keyword = invalid_keyword()
    try:
        result = episodes_with_keyword(episodes, keyword)
    except AssertionError:
        assert True

def test_episodes_with_accented_word():
    episodes = episodes_with_word_in_title("canción")
    result = episodes_with_keyword(episodes, "cancion")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_with_identifier():
    episodes = list(some_episodes(5))
    title = "My december 2007 episode"
    episodes[2].title = title
    episodes[2].date = datetime.date(2007, 12, 23)
    result = list(episodes_with_keyword(episodes, "2007-12-23"))
    assert (len(result) == 1)
    assert (result[0].title == title)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_with_keyword.py
#+end_src

*** episodes_from_year
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados en un año determinado

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y un número entero con el año y devuelve un =filter= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados en un año dado
- Un listado de 5 episodios en el que ninguno fue publicado en un año dado
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Un año que no es un =int=
- Un año que es negativo

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_year.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes import Episode

def some_episodes_with_year(year):
    other_year = year + 5
    episodes = list(episodes_with_year(3, other_year))
    ep = new_episode(year)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def episodes_with_year(how_many, year):
    for i in range(0, how_many):
        yield new_episode(year)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_year():
    return "This is not a year"

def negative_year():
    return -42

def new_episode(year):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = Date(year, 4, 16)
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_year(episodes, year):
    # validar que los episodios sean iterables
    # validar que el año sea un int > 0
    # filtrar los episodios con una función que devuelva true 
    # si la fecha tiene el año correcto

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_year.py
from datetime import date as Date
from franceinter.episodes import Episode, episodes_between_dates


def episodes_from_year(episodes, year):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(year, int), invalid_year(year)
    try:
        starting_at = Date(year, 1, 1)
        ending_at = Date(year, 12, 31)
    except:
        starting_at = False
        ending_at = False
    assert starting_at and ending_at, invalid_year(year)
    valid_episodes = filter(is_episode, episodes)
    return episodes_between_dates(valid_episodes, starting_at, ending_at)


def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True

    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)


def invalid_year(year):
    return "year parameter must be a date, received %s instead" % type(year)


def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados en un año dado, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado en un año dado, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe un año que no es un =int=, lanza un =AssertionError=
- Cuando recibe un año que es negativo, devuelve un =filter= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_year.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes import episodes_from_year
from franceinter.episodes.tests.examples_episodes_from_year import *


def test_episodes_from_year():
    year = 1987
    episodes = some_episodes_with_year(year)
    result = episodes_from_year(episodes, year)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_from_another_year():
    year = 1987
    episodes = episodes_with_year(5, year)
    another_year = 1948
    result = episodes_from_year(episodes, another_year)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        year = 1987
        result = episodes_from_year(episodes, year)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        year = 1987
        result = episodes_from_year(episodes, year)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_year():
    year = 1987
    episodes = episodes_with_year(5, year)
    inv_year = invalid_year()
    try:
        result = episodes_from_year(episodes, inv_year)
    except AssertionError:
        assert True

def test_negative_year():
    year = 1987
    episodes = episodes_with_year(5, year)
    neg_year = negative_year()
    try:
        result = episodes_from_year(episodes, neg_year)
    except AssertionError:
        assert True
#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_year.py
#+end_src

*** episodes_from_month
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados en un mes determinado

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y dos números enteros con el año y el mes respectivamente, y devuelve un =filter= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados en un mes dado
- Un listado de 5 episodios en el que ninguno fue publicado en un mes dado
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Un año que no es un =int=
- Un mes que no es un =int=
- Un año que es negativo
- Un mes que es negativo
- Un mes que es mayor a 12

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_month.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes import Episode

def some_episodes_with_month(year, month):
    other_year = year + 5
    episodes = list(episodes_with_month(3, other_year, month))
    ep = new_episode(year, month)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def episodes_with_month(how_many, year, month):
    for i in range(0, how_many):
        yield new_episode(year, month)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_year():
    return "This is not a year"

def invalid_month():
    return "This is not a month"

def new_episode(year, month):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = Date(year, month, 16)
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_month(episodes, year, month):
    # validar que los episodios sean iterables
    # validar que el año sea un int > 0
    # validar que el mes sea un int entre 1 y 12
    # filtrar los episodios con una función que devuelva true 
    # si la fecha tiene el mes correcto

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_month.py
from calendar import monthrange
from datetime import date as Date
from franceinter.episodes import Episode, episodes_between_dates


def episodes_from_month(episodes, year, month):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    try:
        (first_day, last_day) = monthrange(year, month)
        starting_at = Date(year, month, first_day)
        ending_at = Date(year, month, last_day)
    except:
        starting_at = False
        ending_at = False
    assert starting_at and ending_at, invalid_month(year, month)
    valid_episodes = filter(is_episode, episodes)
    return episodes_between_dates(valid_episodes, starting_at, ending_at)


def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    

def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)


def invalid_month(year, month):
    return "year and month parameters must contain valid month, received %s-%s instead" % (year, month)


def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados en un mes dado, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado en un mes dado, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe un año que no es un =int=, lanza un =AssertionError=
- Cuando recibe un año que es negativo, devuelve un =filter= vacío
- Cuando recibe un mes que no es un =int=, lanza un =AssertionError=
- Cuando recibe un mes que no está entre 1 y 12, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_month.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes import episodes_from_month
from franceinter.episodes.tests.examples_episodes_from_month import *

def test_episodes_from_month():
    year = 1987
    month = 2
    episodes = some_episodes_with_month(year, month)
    result = episodes_from_month(episodes, year, month)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_from_another_month():
    year = 1987
    month = 5
    episodes = episodes_with_month(5, year, month)
    another_year = 1948
    result = episodes_from_month(episodes, another_year, month)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        year = 1987
        month = 4
        result = episodes_from_month(episodes, year, month)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        year = 1987
        month = 4
        result = episodes_from_month(episodes, year, month)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_year():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    inv_year = invalid_year()
    try:
        result = episodes_from_month(episodes, inv_year, month)
    except AssertionError:
        assert True

def test_negative_year():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    neg_year = -998
    try:
        result = episodes_from_month(episodes, neg_year, month)
    except AssertionError:
        assert True

def test_invalid_month():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    inv_month = invalid_month()
    try:
        result = episodes_from_month(episodes, year, inv_month)
    except AssertionError:
        assert True

def test_negative_month():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    negative_month = -5
    try:
        result = episodes_from_month(episodes, year, negative_month)
    except AssertionError:
        assert True

def test_month_over_12():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    month_over_12 = 18
    try:
        result = episodes_from_month(episodes, year, month_over_12)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_month.py
#+end_src

*** episodes_from_day
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados en un día determinado

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y tres números enteros con el año, el mes y el día respectivamente, y devuelve un =filter= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados en un día dado
- Un listado de 5 episodios en el que ninguno fue publicado en un día dado
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Un año que no es un =int=
- Un mes que no es un =int=
- Un día que no es un =int=
- Un año que es negativo
- Un mes que es negativo
- Un día que es negativo
- Un mes que es mayor a 12
- Un día que es mayor a 31

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_day.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes import Episode

def some_episodes_with_day(year, month, day):
    other_year = year + 5
    episodes = list(episodes_with_day(3, other_year, month, day))
    ep = new_episode(year, month, day)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def episodes_with_day(how_many, year, month, day):
    for i in range(0, how_many):
        yield new_episode(year, month, day)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_year():
    return "This is not a year"

def invalid_month():
    return "This is not a month"

def invalid_day():
    return "This is not a day"

def new_episode(year, month, day):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = Date(year, month, day)
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_day(episodes, year, month, day):
    # validar que los episodios sean iterables
    # validar que el año sea un int > 0
    # validar que el mes sea un int entre 1 y 12
    # validar que el mes sea un int entre 1 y 31
    # filtrar los episodios con una función que devuelva true 
    # si la fecha tiene el día correcto

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_day.py
import datetime
from datetime import date as Date
from franceinter.episodes import Episode, episodes_between_dates


def episodes_from_day(episodes, year, month, day):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    try:
        episode_day = Date(year, month, day)
    except:
        episode_day = False
    assert episode_day, invalid_date(year, month, day)
      
    valid_episodes = filter(is_episode, episodes)
    return episodes_between_dates(valid_episodes, episode_day, episode_day)


def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    

def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)


def invalid_date(year, month, day):
    return "invalid date received: %s-%s-%s [Y-m-d]" % (year, month, day)


def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados en un mes dado, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado en un mes dado, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe un año que no es un =int=, lanza un =AssertionError=
- Cuando recibe un año que es negativo, devuelve un =filter= vacío
- Cuando recibe un mes que no es un =int=, lanza un =AssertionError=
- Cuando recibe un mes que no está entre 1 y 12, lanza un =AssertionError=
- Cuando recibe un día que no es un =int=, lanza un =AssertionError=
- Cuando recibe un día que no está entre 1 y 31, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_day.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes import episodes_from_day
from franceinter.episodes.tests.examples_episodes_from_day import *

def test_episodes_from_day():
    year = 1987
    month = 2
    day = 23
    episodes = some_episodes_with_day(year, month, day)
    result = episodes_from_day(episodes, year, month, day)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_from_another_day():
    year = 1987
    month = 5
    day = 21
    episodes = episodes_with_day(5, year, month, day)
    another_year = 1948
    result = episodes_from_day(episodes, another_year, month, day)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        year = 1987
        month = 4
        day = 7
        result = episodes_from_day(episodes, year, month, day)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        year = 1987
        month = 4
        day = 7
        result = episodes_from_day(episodes, year, month, day)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_year():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    inv_year = invalid_year()
    try:
        result = episodes_from_day(episodes, inv_year, month, day)
    except AssertionError:
        assert True

def test_negative_year():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    neg_year = -998
    try:
        result = episodes_from_day(episodes, neg_year, month, day)
    except AssertionError:
        assert True

def test_invalid_month():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    inv_month = invalid_month()
    try:
        result = episodes_from_day(episodes, year, inv_month, day)
    except AssertionError:
        assert True

def test_negative_month():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    negative_month = -5
    try:
        result = episodes_from_day(episodes, year, negative_month, day)
    except AssertionError:
        assert True

def test_month_over_12():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    month_over_12 = 18
    try:
        result = episodes_from_day(episodes, year, month_over_12, day)
    except AssertionError:
        assert True

def test_invalid_day():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    inv_day = invalid_day()
    try:
        result = episodes_from_day(episodes, year, month, inv_day)
    except AssertionError:
        assert True

def test_negative_day():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    negative_day = -5
    try:
        result = episodes_from_day(episodes, year, month, negative_day)
    except AssertionError:
        assert True

def test_day_over_31():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    day_over_31 = 43
    try:
        result = episodes_from_day(episodes, year, month, day_over_31)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_day.py
#+end_src

*** episodes_between_dates
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados entre dos fechas

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y dos objetos =datetime.date= (de inicio y fin del intervalo), y devuelve un =filter= de objetos =franceinter.episodes.Episode=

Para el listado de episodios vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados entre las fechas dadas
- Un listado de 5 episodios en el que ninguno fue publicado entre las fechas dadas
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Una fecha de inicio que no es un =datetime.date=
- Una fecha de fin que no es un =datetime.date=
- Una fecha de inicio que es posterior a la fecha de fin

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_between_dates.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes import Episode

def some_episodes_between_dates(starting_at, ending_at):
    date_outside = ending_at + TimeDelta(days=5)
    episodes = list(some_episodes_with_date(3, date_outside))
    date_between = random_date_between(starting_at, ending_at)
    ep = new_episode(date_between)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def random_date_between(date1, date2):
    days = (date2 - date1).days
    random_days = random.randint(0, days)
    random_date = date1 + TimeDelta(days=random_days)
    return random_date

def some_episodes_with_date(how_many, episode_date):
    for i in range(0, how_many):
        yield new_episode(episode_date)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_date():
    return 42

def new_episode(episode_date):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = episode_date
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_between_dates(episodes, starting_at, ending_at):
    # validar que los episodios sean iterables
    # validar que las fechas sean datetime.date
    # validar que cada episodio sea un Episode
    # filtrar los episodios con una función que devuelva true 
    # si la fecha está entre starting_at y ending_at

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_between_dates.py
from datetime import date as Date
from franceinter.episodes import Episode

def episodes_between_dates(episodes, starting_at, ending_at):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(starting_at, Date), invalid_date(starting_at)
    assert isinstance(ending_at, Date), invalid_date(ending_at)
    valid_episodes = filter(is_episode, episodes)
    is_between_dates = date_filter(starting_at, ending_at)
    return filter(is_between_dates, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def date_filter(starting_at, ending_at):
    def matcher(episode):
        return ((starting_at <= episode.date) 
                and (episode.date <= ending_at))
    return matcher
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_date(date):
    return "starting_at and ending_at parameters must be a date, received %s instead" % type(date)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados entre las fechas dadas, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado entre las fechas dadas, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe una fecha de inicio que no es un =datetime.date=, lanza un =AssertionError=
- Cuando recibe una fecha de fin que no es un =datetime.date=, lanza un =AssertionError=
- Cuando recibe una fecha de inicio que es posterior a la fecha de fin, devuelve un =filter= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_between_dates.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes import episodes_between_dates
from franceinter.episodes.tests.examples_episodes_between_dates import *

def test_episodes_between_dates():
    starting_at = Date.today()
    ending_at = Date.today() + TimeDelta(days=5)
    episodes = some_episodes_between_dates(starting_at, ending_at)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_outside_interval():
    date_outside = Date.today() - TimeDelta(days=30)
    episodes = some_episodes_with_date(5, date_outside)
    starting_at = Date.today()
    ending_at = Date.today() + TimeDelta(days=5)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        starting_at = Date.today()
        ending_at = Date.today() + TimeDelta(days=5)
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        starting_at = Date.today()
        ending_at = Date.today() + TimeDelta(days=5)
        result = episodes_between_dates(episodes, starting_at, ending_at)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_starting_date():
    episode_date = Date.today() + TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = invalid_date()
    ending_at = Date.today() + TimeDelta(days=5)
    try:
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_ending_date():
    episode_date = Date.today() + TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = Date.today()
    ending_at = invalid_date()
    try:
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_interval():
    episode_date = Date.today() - TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = Date.today()
    ending_at = Date.today() - TimeDelta(days=5)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_between_dates.py
#+end_src

*** episodes_from_url
**** 1. Objetivo

Extraer el listado de episodios desde un URL

**** 2. Firma

La función recibe un URL y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un URL con el listado de episodios
- Un URL de otra página, que no tiene episodios
- Un URL de una página inexistente, que dispare un error 404 (not found)
- Un URL de un sitio inexistente, que dispare un error de DNS
- Un URL inválido

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_url.py

def url_ok():
    url = "http://localhost:3000/episode-list.html"
    return url

def wrong_page_url():
    url = "http://localhost:3000/wrong-page.html"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def wrong_site_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

def invalid_url():
    url = "ht pt:\\hostlocal:3000/this-url-is-not-valid.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_url(url):
    # validar el url
    # realizar una petición al url
    # obtener la respuesta del url
    # obtener los episodes llamando a episodes_from_response
    # revisar si da un error de conexión
    return episodes

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_url.py
import requests
from validators.url import url as is_valid_url
from franceinter.episodes import episodes_from_response

def episodes_from_url(url):
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        episodes = episodes_from_response(response)
        return episodes
    except requests.ConnectionError:
        assert False, connection_error(url)

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url
#+end_src

**** 6. Casos de prueba

- Cuando recibe un URL con el listado de episodios, devuelve un =GeneratorType= de objetos =Episode=
- Cuando recibe un URL de otra página, que no tiene episodios, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de una página inexistente, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de un sitio inexistente (error de DNS), lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_url.py
import os
import pytest
import threading
import types
from franceinter.episodes import Episode, episodes_from_url
from franceinter.episodes.tests.examples_episodes_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = url_ok()
    gen = episodes_from_url(url)
    assert isinstance(gen, types.GeneratorType)
    episodes = list(gen)
    assert (len(episodes) > 0)
    for e in episodes:
        assert isinstance(e, Episode)

def test_wrong_page_url(http_server):
    url = wrong_page_url()
    episodes = list(episodes_from_url(url))
    assert (len(episodes) == 0)

def test_not_found_url(http_server):
    url = not_found_url()
    episodes = list(episodes_from_url(url))
    assert (len(episodes) == 0)

@pytest.mark.skipif(os.environ.get('ENV') == 'DEV', reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = wrong_site_url()
    try:
        episodes = list(episodes_from_url(url))
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        episodes = episodes_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_url.py
#+end_src

*** episodes_from_response
**** 1. Objetivo

Extraer el listado de episodios de la respuesta de una petición HTTP

**** 2. Firma

La función recibe una =requests.model.Response= y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Una respuesta válida, con el HTML de una página del listado de episodios
- Una respuesta inválida, que no es de la clase =requests.model.Response=
- Una respuesta válida, pero que tiene el HTML de otra página

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_response.py
from requests.models import Response

def response_ok():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/episode-list.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

def invalid_response():
    return "i am not a Response"

def wrong_page_response():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/wrong-page.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

#+end_src

**** 4. Boceto

#+begin_src python
import requests

def episodes_from_response(resp):
    # validar la respuesta
    # obtener el HTML de resp.text
    # extraer los tags usando tags_from_html
    # obtener los podcasts usando episodes_from_tags

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_response.py
import requests
from franceinter.episodes import tags_from_html, episodes_from_tags

def episodes_from_response(resp):
    assert isinstance(resp, requests.models.Response), invalid_type(resp)
    html = resp.text
    tags = tags_from_html(html)
    episodes = episodes_from_tags(tags)
    return episodes
    
def invalid_type(resp):
    return "resp parameter must be a requests.models.Response, received %s instead" % type(resp)

#+end_src

**** 6. Casos de prueba

- Cuando recibe una respuesta válida, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Cuando recibe una respuesta que no es de la clase =requests.model.Response=, lanza un =AssertionError=
- Cuando recibe una respuesta válida que tiene el HTML de otra página, devuelve un =GeneratorType= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_response.py
import types
from franceinter.episodes import Episode, episodes_from_response
from franceinter.episodes.tests.examples_episodes_from_response import *

def test_response_ok():
    resp = response_ok()
    episodes = episodes_from_response(resp)
    assert isinstance(episodes, types.GeneratorType)
    for e in episodes:
        assert isinstance(e, Episode)

def test_invalid_response():
    resp = invalid_response()
    try:
        episodes = episodes_from_response(resp)
    except AssertionError:
        assert True
    
def test_wrong_page_response():
    resp = wrong_page_response()
    episodes = episodes_from_response(resp)
    assert isinstance(episodes, types.GeneratorType)
    assert (len(list(episodes)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_response.py
#+end_src

*** episodes_from_filename
**** 1. Objetivo

Extraer un listado de episodios desde un archivo

**** 2. Firma

La función recibe un =str= con el nombre del archivo y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un archivo HTML que tiene un listado de episodios
- Un archivo HTML de otra página, que no tiene episodios
- Un archivo que no existe
- Un nombre de archivo que no es un =str=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_filename.py

def ok_filename():
    return "./franceinter/html/episode-list.html"

def wrong_filename():
    return "./franceinter/html/wrong-page.html"

def not_found_filename():
    return "./franceinter/html/this-file-does-not-exist.html"

def invalid_filename():
    return [1, 2, 3]

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_filename(filename):
    # validar que filename sea un str
    # validar que el archivo exista
    episodes = []
    # crear un requests.models.Response con el contenido del archivo
    # obtener los episodios llamando a episodes_from_response
    return episodes
     
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_filename.py
from requests.models import Response
from franceinter.episodes import episodes_from_response

def episodes_from_filename(filename):
    assert isinstance(filename, str), invalid_filename(filename)
    resp = Response()
    episodes = []
    try:
        with open(filename, "rb") as f:
            resp._content = f.read()
            episodes = episodes_from_response(resp)
    except (OSError, IOError) as error:
        assert False, not_found(filename, error)
    return episodes

def invalid_filename(filename):
    return "filename parameter must be a str, %s received instead" % filename

def not_found(filename, error):
    return "filename %s cannot be read, thrown error :\n%s" % (filename, error)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un archivo HTML que tiene un listado de podcasts, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Cuando recibe un archivo HTML de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un archivo que no existe, lanza un =AssertionError=
- Cuando recibe un nombre de archivo que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_filename.py
import types
from franceinter.episodes import Episode, episodes_from_filename
from franceinter.episodes.tests.examples_episodes_from_filename import *

def test_ok_filename():
    filename = ok_filename()
    episodes = episodes_from_filename(filename)
    assert isinstance(episodes, types.GeneratorType)
    episodes = list(episodes)
    assert (len(episodes) > 0)
    for e in episodes:
        assert isinstance(e, Episode)

def test_wrong_filename():
    filename = wrong_filename()
    episodes = episodes_from_filename(filename)
    assert isinstance(episodes, types.GeneratorType)
    episodes = list(episodes)
    assert (len(episodes) == 0)

def test_not_found_filename():
    filename = not_found_filename()
    try:
        episodes = episodes_from_filename(filename)
    except AssertionError:
        assert True

def test_invalid_filename():
    filename = invalid_filename()
    try:
        episodes = episodes_from_filename(filename)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_episodes_from_filename.py
#+end_src

#+RESULTS:
:results:
:end:

*** episodes_from_tags
**** 1. Objetivo

Generar un listado de episodios a partir de un listado de fragmentos de HTML tomados de la página

**** 2. Firma

La función recibe un listado de objetos =bs4.element.Tag= y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

Vamos a aceptar tanto un =list= como un =GeneratorType=

**** 3. Ejemplos

- Un objeto que no es iterable
- Una lista vacía
- Una lista con tags válidos
- Una lista con objetos que no son del tipo =bs4.element.Tag=
- Una lista con tags válidos y un tag inválido (sin el título o el URL)

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_tags.py
import random
from franceinter.episodes import tags_from_html
from franceinter.episodes.tests.examples_episode_from_tag import (
    tag_ok,
    tag_without_title
)

def invalid_list():
    return 123

def empty_list():
    return []

def list_without_tags():
    return [1, 2, 3, 4, 5]

def list_with_valid_tags(how_many):
    html = "<div class='diffusions-list'>"
    for i in range(1, how_many):
        html+= str(tag_ok())
    html+= "</div>"
    tags = tags_from_html(html)
    return tags

def list_with_invalid_tag(how_many):
    tags = list(list_with_valid_tags(how_many - 1))
    tags.append(tag_without_title())
    random.shuffle(tags)
    return tags

#+end_src

**** 4. Boceto

#+begin_src python
from franceinter.episodes import tags_from_html

def podcasts_from_tags(tags):
    # validar que tags sea un GeneratorType
    # para cada tag de la lista
    # usar episode_from_tag() para obtener un podcast
    # yield posdcast

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_tags.py
from franceinter.episodes import episode_from_tag

def episodes_from_tags(tags):
    try:
        it = iter(tags)
    except TypeError:
        assert False, invalid_tags(tags)
    for tag in tags:
        yield episode_from_tag(tag)

def invalid_tags(tags):
    return "tags parameter must be iterable, received %s instead" % type(tags)
#+end_src

**** 6. Casos de prueba

- Si recibe un objeto que no es iterable, lanza un =AssertionError=
- Si recibe una lista vacía, devuelve un =GeneratorType= vacío
- Si recibe una lista de tags válidos, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Si recibe una lista con objetos que no son del tipo =bs4.element.Tag=, lanza un =AssertionError=
- Si recibe una lista con algún tag inválido (que no tenga el título o el URL), lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_tags.py
import types
from franceinter.episodes import Episode, episodes_from_tags
from franceinter.episodes.tests.examples_episodes_from_tags import *

def test_invalid_list():
    tags = invalid_list()
    try:
        episodes = list(episodes_from_tags(tags))
    except AssertionError:
        assert True

def test_empty_list():
    tags = empty_list()
    episodes = episodes_from_tags(tags)
    assert isinstance(episodes, types.GeneratorType)
    assert (len(list(episodes))==0)

def test_list_with_valid_tags():
    tags = list_with_valid_tags(6)
    episodes = episodes_from_tags(tags)
    assert isinstance(episodes, types.GeneratorType)
    for e in episodes:
        assert (isinstance(e, Episode))

def test_list_without_tags():
    tags = list_without_tags()
    try:
        episodes = list(episodes_from_tags(tags))
    except AssertionError:
        assert True

def test_list_with_invalid_tag():
    tags = list_with_invalid_tag(6)
    episodes = episodes_from_tags(tags)
    try:
        for e in episodes:
            assert (isinstance(e, Episode))
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_tags.py
#+end_src

*** pages_from_podcast
**** 1. Objetivo

Obtener un listado de URLs de las páginas del listado de episodios a partir de los datos de un podcast.

**** 2. Firma

La función recibe un objeto =franceinter.podcasts.Podcast= y devuelve un =GeneratorType= con los URLs de las páginas del historial de episodios.

**** 3. Ejemplos

- Caso exitoso, un podcast válido
- Un podcast con el URL vacío
- Un podcast con el URL inválido
- Un objeto que no es un =franceinter.podcasts.Podcast=

#+begin_src python :tangle franceinter/episodes/tests/examples_pages_from_podcast.py
from franceinter.podcasts import Podcast

def valid_podcast():
    title = "Sur les epaules de Darwin"
    url = "http://localhost:3000/episode-list.html"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_empty_url():
    title = "Sur les epaules de Darwin"
    url = ""
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_invalid_url():
    title = "Sur les epaules de Darwin"
    url = "ghu:\\{this]url^is((not?valid.com"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def invalid_podcast():
    return "this is not a podcast object"

#+end_src

**** 4. Boceto

#+begin_src python

def pages_from_podcast(podcast):
    # validar que el podcast sea una instancia de Podcast
    # validar el url
    # obtener el HTML del URL
    # obtener el número de la última página del HTML
    # generar los URLs de las páginas agregando ?p=XX al URL del podcast
    yield page_url

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/pages_from_podcast.py
from franceinter.podcasts import Podcast
from franceinter.episodes import lastpage_from_html
from utils.html import html_from_url

def pages_from_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    html = html_from_url(podcast.url)
    lastpage = lastpage_from_html(html)
    for page_number in range(1, lastpage + 1):
        page_url = podcast.url + "?p=" + str(page_number)
        yield page_url

def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % str(type(podcast))

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un podcast válido, devuelve un =GeneratorType= con los URLs de las páginas del podcast
- Cuando recibe un podcast con el URL vacío, lanza un =AssertionError=
- Cuando recibe un podcast con el URL inválido, lanza un =AssertionError=
- Cuando recibe un objeto que no es un =franceinter.podcasts.Podcast=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_pages_from_podcast.py
import types
import pytest
import threading
from validators.url import url as is_valid_url
from franceinter.episodes import pages_from_podcast
from franceinter.episodes.tests.examples_pages_from_podcast import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    podcast = valid_podcast()
    pages = pages_from_podcast(podcast)
    assert isinstance(pages, types.GeneratorType)
    for page in pages:
        assert is_valid_url(page)

def test_podcast_with_empty_url():
    podcast = podcast_with_empty_url()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    podcast = podcast_with_invalid_url()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

def test_invalid_podcast():
    podcast = invalid_podcast()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_pages_from_podcast.py
#+end_src

*** lastpage_from_html
**** 1. Objetivo

Obtener la cantidad de páginas del HTML del listado de episodios.

En el HTML del listado de episodios de un podcast hay un paginador donde podemos encontrar la cantidad total de páginas, buscando un tag =<li>= que tiene la clase =last=. Dentro de ese =<li>= hay un link a la última página, que se encuentra en el atributo =href=. 

**** 2. Firma

La función recibe un =str= con el HTML y devuelve un =int= con el número de la última página.

**** 3. Ejemplos

- Caso exitoso, un HTML con el tag =<li>= que tiene la clase =last= y el =<a>= con el atributo =href= correcto
- Un HTML que no es un =str=
- Un HTML que no tiene el tag =<li>=
- Un HTML que tiene el tag =<li>=, pero éste no tiene la clase =last=
- Un HTML que tiene el tag =<li>= con la clase =last=, pero éste no tiene el =<a>=

#+begin_src python :tangle franceinter/episodes/tests/examples_lastpage_from_html.py

def html_ok():
    html = '''<div>
<li class="pager-item last">
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

def invalid_html():
    return 4321

def html_without_item():
    html = '''<div>
<span class="pager-item last">
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</span>
    </div>'''
    return html

def html_without_class():
    html = '''<div>
<li>
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

def html_without_link():
    html = '''<div>
<li>
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

#+end_src

**** 4. Boceto

#+begin_src python

def lastpage_from_html(html):
    # validar que el html sea un str
    # buscar un <li> con la clase =last=
    # si existe buscar dentro un <a> y extraer el atributo "href"
    # extraer al final del href uno o más números [0-9]
    lastpage = 1
    return lastpage

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/lastpage_from_html.py
from bs4 import BeautifulSoup
import re

def lastpage_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    lastpage = 1
    item = soup.find("li", class_="last")
    if item:
        href = item.find("a").attrs["href"]
        match = re.search("([0-9]+)$", href)
        if match:
            lastpage = int(match.groups()[0])
    return lastpage
     
def invalid_html(html):
    return "html parameter must be a string, %s received" % str(type(html))

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un HTML con el tag =<li>= que tiene la clase =last=, devuelve el número de la última página
- Cuando recibe un HTML que no es un =str=, lanza un =AssertionError=
- Cuando recibe un HTML que no tiene el tag =<li>=, devuelve la primera página (=1=)
- Cuando recibe un HTML que tiene el tag =<li>=, pero éste no tiene la clase =last=, devuelve la primera página (=1=)
- Cuando recibe un HTML que tiene el tag =<li>= con la clase =last=, pero éste no tiene el =<a>=, devuelve la primera página (=1=)

#+begin_src python :tangle franceinter/episodes/tests/test_lastpage_from_html.py
from franceinter.episodes import lastpage_from_html
from franceinter.episodes.tests.examples_lastpage_from_html import *

def test_html_ok():
    html = html_ok()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 22)

def test_invalid_html():
    html = invalid_html()
    try:
        lastpage = lastpage_from_html(html)
    except AssertionError:
        assert True

def test_html_without_item():
    html = html_without_item()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

def test_html_without_class():
    html = html_without_class()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

def test_html_without_link():
    html = html_without_link()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_lastpage_from_html.py
#+end_src

*** tags_from_html
**** 1. Objetivo

Obtener un array de tags con los fragmentos de html que tienen el detalle del episodio (título, URL, fecha de emisión y duración) a partir del html de la página con el listado de episodios.

Hay que extraer todos los =<button>= que tengan la clase =replay-button= y que estén dentro de un =<div>= que tiene clase =diffusions-list=. Necesitamos extraer solamente los botones que están dentro de este div porque en el HTML de la página hay otros botones que son de otros podcasts.

**** 2. Firma

La función recibe un =str= con el html de la página y devuelve un =GeneratorType= de elementos =bs4.element.Tag=

**** 3. Ejemplos

- Un html que tiene un =<div>= con la clase buscada y que contiene varios =<button>= con la clase =replay-button=
- Un html que no es un =str=
- Un html que no tiene ningún =<div>=
- Un html que tiene varios =<div>= pero que ninguno tiene la clase =diffusions-list=
- Un html que tiene un =<div>= con la clase buscada y que contiene algunos =<buttons>= con la clase =replay-button= y otros que no la tienen

#+begin_src python :tangle franceinter/episodes/tests/examples_tags_from_html.py
from bs4 import BeautifulSoup
import random

def html_with_buttons(how_many):
    btn_class = "replay-button"
    buttons = map(lambda x: button("click here", btn_class), range(how_many))
    cls_name = "diffusions-list"
    return html(buttons, cls_name)

def html_is_not_string():
    return 42

def html_without_divs():
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>'''
    return html

def html_divs_without_class(how_many):
    content = "blablabla"
    divs = map(lambda x: div(content), range(how_many))
    return html(divs)

def html_some_buttons_with_class(how_many_with, how_many_without):
    cls = "replay-button"
    buttons_with = list(map(lambda x: button("click here", cls), range(how_many_with)))
    buttons_without = list(map(lambda x: button("click here"), range(how_many_without)))
    buttons = buttons_with + buttons_without
    random.shuffle(buttons)
    class_name = "diffusions-list"
    return html(buttons, class_name)

def button(content, class_name=""):
    attr = ""
    if class_name:
        attr = 'class="%s"' % class_name
    html = '''<button %s>%s</button>''' % (attr, content)
    soup = BeautifulSoup(html, "html.parser")
    return soup.button

def div(content):
    html = '''<div>%s</div>''' % content
    soup = BeautifulSoup(html, "html.parser")
    return soup.div

def html(elements, class_name=""):
    attr = ""
    if class_name:
        attr = 'class="%s"' % class_name
    content = "".join(map(lambda e: str(e), elements))
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<div %s>
%s
</div>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    ''' % (attr, content)
    return html
    
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup

def tags_from_html(html):
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # buscar el <div> que tiene la clase "diffusions-list"
    # dentro de ese <div> filtrar todos los <button> 
    # que tienen la clase =replay-button=
    yield tag

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/tags_from_html.py
from bs4 import BeautifulSoup

def tags_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    div = soup.find("div", class_="diffusions-list")
    if div:
        buttons = div.find_all("button", class_="replay-button")
        for tag in buttons:
            yield tag

def invalid_html(html):
    return "html parameter must be a string, received %s instead" % type(html)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un html que tiene un =<div>= con la clase buscada y que contiene varios =<button>= con la clase =replay-button=, devuelve un =GeneratorType= que tiene tantos elementos como =<button>= haya en el html
- Cuando recibe un html que no es un string, lanza un =AssertionError=
- Cuando recibe un html que no tiene ningún =<div>=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene varios =<div>= pero ninguno tiene la clase =rich-section-list-item-content=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen, devuelve un =GeneratorType= con solamente los =<div>= que tienen la clase

#+begin_src python :tangle franceinter/episodes/tests/test_tags_from_html.py
import types
from franceinter.episodes import tags_from_html
from franceinter.episodes.tests.examples_tags_from_html import *

def test_html_with_buttons():
    html = html_with_buttons(5)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 5)

def test_html_is_not_string():
    try:
        html = html_is_not_string()
        tags = list(tags_from_html(html))
    except AssertionError:
        assert True

def test_html_without_divs():
    html = html_without_divs()
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_divs_without_class():
    html = html_divs_without_class(4)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_some_buttons_with_class():
    html = html_some_buttons_with_class(2,3)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 2)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_tags_from_html.py
#+end_src

*** episode_from_tag
**** 1. Objetivo

Obtener un episodio de un fragmento de html.

Un episodio tiene cuatro propiedades, a saber:

- título :: es un =str= y es obligatorio
- url :: es un =str=, es obligatorio y debe ser un URL válido
- fecha de emisión :: es un =str=, es obligatoria y debe ser una fecha válida en formato =YYYY-MM-DD=
- duración en segundos :: es un =int= y es obligatoria

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un objeto =franceinter.episodes.episode=

Necesitamos entonces definir la clase =Episode=

#+begin_src python :tangle franceinter/episodes/episode.py

class Episode:
    def __init__(self, title, url, date, duration):
        self.title = title
        self.url = url
        self.date = date
        self.duration = duration

    @property
    def identifier(self):
        return str(self.date)

    def __repr__(self):
        return "Episode(title='%s', date='%s')" % (
            self.title, self.date
        )

#+end_src

**** 3. Ejemplos

- Un tag que tiene todos los elementos para generar un episodio válido (título, URL, fecha y duración)
- Un tag que no es un =bs4.element.Tag=
- Un tag que no tiene el elemento del título
- Un tag que no tiene el elemento del URL
- Un tag que no tiene el elemento de la fecha
- Un tag que no tiene el elemento de la duración
- Un tag que tiene el elemento del URL, pero el URL no es válido
- Un tag que tiene el elemento de la fecha, pero ésta no es válida
- Un tag que tiene el elemento de la duración, pero ésta no es válida

#+begin_src python :tangle franceinter/episodes/tests/examples_episode_from_tag.py
from bs4 import BeautifulSoup

def tag_ok():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def invalid_tag():
    return "I am not a tag"

def tag_without_title():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_url():
    html = '''<button class="replay-button playable"
            data-diffusion-title="Une année dans le monde"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_date():
    html = '''<button class="replay-button playable"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_duration():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_url():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="this://isnot[?=>avalid[[/\\url"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_date():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-mercredi-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_duration():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="forty minutes"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def episode_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag

    # extraer el título con title_from_tag
    # validar que el título no sea un string vacío

    # extraer el url con url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer la fecha con date_from_tag
    # validar la fecha

    # extraer la duración con duration_from_tag
    # validar que la duración sea > 0

    # crear una instancia de franceinter.epidsodes.Episode
    # con el título, el url, la fecha y la duración
    return episode

#+end_src

**** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceinter/episodes/episode_from_tag.py
from franceinter.episodes import (
    title_from_tag,
    url_from_tag,
    date_from_tag,
    duration_from_tag,
    Episode
)
from validators.url import url as is_valid_url
import datetime
import bs4

def episode_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = title_from_tag(tag)
    assert (title != ""), no_title(tag)

    url = url_from_tag(tag)
    assert (url != ""), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)

    date = date_from_tag(tag)
    assert (date != None), no_date(tag)

    duration = duration_from_tag(tag)
    assert (duration != 0), invalid_duration(tag)

    return Episode(title, url, date, duration)

def no_url(tag):
    return "received tag does not have an episode URL\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid episode URL\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have an episode title\n %s" % str(tag)

def no_date(tag):
    return "received tag does not have an episode publication date\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_duration(tag):
    return "received tag has an invalid duration\n %s" % str(tag)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve un episodio (=franceinter.episodes.Episode=)
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento del título, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento del URL, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento de la fecha, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento de la duración, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento del URL, pero el URL no es válido, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento de la fecha, pero ésta no es válida, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento de la duración, pero ésta no es válida, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episode_from_tag.py
from franceinter.episodes import Episode, episode_from_tag
from franceinter.episodes.tests.examples_episode_from_tag import *

def test_episode_ok():
    tag = tag_ok()
    episode = episode_from_tag(tag)
    assert isinstance(episode, Episode)
    assert (len(str(episode)) > 0)

def test_tag_without_title():
    tag = tag_without_title()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_url():
    tag = tag_without_url()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_date():
    tag = tag_without_date()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_duration():
    tag = tag_without_duration()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_url():
    tag = tag_with_invalid_url()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_date():
    tag = tag_with_invalid_date()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_duration():
    tag = tag_with_invalid_duration()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_invalid_tag():
    tag = invalid_tag()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episode_from_tag.py
#+end_src

*** title_from_tag
**** 1. Objetivo

Obtener el título de un episodio de un fragmento de HTML.

El título se puede obtener en dos lugares: 

- En el atributo =data-diffusion-title= de un =<button>= que tiene la clase =replay-button=
- En el atributo =title= de un =<a>= que tiene la clase =rich-section-list-item-content-title=

Elegimos sacarlo del button porque tiene todos los atributos que necesitamos obtener (titlulo, url, fecha y duración) en el mismo tag

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y el atributo =data-diffusion-title=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-diffusion-title=

#+begin_src python :tangle franceinter/episodes/tests/examples_title_from_tag.py
from bs4 import BeautifulSoup

def tag_with_title():
    html = '''<button class="replay-button" 
    data-diffusion-title="Sur les epaules de Darwin">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<p class="replay-button" 
    data-diffusion-title="Sur les epaules de Darwin">
</p>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.p
    return tag

def tag_without_class():
    html = '''<button data-diffusion-title="Sur les epaules de Darwin">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_title():
    html = '''<button class="replay-buttton"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def title_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    title = ""
    # validar que sea un <button>
    # validar que tenga la clase "replay-button"
    # revisar si tiene el atributo "data-diffusion-title"
    # si tiene el atributo se guarda en la variable title
    return title
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/title_from_tag.py
import bs4

def title_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = ""
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-diffusion-title" in tag.attrs):
        title = tag.attrs["data-diffusion-title"]
    return title

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y el atributo =data-diffusion-title=, devuelve el título
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve un string vacío
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve un string vacío
- Cuando recibe un =<button>= que no tiene el atributo =data-diffusion-title=, devuelve un string vacío

#+begin_src python :tangle franceinter/episodes/tests/test_title_from_tag.py
from franceinter.episodes import title_from_tag
from franceinter.episodes.tests.examples_title_from_tag import *

def test_author_ok():
    tag = tag_with_title()
    assert ("Sur les epaules de Darwin" == title_from_tag(tag))

def test_invalid_tag():
    try:
        title_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert ("" == title_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == title_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == title_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_title_from_tag.py
#+end_src

*** url_from_tag
**** 1. Objetivo

Obtener el URL de descarga de un episodio a partir de un fragmento de html.

El URL se encuentra en el atributo =data-url= de un tag =<button>= que tiene la clase =replay-button=. 

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y un URL en el atributo =data-url=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-url=

#+begin_src python :tangle franceinter/episodes/tests/examples_url_from_tag.py
from bs4 import BeautifulSoup

def tag_with_url():
    html = '''<button class="replay-button" 
    data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_class():
    html = '''<button data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<a class="replay-button" 
    data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</a>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.a
    return tag

def tag_without_url():
    html = '''<button class="replay-button">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def url_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    url = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-url"
    # se guarda el valor del atributo en la variable url
    return url
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/url_from_tag.py
import bs4
from requests.utils import requote_uri

def url_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    url = ""
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-url" in tag.attrs):
        url = tag.attrs["data-url"]
        if " " in url:
            url = requote_uri(url)
    return url

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y un URL en el atributo =data-url=, devuelve el URL
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve un string vacío
- Cuando recibe un tag =<button>= que no tiene la clase =replay-button=, devuelve un string vacío
- Cuando recibe un tag =<button>= que no tiene el atributo =data-url=, devuelve un string vacío

#+begin_src python :tangle franceinter/episodes/tests/test_url_from_tag.py
from franceinter.episodes import url_from_tag
from franceinter.episodes.tests.examples_url_from_tag import *

def test_url_ok():
    tag = tag_with_url()
    assert (len(url_from_tag(tag)) > 0)

def test_invalid_url():
    try:
        url_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert ("" == url_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == url_from_tag(tag))

def test_url_not_found():
    tag = tag_without_url()
    assert ("" == url_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_url_from_tag.py
#+end_src

**** 7. Bugfixes

- Cuando recibe un tag que tiene un url con espacios en el atributo =data-url=, devuelve el url escapado reemplazando los espacios por =%20=

#+begin_src python :tangle franceinter/episodes/tests/test_bugfixes_url_from_tag.py
from bs4 import BeautifulSoup
from franceinter.episodes import url_from_tag


def test_tag_with_space_in_url():
    tag = tag_with_space_in_url()
    url = url_from_tag(tag)
    assert "%20" in url


def tag_with_space_in_url():
    html = '''<button class="replay-button" 
    data-url="https://s3-eu-west-1.amazonaws.com/cruiser-production/static/inter/sons/2011/07/s27/carrefour (2).mp3">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag
#+end_src

*** date_from_tag
**** 1. Objetivo

Obtener la fecha de emisión de un episodio a partir de un fragmento de html.

La fecha de emisión se encuentra en el atributo =data-diffusion-path= de un tag =<button>= que tiene la clase =replay-button=. En ese atributo, la fecha se encuentra al final del path en formato =día-mes-año=, con el mes en palabras.

Ejemplo: ~data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"~. 

Tenemos que extraer la fecha del path y devolverla como un =datetime.date=

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =datetime.date=

**** 3. Ejemplos

- Caso exitoso, un =<button>= con la clase =replay-button= y una fecha en el atributo =data-diffusion-path=
- Un tag que no es un =<button>=
- Un =<button>= que no tiene la clase =replay-button=
- Un =<button>= que no tiene el atributo =data-diffusion-path=

#+begin_src python :tangle franceinter/episodes/tests/examples_date_from_tag.py
from bs4 import BeautifulSoup

def tag_with_date():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_class():
    html = '''<button 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<a class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</a>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.a
    return tag

def tag_without_date():
    html = '''<button class="replay-button">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

# la fecha es inválida porque el mes debe estar en francés
def tag_with_invalid_month():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-january-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

# la fecha es inválida porque el día es > 31
def tag_with_invalid_day():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-42-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def date_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    date = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-diffusion-path"
    # se guarda el valor del atributo en la variable attr

    # usar una expresión regular para extraer del atributo:
    # - dos números para el día [0-9] 
    # - seguidos de un guión
    # - seguido de una o más letras para el mes [a-z]
    # - seguidos de un guión
    # - seguidos de cuatro números para el año [0-9]
    # - seguidos del fin del string ($)

    # transformar el mes en números con una función auxiliar
    # crear el objeto datetime.date con el año, el día y el mes
    # validar la fecha
    
    return date
    
def month_from_name(month_name):
    # recibe el nombre (janvier, fevrier, etc)
    # y devuelve el número (1, 2, etc)
    return month_num

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/date_from_tag.py
import bs4
import re
import datetime

def date_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    date = None
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-diffusion-path" in tag.attrs):

        attr = tag.attrs["data-diffusion-path"]
        match = re.search("([0-9]{2})-([a-z]+)-([0-9]{4})(-[0-9])*$", attr)
        if match:
            try:
                date = datetime.date(
                    int(match.group(3)), 
                    month_from_name(match.group(2)), 
                    int(match.group(1))
                )
            except ValueError:
                assert False, invalid_date(match, tag)
    return date

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_date(date, tag):
    return "received tag has an invalid date [%s]\n %s" % (str(date), str(tag))

def month_from_name(month_name):
    try:
        return {
            'janvier': 1,
            'fevrier': 2,
            'mars': 3,
            'avril': 4,
            'mai': 5,
            'juin': 6,
            'juillet': 7,
            'aout': 8,
            'septembre': 9,
            'octobre': 10,
            'novembre': 11,
            'decembre': 12
        }[month_name]
    except KeyError:
        assert False, invalid_month(month_name)

def invalid_month(month_name):
    return "invalid month name, %s received" % month_name

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un =<button>= con la clase =replay-button= y una fecha en el atributo =data-diffusion-path=, devuelve la fecha
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve =None=
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve =None=
- Cuando recibe un =<button>= que no tiene el atributo =data-diffusion-path=, devuelve =None=
- Cuando recibe un =<button>= que tiene una fecha inválida en el atributo =data-diffusion-path=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_date_from_tag.py
import datetime
from franceinter.episodes import date_from_tag
from franceinter.episodes.tests.examples_date_from_tag import *

def test_url_ok():
    tag = tag_with_date()
    assert (datetime.date(2019, 1, 26) == date_from_tag(tag))

def test_invalid_tag():
    try:
        date_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert (None == date_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert (None == date_from_tag(tag))

def test_date_not_found():
    tag = tag_without_date()
    assert (None == date_from_tag(tag))

def test_invalid_month():
    tag = tag_with_invalid_month()
    try:
        date_from_tag(tag)
    except AssertionError:
        assert True

def test_invalid_day():
    tag = tag_with_invalid_day()
    try:
        date_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_date_from_tag.py
#+end_src

**** 7. Bugfixes

- Encontré un podcast que tiene la propiedad =data-diffusion-path= con la fecha pero que la expresión regular de =date_from_tag= no logra parsear porque tiene un sufijo (=-0=)

#+begin_src html
E       AssertionError: received tag does not have an episode publication date
E        <button class="replay-button playable" 
data-broadcast-type="replay" 
data-clip-type="réécoute" 
data-diffusion-path="/emissions/3d-le-journal/3d-le-journal-24-mai-2015-0" 
data-diffusion-title="En direct de St-Malo pour le Festival Etonnants Voyageurs" 
data-...
#+end_src

#+begin_src python :tangle franceinter/episodes/tests/test_bugfixes_date_from_tag.py
import datetime
from bs4 import BeautifulSoup
from franceinter.episodes import date_from_tag

def test_tag_with_date_and_suffix():
    tag = tag_with_date_and_suffix()
    assert (datetime.date(2015, 5, 24) == date_from_tag(tag))


def tag_with_date_and_suffix():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/3d-le-journal/3d-le-journal-24-mai-2015-0">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag
#+end_src

*** duration_from_tag
**** 1. Objetivo

Obtener la duración en segundos de un episodio a partir de un fragmento de html.

La duración se encuentra en el atributo =data-duration-seconds= de un tag =<button>= que tiene la clase =replay-button=. 

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =int=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y una duración válida en el atributo =data-duration-seconds=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-duration-seconds=
- Un tag =<button>= con la clase =replay-button= pero que no contiene un número entero en el atributo =data-duration-seconds=

#+begin_src python :tangle franceinter/episodes/tests/examples_duration_from_tag.py
from bs4 import BeautifulSoup

def tag_with_duration():
    html = '''<button class="replay-button" 
data-duration-seconds="3256">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<p class="replay-button" 
data-duration-seconds="3256">
</p>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.p
    return tag

def tag_without_class():
    html = '''<button data-duration-seconds="3256"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_duration():
    html = '''<button class="replay-button"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_duration():
    html = '''<button class="replay-button" 
data-duration-seconds="six seconds">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def duration_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un integer
    duration = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-duration-seconds"
    # se guarda el valor del atributo en la variable duration

    # validar que la duración sea un número entero
    return duration

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/duration_from_tag.py
import bs4

def duration_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    duration = 0
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-duration-seconds" in tag.attrs):

        value = tag.attrs["data-duration-seconds"]
        try:
            duration = int(value)
        except ValueError:
            assert False, invalid_duration(value, tag)
    return duration

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_duration(duration, tag):
    return "data-duration-seconds attribute must be int, received %s instead\n%s" % (str(type(duration)), tag)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y una duración válida en el atributo =data-duration-seconds=, devuelve la duración
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe tag que no es un =<button>=, devuelve =0=
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve =0=
- Cuando recibe un =<button>= que no tiene el atributo =data-url=, devuelve =0=
- Cuando recibe un =<button>= con la clase =replay-button= pero que no contiene un número entero en el atributo =data-duration-seconds=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_duration_from_tag.py
from franceinter.episodes import duration_from_tag
from franceinter.episodes.tests.examples_duration_from_tag import *

def test_duration_ok():
    tag = tag_with_duration()
    assert (3256 == duration_from_tag(tag))

def test_invalid_url():
    try:
        duration_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert (0 == duration_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert (0 == duration_from_tag(tag))

def test_duration_not_found():
    tag = tag_without_duration()
    assert (0 == duration_from_tag(tag))

def test_invalid_duration():
    tag = tag_with_invalid_duration()
    try:
        duration_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_duration_from_tag.py
#+end_src

** HTML

Vamos a usar cURL para descargar el HTML de las diferentes páginas que necesitamos parsear, así podemos desarrollar y ejecutar los casos de prueba sin tener conexión a Internet. Guardamos los archivos en la carpeta =franceinter/html=.

#+begin_src sh
mkdir -p ./franceinter/html
curl -o ./franceinter/html/podcast-list.html https://www.franceinter.fr/emissions
head -n 1000 ./franceinter/html/podcast-list.html > franceinter/html/podcast-list-short.html
curl -o ./franceinter/html/episode-list.html https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin
head -n 1000 ./franceinter/html/episode-list.html > franceinter/html/episode-list-short.html
curl -o ./franceinter/html/wrong-page.html https://www.pagina12.com.ar
ls -alh ./franceinter/html
#+end_src

#+RESULTS:
:results:
total 11568
drwxr-xr-x   8 martin  staff   256B Mar 18 23:57 .
drwxr-xr-x   7 martin  staff   224B Mar 19 00:52 ..
drwxr-xr-x  11 martin  staff   352B Mar 19 00:02 emissions
-rw-r--r--   1 martin  staff    82K Mar 19 01:05 episode-list-short.html
-rw-r--r--   1 martin  staff   275K Mar 19 01:05 episode-list.html
-rw-r--r--   1 martin  staff    85K Mar 19 01:05 podcast-list-short.html
-rw-r--r--   1 martin  staff   4.1M Mar 19 01:05 podcast-list.html
-rw-r--r--   1 martin  staff    20K Mar 19 01:05 wrong-page.html
:end:

* France Culture
** Diseño

Ahora estamos trabajando con nuestra segunda fuente de podcasts y encontramos que hay funcionalidades que podemos reutilizar de lo hecho con France Inter.

La mayoría de las funciones =podcasts_from_*= y =episodes_from_*= se pueden generalizar a partir de las ya existentes en el módulo France Inter, para poder usarlas en ambos módulos (y en los que vendrán).

El objetivo es que en cada módulo de una fuente queden unicamente las funciones que se usan para extraer los atributos que necesitamos de los podcasts y los episodios a partir del HTML de la fuente.

** Módulos

#+begin_src python :tangle franceculture/__init__.py

#+end_src

** Podcasts
*** Wishlist

- [ ] Obtener el listado de los podcasts de France Culture
- [ ] Para cada podcast obtener el nombre y el url
- [ ] Filtrar el listado de podcasts por una palabra clave
- [ ] Asignarle un identificador a cada podcast

*** TODO Mejoras

- [ ] Extraer las funciones =podcasts_from_*= :: Hay que crear un módulo genérico =podcasts= que tenga las funciones que obtienen y filtran los podcasts que se diseñaron en el módulo FranceInter. Este nuevo módulo debe llamar a las funciones correspondientes que saben como parsear cada fuente.

*** =__init.py__=
**** Funciones

#+begin_src python :tangle franceculture/podcasts/__init__.py
from franceculture.podcasts.podcast import Podcast
from franceculture.podcasts.url_from_tag import url_from_tag
from franceculture.podcasts.podcast_from_tag import podcast_from_tag
#+end_src

**** Tests

#+begin_src python :tangle franceculture/podcasts/tests/__init__.py

#+end_src

*** url_from_tag
**** 1. Objetivo

Obtener el URL de un podcast a partir de un fragmento de HTML.

El URL se encuentra en el atributo =href= de un tag =<a>= que tiene la clase =content=

**** 2. Firma

La función recibe un =str= con el fragmento de HTML y devuelve el URL del podcast.

**** 3. Ejemplos

- Caso exitoso, un fragmento de HTML que tiene un tag =<a>= con la clase =<content>= y un link en el atributo =href=
- Un fragmento de HTML que no tiene el tag =<a>=
- Un fragmento de HTML que no tiene la clase =content=
- Un fragmento de HTML que no tiene el atributo =href=
- Un fragmento de HTML que no es un =str=

#+begin_src python :tangle franceculture/podcasts/tests/examples_url_from_tag.py
def html_with_tag_class_attr(tag, cls, attr, value):
    return f'''<{tag} {attr}="{value}" class="{cls}"></{tag}>'''
#+end_src

**** 4. Boceto

#+begin_src python
def url_from_tag(html):
    # obtener el path con attribute_from_tag ("a", "content", "href")
    # agregar el base URL de France Culture
    return url
#+end_src

**** 5. Definición

#+begin_src python :tangle franceculture/podcasts/url_from_tag.py
from utils.html import attribute_from_tag

def url_from_tag(html):
    url = False
    path = attribute_from_tag(html, "a", "content", "href")
    if path:
        url = "https://www.franceculture.fr/" + path
    return url
#+end_src

**** 6. Casos de prueba

- Caso exitoso, un fragmento de HTML que tiene un tag =<a>= con la clase =<content>= y un link en el atributo =href=
- Un fragmento de HTML que no tiene el tag =<a>=
- Un fragmento de HTML que no tiene la clase =content=
- Un fragmento de HTML que no tiene el atributo =href=
- Un fragmento de HTML que no es un =str=

#+begin_src python :tangle franceculture/podcasts/tests/test_url_from_tag.py
from franceculture.podcasts import url_from_tag
from franceculture.podcasts.tests.examples_url_from_tag import *

def test_html_with_tag_class_attr():
    path = "emissions/fictions-le-feuilleton"
    html = html_with_tag_class_attr("a", "content", "href", path)
    url = url_from_tag(html)
    assert path in url

def test_html_without_tag():
    path = "emissions/fictions-le-feuilleton"
    html = html_with_tag_class_attr("div", "content", "href", path)
    url = url_from_tag(html)
    assert url == False
    
def test_html_without_class():
    path = "emissions/fictions-le-feuilleton"
    html = html_with_tag_class_attr("div", "left", "href", path)
    url = url_from_tag(html)
    assert url == False
    
def test_html_without_attr():
    date = "2019-02-02"
    html = html_with_tag_class_attr("div", "content", "date", date)
    url = url_from_tag(html)
    assert url == False
    
def test_html_not_str():
    html = 42
    try:
        url = url_from_tag(html)
    except AssertionError:
        assert True
#+end_src

***** Run tests

#+begin_src sh
pytest ./franceculture/podcasts/tests/test_url_from_tag.py
#+end_src

*** podcast_from_tag
**** 1. Objetivo

Obtener un podcast de un fragmento de HTML. 

Un podcast tiene cuatro propiedades principales, a saber:

- título :: es un =str= y es obligatorio
- url :: es un =str=, es obligatorio y debe ser un URL válido
- descripción :: es un =str=, pero puede estar vacía

**** 2. Firma

La función recibe un =str= con un fragmento de HTML y devuelve un objeto =franceculture.podcasts.podcast=

Necesitamos entonces definir la clase =podcast=

#+begin_src python :tangle franceculture/podcasts/podcast.py
class Podcast:
    def __init__(self, title, url, description=""):
        self.title = title
        self.url = url
        self.description = description


    @property
    def identifier(self):
        return self.url.lower().replace(
            "https://www.franceculture.fr/emissions/", ""
        )


    def __repr__(self):
        return "Podcast(title='%s', url='%s')" % (self.title, self.url)
#+end_src

**** 3. Ejemplos

- Un fragmento de HTML que tiene todos los elementos para generar un podcast válido (título, URL y descripción)
- Un HTML que no es un =str=
- Un HTML que no tiene el elemento del título
- Un HTML que no tiene el elemento del URL
- Un HTML que tiene el elemento del URL, pero el URL no es válido
- Un HTML que no tiene el elemento de la descripción

#+begin_src python :tangle franceculture/podcasts/tests/examples_podcast_from_tag.py
def html_with_title_and_href(title, href):
    html = f'''<a href="{href}" class="content">
<span class="title name">{title}</span>
<p class="text">30 minutes d’espace de création radiophonique, de grandes adaptations d’œuvres du patrimoine classique et contemporain pour mêler tous les métiers et les...</p>
    </a>'''
    return html


def html_without_title():
    html = '''<a href="/emissions/fictions-le-feuilleton" class="content">
<p class="text">30 minutes d’espace de création radiophonique, de grandes adaptations d’œuvres du patrimoine classique et contemporain pour mêler tous les métiers et les...</p>
    </a>'''
    return html


def html_without_url():
    html = '''<a class="content">
<span class="title name">Fictions / Le Feuilleton</span>
<p class="text">30 minutes d’espace de création radiophonique, de grandes adaptations d’œuvres du patrimoine classique et contemporain pour mêler tous les métiers et les...</p>
    </a>'''
    return html


def html_with_invalid_url():
    html = '''<a href="/emi:\\ hht :0393; ee" class="content">
<span class="title name">Fictions / Le Feuilleton</span>
<p class="text">30 minutes d’espace de création radiophonique, de grandes adaptations d’œuvres du patrimoine classique et contemporain pour mêler tous les métiers et les...</p>
    </a>'''
    return html


def html_without_description():
    html = '''<a href="/emissions/fictions-le-feuilleton" class="content">
<span class="title name">Fictions / Le Feuilleton</span>
    </a>'''
    return html

#+end_src

**** 4. Boceto

#+begin_src python
def podcast_from_tag(tag):
    # validar que el tag sea un =str= 

    # extraer el título usando content_from_tag
    # validar que el título no sea un string vacío

    # extraer el url usando url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer la descripción usando content_from_tag

    # crear una instancia de franceculture.podcasts.podcast
    # con el título, el url y la descripción
    return podcast
#+end_src

**** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceculture/podcasts/podcast_from_tag.py
from utils.html import content_from_tag
from validators.url import url as is_valid_url
from franceculture.podcasts import (
    url_from_tag, 
    Podcast
)

def podcast_from_tag(tag):
    assert isinstance(tag, str), invalid_tag(tag)
    title = content_from_tag(tag, "span", "title")
    assert (title != ""), no_title(tag)
    url = url_from_tag(tag)
    assert (url != False), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)
    description = content_from_tag(tag, "p", "text")
    return Podcast(title, url, description)

def no_url(tag):
    return "received tag does not have a podcast URL\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid podcast URL\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have a podcast title\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of str, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Cuando recibe un fragmento de HTML que tiene todos los elementos para generar un podcast válido (título, URL y descripción), devuelve un objeto =Podcast= con las propiedades correctas
- Cuando recibe un HTML que no es un =str=, lanza un =AssertionError=
- Cuando recibe un HTML que no tiene el elemento del título, lanza un =AssertionError=
- Cuando recibe un HTML que no tiene el elemento del URL, lanza un =AssertionError=
- Cuando recibe un HTML que tiene el elemento del URL, pero el URL no es válido, lanza un =AssertionError=
- Cuando recibe un HTML que no tiene el elemento de la descripción, devuelve un =Podcast= con la descripción vacía

#+begin_src python :tangle franceculture/podcasts/tests/test_podcast_from_tag.py
from franceculture.podcasts import podcast_from_tag
from franceculture.podcasts.tests.examples_podcast_from_tag import *


def test_html_with_title_and_href():
    title = "Fictions / Le Feuilleton"
    href = "/emissions/fictions-le-feuilleton"
    html = html_with_title_and_href(title, href)
    podcast = podcast_from_tag(html)
    assert title == podcast.title
    assert href in podcast.url


def test_invalid_html():
    title = "Fictions / Le Feuilleton"
    href = "/emissions/fictions-le-feuilleton"
    html = html_with_title_and_href(title, href)
    try:
        podcast = podcast_from_tag(html)
    except AssertionError:
        assert True


def test_html_without_title():
    html = html_without_title()
    try:
        podcast = podcast_from_tag(html)
    except AssertionError:
        assert True


def test_html_without_url():
    html = html_without_url()
    try:
        podcast = podcast_from_tag(html)
    except AssertionError:
        assert True


def test_html_with_invalid_url():
    html = html_with_invalid_url()
    try:
        podcast = podcast_from_tag(html)
    except AssertionError:
        assert True


def test_html_without_description():
    html = html_without_description()
    podcast = podcast_from_tag(html)
    assert podcast.description == False
#+end_src

***** Run tests

#+begin_src sh
pytest ./franceculture/podcasts/tests/test_podcast_from_tag.py
#+end_src

*** TODO podcasts_from_url
**** 1. Objetivo
**** 2. Firma
**** 3. Ejemplos
**** 4. Boceto
**** 5. Definición
**** 6. Casos de prueba
*** TODO podcasts_with_keyword
**** 1. Objetivo
**** 2. Firma
**** 3. Ejemplos
**** 4. Boceto
**** 5. Definición
**** 6. Casos de prueba
*** TODO podcasts_from_response
**** 1. Objetivo
**** 2. Firma
**** 3. Ejemplos
**** 4. Boceto
**** 5. Definición
**** 6. Casos de prueba
*** TODO podcasts_from_tags
**** 1. Objetivo
**** 2. Firma
**** 3. Ejemplos
**** 4. Boceto
**** 5. Definición
**** 6. Casos de prueba
*** TODO podcasts_from_filename
**** 1. Objetivo
**** 2. Firma
**** 3. Ejemplos
**** 4. Boceto
**** 5. Definición
**** 6. Casos de prueba
** Episodes
** HTML

#+begin_src sh
mkdir -p ./franceculture/html
curl -o ./franceculture/html/podcast-list.html https://www.franceculture.fr/emissions
head -n 1000 ./franceculture/html/podcast-list.html > franceculture/html/podcast-list-short.html
curl -o ./franceculture/html/episode-list.html https://www.franceculture.fr/emissions/les-chemins-de-la-philosophie
head -n 1000 ./franceculture/html/episode-list.html > franceculture/html/episode-list-short.html
curl -o ./franceculture/html/wrong-page.html https://www.pagina12.com.ar
ls -alh ./franceculture/html
#+end_src

#+RESULTS:
:results:
total 1856
drwxr-xr-x  7 martin  staff   224B Apr  1 17:54 .
drwxr-xr-x  3 martin  staff    96B Apr  1 17:54 ..
-rw-r--r--  1 martin  staff   183K Apr  1 17:54 episode-list-short.html
-rw-r--r--  1 martin  staff   183K Apr  1 17:54 episode-list.html
-rw-r--r--  1 martin  staff   143K Apr  1 17:54 podcast-list-short.html
-rw-r--r--  1 martin  staff   347K Apr  1 17:54 podcast-list.html
-rw-r--r--  1 martin  staff    20K Apr  1 17:54 wrong-page.html
:end:

* Interface desde línea de comandos
** Diseño
*** Consulta de podcasts y episodios

Quiero que los comandos de consulta sean lo más claro y conciso posible. Tenemos básicamente dos operaciones, listar y ver el detalle, tanto para los podcasts como para los episodios. 

En los listados se puede agregar el argumento =--keyword= que filtra por palabra clave y, para los episodios, también se puede filtrar por año con el argumento =--year= y por mes con =--month=.

Para ver el detalle de un podcast o de un episodio se debe indicar un identificador. En el caso de los podcasts vamos a usar el nombre de la fuente (o su código) seguido de un slash y el identificador del podcast. Para identificar un episodio dentro de un determinado podcast, en principio, vamos a usar como identificador su fecha de publicación, mientras que para identificar un podcast vamos a usar un fragmento de su URL.

#+begin_src sh :eval never

# listar fuentes de podcasts
podcast-db list-sources

# listar podcasts de una fuente
podcast-db list-podcasts --source franceinter
podcast-db list-podcasts --source franceinter --keyword musique

# ver detalle de un podcast
podcast-db --show-podcast franceinter/darwin

# listar episodios de un podcast
podcast-db list-episodes --podcast franceinter/darwin
podcast-db list-episodes --podcast franceinter/darwin --year 2018
podcast-db list-episodes --podcast franceinter/darwin --month 2018-05
podcast-db list-episodes --podcast franceinter/darwin --keyword musique

# ver detalle de un episodio
podcast-db show-episode --episode franceinter/darwin/2018-04-16

#+end_src

** Wishlist

- [X] Validar los argumentos recibidos
- [X] Generar el comando a ejecutar a partir de los argumentos
- [X] Listar las fuentes de podcasts
- [X] Listar los podcasts de una fuente
- [X] Mostrar el detalle de un podcast
- [X] Listar los episodios de un podcast
- [X] Mostrar el detalle de un episodio
- [X] Mostrar el mensaje de ayuda
- [X] Mostrar el mensaje con la versión

** TODO Mejoras

- [ ] =output_from_podcast_list= :: Está devolviendo mal los caracteres acentuados

- [ ] Import de podcasts y episodios :: Hay que crear dos funciones en el módulo =sources= que permitan importar las funciones de podcasts y episodios del módulo correspondiente a una fuente determinada. Podrían llamarse =import_podcasts_from_source= e =import_episodes_from_source=

- [ ] Inyectar el base URL de la fuente en los podcasts :: La función =episodes_from_podcast= utiliza el URL del podcast para ir a buscar los episodios. El problema es que el base URL de los podcasts de France Inter (=https://www.franceinter.fr/=) está harcodeado en la función =url_from_tag= del módulo =franceinter.podcasts= y eso nos causa problemas en las pruebas unitarias de =output_from_episode_list=. El objetivo de las pruebas unitarias es que no realicen ninguna petición HTTP a servicios externos, pero con ese URL fijo dentro del podcast se hace difícil evitarlo. Como solución provisoria se agregó un =if= que modifica el base URL del podcast si la fuente es =testing=, pero esa no es la manera correcta de hacerlo. Se podría agregar en la clase =Podcast= un método para reemplazar el base URL o para agregar la fuente.

- [ ] Entender el import circular en =handler_from_command= :: Si se ponen los imports de las funciones =output_from_*= al inicio de =handler_from_command= fallan los tests de la mayoría de las funciones =cli/arguments/*_from_arguments=. El error que devuelven es =TypeError: 'module' object is not callable=, que por lo que entiendo se produce por un import circular.

#+begin_src python :eval never
from cli.output import (
    output_from_source_list,
    output_from_podcast_list,
    output_from_episode_list,
    output_from_podcast_details,
    output_from_episode_details
)
#+end_src

- [ ] Agregar tests para el resto de los comandos en =output_from_command= :: Solamente se está testeando el comando =list-sources=, porque para testear el resto hay que levantar el servidor http y probar los comandos de listado y detalle de podcasts y episodios usando la fuente de testing.

- [ ] Múltiples podcasts en list-episodes :: Cuando se desean ver los episodios del podcast "La Tête au carré", el comando devuelve un error por resultados múltiples debido a que hay dos podcasts que tienen la misma frase. Dado que el título del podcast "La revue de presse de la tête au carré" contiene el título completo del podcast "La Tête au carré", no existe un keyword que devuelva solamente éste último y no ambos. Hay que modificar el comando para que, en ese caso, devuelva un solo resultado si el keyword coincide exactamente con el identificador del podcast.

#+begin_src text
root@0fd889236ded:/app/dist# ./podcast-db list-episodes --podcast=fri/la-tete-au-carre
Found multiple records with identifier 'la-tete-au-carre'

- la-revue-de-presse-de-la-tete-au-carre [La revue de presse de la tête au carré]
- la-tete-au-carre [La Tête au carré]
#+end_src

** Implementación
*** =__init.py__=

#+begin_src python :tangle cli/__init__.py
__version__ = "0.2.0"
#+end_src

*** CLI script

Generamos el script =./podcast-db= que será la interface desde línea de comandos de la aplicación, parseando los parámetros recibidos y ejecutando las acciones correspondientes.

#+begin_src python :tangle podcast-db :tangle-mode (identity #o755)
#!/usr/bin/env python-3.6
import requests
import requests_cache
from cli.arguments import parser
from cli.output import output_from_command

requests_cache.install_cache()
parser = parser()
args = parser.parse_args()
if args.command:
    try:
        output = output_from_command(args)
    except AssertionError as ex:
        output = str(ex)

print(output)
print("")
#+end_src

#+begin_src text
usage:  [-h] [-v] [--source SOURCE] [--podcast PODCAST] [--episode EPISODE]
        [--keyword KEYWORD] [--year YEAR] [--month MONTH]
        command

Query podcasts and episodes from France Inter

positional arguments:
  command            list-sources | list-podcasts | list-episodes | show-
                     podcast | show-episode

optional arguments:
  -h, --help         show this help message and exit
  -v , --version     show version
  --source SOURCE    source name or code ('franceinter' or 'fri')
  --podcast PODCAST  podcast identifier string ('sur-les-epaules')
  --episode EPISODE  episode date in YYYY-MM-DD format ('2018-04-17')
  --keyword KEYWORD  filter list by keyword ('musique')
  --year YEAR        filter list by year ('2018')
  --month MONTH      filter list by month ('2018-03')
#+end_src

*** Arguments

En este módulo se encuentran las funciones que se encargan de procesar los argumentos
que recibe la aplicación. Básicamente, hay un solo argumento posicional obligatorio (=command=) y el resto son argumentos opcionales que indican la entidad buscada (=--source=, =--podcast=, =--episode=) y los filtros que se desean aplicar (=--keyword=, =--year=, =--month=).

**** =__init.py__=
***** Funciones

#+begin_src python :tangle cli/arguments/__init__.py
from cli.arguments.known_arguments import known_arguments
from cli.arguments.parser_from_arguments import parser_from_arguments
from cli.arguments.argument_from_namespace import argument_from_namespace
from cli.arguments.command_from_arguments import command_from_arguments
from cli.arguments.source_from_arguments import source_from_arguments
from cli.arguments.podcast_from_arguments import podcast_from_arguments
from cli.arguments.episode_from_arguments import episode_from_arguments
from cli.arguments.keyword_from_arguments import keyword_from_arguments
from cli.arguments.year_from_arguments import year_from_arguments
from cli.arguments.month_from_arguments import month_from_arguments

def parser():
    arguments = known_arguments()
    parser = parser_from_arguments(arguments)
    parser.description = "Query podcasts and episodes from France Inter"
    return parser
#+end_src

***** Tests

#+begin_src python :tangle cli/arguments/tests/__init__.py

#+end_src

**** known_arguments
***** 1. Objetivo

Obtener el listado de los parámetros que acepta nuestro programa desde la línea de comandos

***** 2. Firma

La función no recibe argumentos y devuelve una lista de tuplas =(*args, **kwargs)=.

Cada tupla contiene los argumentos que recibe el método =add_argument= de la clase =argparse.Parser= para agregar un nuevo parámetro al parser de línea de comandos.

***** 3. Ejemplos

Dado que la función no recibe argumentos, no es necesario confeccionar ejemplos.

***** 4. Boceto

#+begin_src python

def known_arguments():
    # devuelve una lista de tuplas
    arguments = []
    # agregar una tupla para cada parámetro
    return arguments

#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/known_arguments.py
import cli
from cli.commands import known_commands

def known_arguments():
    args = []
    args.append((
        ["command"],
        {
            "help": " | ".join(known_commands()),  
            "choices": known_commands(),
            "metavar": "command"
        }
    ))
    args.append((
        ["-v", "--version"], 
        {"help": "show version", "action": "version", "version": cli.__version__}
    ))
    args.append((
        ["--source"], 
        {"help": "source name or code ('franceinter' or 'fri')"}
    ))
    args.append((
        ["--podcast"], 
        {"help": "podcast identifier string ('sur-les-epaules')"}
    ))
    args.append((
        ["--episode"], 
        {"help": "episode date in YYYY-MM-DD format ('2018-04-17')"}
    ))
    args.append((
        ["--keyword"], 
        {"help": "filter list by keyword ('musique')"}
    ))
    args.append((
        ["--year"], 
        {"help": "filter list by year ('2018')"}
    ))
    args.append((
        ["--month"], 
        {"help": "filter list by month ('2018-03')"}
    ))
    return args

#+end_src

***** 6. Casos de prueba

- Todas las tuplas deben tener un =str= como primer elemento de los argumentos posicionales
- Todas las tuplas deben tener un =str= con el mensaje de ayuda en la clave =help= de los argumentos de diccionario
- Todos los argumentos que acepta el programa deben estar presentes en los argumentos posicionales

#+begin_src python :tangle cli/arguments/tests/test_known_arguments.py
from cli.arguments import known_arguments


def test_postitional_arguments():
    tuples = known_arguments()
    for (args, kwargs) in tuples:
        assert isinstance(args[0], str)


def test_keyword_arguments():
    tuples = known_arguments()
    for (args, kwargs) in tuples:
        assert 'help' in kwargs
        assert isinstance(kwargs['help'], str)
        assert len(kwargs['help']) > 0


def test_arguments_are_present():
    tuples = known_arguments()
    arguments = [
        "command", "-v", "--version",
        "--source", "--podcast", "--episode",
        "--year", "--month", "--keyword",
    ]
    for argument in arguments:
        found = False
        for (args, kwargs) in tuples:
            if argument in args:
                found = True
                break
        assert found, "argument tuples do not contain '%s' argument" % argument

#+end_src

****** Run tests

#+begin_src sh
pytest cli/arguments/tests/test_known_arguments.py
#+end_src

**** parser_from_arguments
***** 1. Objetivo

Obtener el parser de argumentos de línea de comando

***** 2. Firma

La función recibe una lista de tuplas =(args, kwargs)= y devuelve un objeto =argparse.ArgumentParser=

***** 3. Ejemplos

- Caso exitoso, una lista con una tupla de un argumento
- Una lista de tuplas vacía
- Una lista de tuplas que no es un =list=
- Una lista de tuplas con un elemento que no es una tupla
- Una lista con una tupla que no tiene un =list= en su primer elemento
- Una lista con una tupla que no tiene un =dict= en su segundo elemento

#+begin_src python :tangle cli/arguments/tests/examples_parser_from_arguments.py

def valid_argument_list():
    args = [
        (["argument-1"], {"help": "help message for arg 1"}),
        (["--argument-2"], {"help": "help message for arg 2"})
    ]
    return args

def empty_argument_list():
    args = []
    return args

def invalid_argument_list():
    args = 42
    return args

def list_with_invalid_arguments():
    args = valid_argument_list()
    args.append(42)
    return args

def argument_list_without_list_as_first():
    args = [(42, {"help": "help message for command"})]
    return args
    
def argument_list_without_dict_as_second():
    args = [(["valid_command"], 42)]
    return args

#+end_src

***** 4. Boceto

#+begin_src python
import argparse

def parser_from_arguments(args):
    parser = argparse.ArgumentParser()
    # validar que args sea una lista
    # validar que cada elemento de la lista
    # sea una tupla (list, dict)
    # agregarle al parser un argumento para cada tupla
    # usando parser.add_argument()
    return parser

#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/parser_from_arguments.py
import argparse

def parser_from_arguments(arguments):
    parser = argparse.ArgumentParser()
    assert isinstance(arguments, list), invalid_list(arguments)

    for t in arguments:
        assert isinstance(t, tuple), invalid_tuple(t)
        (args, kwargs) = t
        assert isinstance(args, list), invalid_args(args)
        assert isinstance(kwargs, dict), invalid_kwargs(kwargs)
        parser.add_argument(*args, **kwargs)

    return parser

def invalid_list(arguments):
    return "arguments parameter must be a list, received %s instead" % type(arguments)

def invalid_tuple(tup):
    return "tup parameter must be a tuple, received %s instead" % type(tup)

def invalid_args(args):
    return "args parameter must be a list, received %s instead" % type(args)

def invalid_kwargs(kwargs):
    return "kwargs parameter must be a dict, received %s instead" % type(kwargs)

#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe una lista con una tupla de un argumento, devuelve un =ArgumentParser= que tiene asignado ese argumento
- Cuando recibe una lista de tuplas vacía, devuelve un =ArgumentParser= vacío
- Cuando recibe lista de tuplas que no es un =list=, lanza un =AssertionError=
- Cuando recibe lista de tuplas con un elemento que no es un =tuple=, lanza un =AssertionError=
- Cuando recibe una lista con una tupla que no tiene un =list= en su primer elemento, lanza un =AssertionError=
- Cuando recibe una lista con una tupla que no tiene un =dict= en su segundo elemento, lanza un =AssertionError=

#+begin_src python :tangle cli/arguments/tests/test_parser_from_arguments.py
from argparse import ArgumentParser, Namespace
from cli.arguments import parser_from_arguments
from cli.arguments.tests.examples_parser_from_arguments import *

def test_valid_argument_list():
    arguments = valid_argument_list()
    parser = parser_from_arguments(arguments)
    args = parser.parse_args(["argument-1"])
    assert isinstance(parser, ArgumentParser)
    assert isinstance(args, Namespace)
    
def test_empty_argument_list():
    arguments = empty_argument_list()
    parser = parser_from_arguments(arguments)
    args = parser.parse_args([])
    assert isinstance(parser, ArgumentParser)
    assert isinstance(args, Namespace)

def test_invalid_argument_list():
    arguments = invalid_argument_list()
    try:
        parser = parser_from_arguments(arguments)
    except AssertionError:
        assert True

def test_list_with_invalid_arguments():
    arguments = list_with_invalid_arguments()
    try:
        parser = parser_from_arguments(arguments)
    except AssertionError:
        assert True

def test_argument_list_without_list_as_first():
    arguments = argument_list_without_list_as_first()
    try:
        parser = parser_from_arguments(arguments)
    except AssertionError:
        assert True

def test_argument_list_without_dict_as_second():
    arguments = argument_list_without_dict_as_second()
    try:
        parser = parser_from_arguments(arguments)
    except AssertionError:
        assert True

#+end_src

****** Run tests

#+begin_src sh
pytest cli/arguments/tests/test_parser_from_arguments.py
#+end_src

**** argument_from_namespace
***** 1. Objetivo

Verificar la existencia de un argumento recibido por la aplicación y obtener su valor.

***** 2. Firma

La función recibe un objeto =argparse.Namespace= con los argumentos recibidos, un =str= con el nombre del argumento buscado, y un =bool= que indica si el argumento es obligatorio o no, y devuelve un =str= con el valor del argumento buscado, si existe.

***** 3. Ejemplos

- Caso exitoso, un =Namespace= que tiene un argumento válido
- Un =Namespace= que no es un objeto =argparse.Namespace=
- Un =Namespace= vacío

#+begin_src python :tangle cli/arguments/tests/examples_argument_from_namespace.py
from argparse import Namespace


def namespace_with_argument(name, value):
    args = Namespace()
    setattr(args, name, value)
    return args


def invalid_namespace():
    args = 42
    return args


def empty_namespace():
    args = Namespace()
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def argument_from_namespace(ns, argument, is_required):
    # validar que args sea un Namespace
    # si is_required es True, 
    #       validar que namespace tenga la propiedad argument
    return ns[argument]
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/argument_from_namespace.py
from argparse import Namespace


def argument_from_namespace(ns, argument, is_required=False):
    assert isinstance(ns, Namespace), invalid_namespace(ns)
    value = False
    if hasattr(ns, argument):
        value = getattr(ns, argument)
    if is_required:
        assert value, required_argument(ns, argument)
    return value


def invalid_namespace(ns):
    return "ns parameter must be an argparse.Namespace, received %s instead" % type(ns)


def required_argument(ns, argument):
    return "%s argument is required, but not present in received namespace [%s]" % (argument, ns)
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= que tiene el argumento obligatorio buscado, devuelve el valor del argumento
- Caso exitoso, cuando recibe un =Namespace= que tiene el argumento opcional buscado, devuelve el valor del argumento
- Cuando recibe un =Namespace= que no es un objeto =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene el argumento obligatorio buscado, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene el argumento opcional buscado, devuelve =False=

#+begin_src python :tangle cli/arguments/tests/test_argument_from_namespace.py
from cli.arguments import argument_from_namespace
from cli.arguments.tests.examples_argument_from_namespace import *


def test_required_argument():
    ns = namespace_with_argument("keyword", "episode")
    keyword = argument_from_namespace(ns, "keyword", is_required=True)
    assert (keyword == "episode")


def test_optional_argument():
    ns = namespace_with_argument("keyword", "episode")
    keyword = argument_from_namespace(ns, "keyword")
    assert (keyword == "episode")


def test_invalid_namespace():
    ns = invalid_namespace()
    try:
        keyword = argument_from_namespace(ns, "keyword")
    except AssertionError:
        assert True


def test_missing_required_argument():
    ns = empty_namespace()
    try:
        keyword = argument_from_namespace(ns, "keyword", is_required=True)
    except AssertionError:
        assert True


def test_missing_optional_argument():
    ns = empty_namespace()
    keyword = argument_from_namespace(ns, "keyword")
    assert keyword == False
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/arguments/tests/test_argument_from_namespace.py
#+end_src

**** command_from_arguments
***** 1. Objetivo

Obtener el comando a ejecutar a partir de los argumentos recibidos.

El comando es un argumento obligatorio, por lo tanto la función debe lanzar un error si no se encuentra entre los argumentos recibidos.

***** 2. Firma

La función recibe un objeto =argparse.Namespace= y devuelve un =str=

***** 3. Ejemplos

- Caso exitoso, un =Namespace= que tiene un comando válido en la propiedad =command=
- Un =Namespace= que no es un objeto =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =command=
- Un =Namespace= que tiene un comando desconocido en la propiedad =command=

#+begin_src python :tangle cli/arguments/tests/examples_command_from_arguments.py
from argparse import Namespace


def valid_arguments():
    args = Namespace()
    args.command = "list-podcasts"
    return args


def invalid_arguments():
    args = 42
    return args


def arguments_without_command():
    args = Namespace()
    args.source = "test source"
    return args


def arguments_with_unknown_command():
    args = Namespace()
    args.command = "list-videos"
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def command_from_arguments(args):
    command = ""
    # validar que args sea un Namespace
    # validar que args tenga la propiedad command
    # validar que el comando esté entre los comandos aceptados
    return command
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/command_from_arguments.py
from cli.arguments import argument_from_namespace
from cli.commands import known_commands

def command_from_arguments(args):
    command = argument_from_namespace(args, "command", is_required=True)
    assert command in known_commands(), unknown_command(args.command)
    return command


def unknown_command(command):
    return "unknown command: %s" % command
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= que tiene un comando válido, devuelve un =str= con el comando
- Cuando recibe un =Namespace= que no es un objeto =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =command=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene un comando desconocido en la propiedad =command=, lanza un =AssertionError=

#+begin_src python :tangle cli/arguments/tests/test_command_from_arguments.py
from cli.arguments import command_from_arguments
from cli.arguments.tests.examples_command_from_arguments import *


def test_valid_arguments():
    args = valid_arguments()
    command = command_from_arguments(args)
    assert isinstance(command, str)


def test_invalid_arguments():
    args = invalid_arguments()
    try:
        command = command_from_arguments(args)
    except AssertionError:
        assert True


def test_arguments_without_command():
    args = arguments_without_command()
    try:
        command = command_from_arguments(args)
    except AssertionError:
        assert True
    

def test_arguments_with_unknown_command():
    args = arguments_with_unknown_command()
    try:
        command = command_from_arguments(args)
    except AssertionError:
        assert True
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/arguments/tests/test_command_from_arguments.py
#+end_src

**** source_from_arguments
***** 1. Objetivo

Obtener la fuente de podcasts a partir de los argumentos recibidos

***** 2. Firma

La función recibe un objeto =argparse.Namespace= con el nombre o el código de una fuente y devuelve un objeto =sources.Source= con la fuente recibida

***** 3. Ejemplos

- Caso exitoso, un =Namespace= que tiene el nombre de una fuente válida en la propiedad =source=
- Caso exitoso, un =Namespace= que tiene el código de una fuente válida en la propiedad =source=
- Caso exitoso, un =Namespace= que tiene una fuente válida en la propiedad =podcast=
- Caso exitoso, un =Namespace= que tiene una fuente válida en la propiedad =episode=
- Un =Namespace= que no es un objeto =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =source=
- Un =Namespace= tiene una fuente desconocida en la propiedad =source=

#+begin_src python :tangle cli/arguments/tests/examples_source_from_arguments.py
from argparse import Namespace

def arguments_with_valid_source_name():
    args = Namespace()
    args.source = "franceinter"
    return args

def arguments_with_valid_source_code():
    args = Namespace()
    args.source = "fri"
    return args

def arguments_with_valid_source_in_podcast():
    args = Namespace()
    args.podcast = "franceinter/politique-et-societe"
    return args

def arguments_with_valid_source_in_episode():
    args = Namespace()
    args.episode = "fri/politique-et-societe/2018-03-23"
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_source():
    args = Namespace()
    args.command = "list-podcasts"
    return args
    
def arguments_with_unknown_source():
    args = Namespace()
    args.source = "next"
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def source_from_arguments(args):
    # validar que args sea un Namespace
    # verificar si hay una fuente en args.source
    # verificar si hay una fuente en args.podcast
    # verificar si hay una fuente en args.episode
    # validar que la fuente sea conocida
    return source
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/source_from_arguments.py
import re
from cli.arguments import argument_from_namespace
from sources import list_sources

def source_from_arguments(args):
    source = argument_from_namespace(args, "source")
    podcast = argument_from_namespace(args, "podcast")
    if not source and podcast:
        source = source_from_podcast(podcast)
    episode = argument_from_namespace(args, "episode")
    if not source and episode:
        source = source_from_episode(episode)
    assert isinstance(source, str), missing_source(args)
    source = source_from_attribute(source)
    assert source, unknown_source(source)
    return source


def source_from_podcast(podcast):
    source = False
    match = re.search("^([a-z0-9-]+)/([a-z0-9-]+)$", podcast)
    if match:
        source = match.groups()[0]
    return source


def source_from_episode(episode):
    source = False
    match = re.search("^([a-z0-9-]+)/([a-z0-9-]+)/([a-z0-9-]+)$", episode)
    if match:
        source = match.groups()[0]
    return source


def missing_source(args):
    return "arguments parameter must have a source property, received %s" % args


def unknown_source(source):
    return "unknown source: %s" % source


def source_from_attribute(attribute):
    source = False
    for src in list_sources():
        if attribute in [src.name, src.code]:
            source = src
    return source
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= que tiene el nombre de una fuente válida en la propiedad =source=, devuelve un =str= con el nombre de la fuente
- Caso exitoso, cuando recibe un =Namespace= que tiene el código de una fuente válida en la propiedad =source=, devuelve un =str= con el nombre de la fuente
- Caso exitoso, cuando recibe un =Namespace= que tiene una fuente válida en la propiedad =podcast=, devuelve un =str= con el nombre de la fuente
- Caso exitoso, cuando recibe un =Namespace= que tiene una fuente válida en la propiedad =episode=, devuelve un =str= con el nombre de la fuente
- Cuando recibe un =Namespace= que no es un objeto =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =source=, lanza un =AssertionError=
- Cuando recibe un =Namespace= tiene una fuente desconocida en la propiedad =source=, lanza un =AssertionError=

#+begin_src python :tangle cli/arguments/tests/test_source_from_arguments.py
from cli.arguments import source_from_arguments
from cli.arguments.tests.examples_source_from_arguments import *

def test_arguments_with_valid_source_name():
    args = arguments_with_valid_source_name()
    source = source_from_arguments(args)
    assert source.name == "franceinter"

def test_arguments_with_valid_source_code():
    args = arguments_with_valid_source_code()
    source = source_from_arguments(args)
    assert source.name == "franceinter"

def test_arguments_with_valid_source_in_podcast():
    args = arguments_with_valid_source_in_podcast()
    source = source_from_arguments(args)
    assert source.name == "franceinter"

def test_arguments_with_valid_source_in_episode():
    args = arguments_with_valid_source_in_episode()
    source = source_from_arguments(args)
    assert source.name == "franceinter"

def test_invalid_arguments():
    args = invalid_arguments()
    try:
        source = source_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_without_source():
    args = arguments_without_source()
    try:
        source = source_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_with_unknown_source():
    args = arguments_with_unknown_source()
    try:
        source = source_from_arguments(args)
    except AssertionError:
        assert True
#+end_src

****** Run tests
**** podcast_from_arguments
***** 1. Objetivo

Obtener el identificador del podcast a partir de los argumentos recibidos

***** 2. Firma

La función recibe un objeto =argparse.Namespace= y devuelve un =str= con el identificador del podcast

***** 3. Ejemplos

- Caso exitoso, un =Namespace= que tiene solamente el identificador del podcast en la propiedad =podcast=
- Caso exitoso, un =Namespace= que tiene la fuente y el identificador del podcast en la propiedad =podcast=
- Caso exitoso, un =Namespace= que tiene el identificador del podcast en la propiedad =episode=
- Un =Namespace= que no es un objeto =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =podcast=

#+begin_src python :tangle cli/arguments/tests/examples_podcast_from_arguments.py
from argparse import Namespace

def arguments_with_podcast():
    args = Namespace()
    args.podcast = "la-france-aujourdhui"
    return args
    
def arguments_with_source_and_podcast():
    args = Namespace()
    args.podcast = "franceinter/la-france-aujourdhui"
    return args

def arguments_with_podcast_in_episode():
    args = Namespace()
    args.episode = "fri/la-france-aujourdhui/2018-08-21"
    return args

def invalid_arguments():
    return 42

def arguments_without_podcast():
    args = Namespace()
    args.source = "fri"
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def podcast_from_arguments(args):
    # validar que args sea un argparse.Namespace
    # verificar si hay un podcast en args.podcast
    # verificar si hay un podcast en args.episode
    return podcast
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/podcast_from_arguments.py
import re
from cli.arguments import argument_from_namespace

def podcast_from_arguments(args):
    podcast = False
    attr = argument_from_namespace(args, "podcast")
    if attr:
        podcast = podcast_from_attr(attr)
    episode = argument_from_namespace(args, "episode")
    if not podcast and episode:
        podcast = podcast_from_episode(episode)
    assert isinstance(podcast, str), missing_podcast(args)
    return podcast


def podcast_from_attr(attr):
    podcast = attr
    match = re.search("^([a-z0-9-]+)/([a-z0-9-]+)$", podcast)
    if match:
        podcast = match.groups()[1]
    return podcast

    
def podcast_from_episode(episode):
    podcast = False
    match = re.search("^([a-z0-9-]+)/([a-z0-9-]+)/([a-z0-9-]+)$", episode)
    if match:
        podcast = match.groups()[1]
    return podcast


def missing_podcast(args):
    return "arguments parameter must have a podcast property, received %s" % args
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= que tiene solamente el identificador del podcast en la propiedad =podcast=, devuelve un =str= con el identificador del podcast
- Caso exitoso, cuando recibe un =Namespace= que tiene la fuente y el identificador del podcast en la propiedad =podcast=, devuelve un =str= solamente con el identificador del podcast
- Caso exitoso, cuando recibe un =Namespace= que tiene el identificador del podcast en la propiedad =episode=, devuelve un =str= con el identificador del podcast
- Cuando recibe un =Namespace= que no es un objeto =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =podcast=, lanza un =AssertionError=

#+begin_src python :tangle cli/arguments/tests/test_podcast_from_arguments.py
from cli.arguments import podcast_from_arguments
from cli.arguments.tests.examples_podcast_from_arguments import *

def test_arguments_with_podcast():
    args = arguments_with_podcast()
    podcast = podcast_from_arguments(args)
    assert (podcast == "la-france-aujourdhui")

def test_arguments_with_source_and_podcast():
    args = arguments_with_source_and_podcast()
    podcast = podcast_from_arguments(args)
    assert (podcast == "la-france-aujourdhui")

def test_arguments_with_podcast_in_episode():
    args = arguments_with_podcast_in_episode()
    podcast = podcast_from_arguments(args)
    assert (podcast == "la-france-aujourdhui")

def test_invalid_arguments():
    args = invalid_arguments()
    try:
        podcast = podcast_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_without_podcast():
    args = arguments_without_podcast()
    try:
        podcast = podcast_from_arguments(args)
    except AssertionError:
        assert True
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/arguments/tests/test_podcast_from_arguments.py
#+end_src

**** episode_from_arguments
***** 1. Objetivo

Obtener el identificador del episodio a partir de los argumentos recibidos

***** 2. Firma

La función recibe un objeto =argparse.Namespace= y devuelve un =str= con el identificador del episodio

***** 3. Ejemplos

- Caso exitoso, un =Namespace= que tiene solamente el identificador del episodio en la propiedad =episode=
- Caso exitoso, un =Namespace= que tiene la fuente, el podcast y el identificador del episodio en la propiedad =episode=
- Un =Namespace= que no es un objeto =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =episode=

#+begin_src python :tangle cli/arguments/tests/examples_episode_from_arguments.py
from argparse import Namespace

def arguments_with_episode():
    args = Namespace()
    args.episode = "2018-03-13"
    return args

def arguments_with_source_podcast_episode():
    args = Namespace()
    args.episode = "franceinter/l-histoire-africaine/2018-03-13"
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_episode():
    args = Namespace()
    args.podcast = "l-histoire-africaine"
    return args

#+end_src

***** 4. Boceto

#+begin_src python
def episode_from_arguments(args):
    # validar que args sea un argparse.Namespace
    # verificar si hay un episodio en args.episode
    return episode
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/episode_from_arguments.py
import re
from cli.arguments import argument_from_namespace


def episode_from_arguments(args):
    episode = argument_from_namespace(args, "episode", is_required=True)
    match = re.search("^([a-z0-9-]+)/([a-z0-9-]+)/([a-z0-9-]+)$", episode)
    if match:
        episode = match.groups()[2]
    return episode
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= que tiene solamente el identificador del episodio en la propiedad =episode=, devuelve un =str= con el identificador del episodio
- Caso exitoso, cuando recibe un =Namespace= que tiene la fuente, el podcast y el identificador del episodio en la propiedad =episode=, devuelve un =str= con el identificador del episodio
- Cuando recibe un =Namespace= que no es un objeto =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =episode=, lanza un =AssertionError=

#+begin_src python :tangle cli/arguments/tests/test_episode_from_arguments.py
from cli.arguments import episode_from_arguments
from cli.arguments.tests.examples_episode_from_arguments import *

def test_arguments_with_episode():
    args = arguments_with_episode()
    episode = episode_from_arguments(args)
    assert (episode == "2018-03-13")

def test_arguments_with_source_podcast_episode():
    args = arguments_with_source_podcast_episode()
    episode = episode_from_arguments(args)
    assert (episode == "2018-03-13")

def test_invalid_arguments():
    args = invalid_arguments()
    try:
        episode = episode_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_without_episode():
    args = arguments_without_episode()
    try:
        episode = episode_from_arguments(args)
    except AssertionError:
        assert True
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/arguments/tests/test_episode_from_arguments.py
#+end_src

**** keyword_from_arguments
***** 1. Objetivo

Obtener la palabra buscada para filtrar los resultados a partir de los argumentos recibidos

***** 2. Firma

La función recibe un objeto =argparse.Namespace= y devuelve un =str= con la palabra buscada

***** 3. Ejemplos

- Caso exitoso, un =Namespace= que tiene la palabra buscada en la propiedad =keyword=
- Un =Namespace= que no es un objeto =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =keyword=
- Un =Namespace= que tiene un =str= vacío en la propiedad =keyword=

#+begin_src python :tangle cli/arguments/tests/examples_keyword_from_arguments.py
from argparse import Namespace

def arguments_with_keyword(keyword):
    args = Namespace()
    args.keyword = keyword
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_keyword():
    args = Namespace()
    args.podcast = "l-histoire-africaine"
    return args

#+end_src

***** 4. Boceto

#+begin_src python
def keyword_from_arguments(args):
    # validar que args sea un argparse.Namespace
    # verificar si hay un keyword en args.keyword
    # validar que el keyword no esté vacío
    return keyword
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/keyword_from_arguments.py
import re
from cli.arguments import argument_from_namespace


def keyword_from_arguments(args):
    keyword = False 
    attr = argument_from_namespace(args, "keyword")
    if attr:
        keyword = attr
    return keyword
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= que tiene la palabra buscada en la propiedad =keyword=, devuelve un =str= con esa palabra
- Cuando recibe un =Namespace= que no es un objeto =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =keyword=, devuelve =False=
- Cuando recibe un =Namespace= que tiene un =str= vacío en la propiedad =keyword=, lanza un =AssertionError=

#+begin_src python :tangle cli/arguments/tests/test_keyword_from_arguments.py
from cli.arguments import keyword_from_arguments
from cli.arguments.tests.examples_keyword_from_arguments import *

def test_arguments_with_keyword():
    args = arguments_with_keyword("theatre")
    keyword = keyword_from_arguments(args)
    assert (keyword == "theatre")

def test_invalid_arguments():
    args = invalid_arguments()
    try:
        keyword = keyword_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_without_keyword():
    args = arguments_without_keyword()
    keyword = keyword_from_arguments(args)
    assert (keyword == False)

def test_arguments_with_empty_keyword():
    args = arguments_with_keyword("")
    keyword = keyword_from_arguments(args)
    assert (keyword == False)
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/arguments/tests/test_keyword_from_arguments.py
#+end_src

**** year_from_arguments
***** 1. Objetivo

Obtener el año para filtrar los resultados desde los argumentos recibidos

Dado que son podcasts, vamos a considerar un año como válido cuando sea un =int= mayor a 1900. Podrían llegar a existir emisiones radiales de principios del siglo 20 que se publiquen como podcasts.

***** 2. Firma

La función recibe un =argparse.Namespace= y devuelve un =int= con el año

***** 3. Ejemplos

- Caso exitoso, un =Namespace= que tiene un año válido en la propiedad =year=
- Caso exitoso, un =Namespace= que tiene un año válido en la propiedad =month=
- Un =Namespace= que no es un objeto =argparse.Namespace=
- Un =Namespace= que no tiene las propiedades =year= y =month=
- Un =Namespace= que tiene un año menor a 1900 en la propiedad =year=
- Un =Namespace= que tiene un año menor a 1900 en la propiedad =month=
- Un =Namespace= que tiene valor que no se puede parsear como =int= en la propiedad =year=

#+begin_src python :tangle cli/arguments/tests/examples_year_from_arguments.py
from argparse import Namespace

def arguments_with_year(year):
    args = Namespace()
    args.year = year
    return args

def arguments_with_year_in_month(year):
    args = Namespace()
    args.month = str(year) + "-23"
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_year():
    args = Namespace()
    args.podcast = "l-histoire-africaine"
    return args

#+end_src

***** 4. Boceto

#+begin_src python
def year_from_arguments(args):
    # validar que args sea un argparse.Namespace
    # verificar si hay un año en args.year
    # verificar si hay un año en args.month en formato YYYY-MM
    # validar que el año sea mayor que 1900
    return year
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/year_from_arguments.py
import re
from cli.arguments import argument_from_namespace


def year_from_arguments(args):
    year = False
    attr = argument_from_namespace(args, "year")
    if attr:
        year = year_from_attribute(attr)
    month = argument_from_namespace(args, "month")
    if not year and month:
        year = year_from_month(month)
    if year:
        assert (year > 1900), invalid_year(args)
    return year


def invalid_year(args):
    return "year property must be an int > 1900, received %s" % args


def year_from_attribute(attr):
    year = False
    match = re.search("^([0-9]{4})$", str(attr))
    if match:
        year = int(match.groups()[0])
    return year


def year_from_month(month):
    year = False
    match = re.search("^([0-9]{4})-[0-9]{2}$", month)
    if match:
        year = int(match.groups()[0])
    return year
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= que tiene un año válido en la propiedad =year=, devuelve un =int= con el año
- Caso exitoso, cuando recibe un =Namespace= que tiene un año válido en la propiedad =month=, devuelve un =int= con el año
- Cuando recibe un =Namespace= que no es un objeto =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene las propiedades =year= ni =month=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene un año menor a 1900 en la propiedad =year=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene un año menor a 1900 en la propiedad =month=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene valor que no se puede parsear como =int= en la propiedad =year=, lanza un =AssertionError=

#+begin_src python :tangle cli/arguments/tests/test_year_from_arguments.py
from cli.arguments import year_from_arguments
from cli.arguments.tests.examples_year_from_arguments import *

def test_arguments_with_year():
    args = arguments_with_year(2018)
    year = year_from_arguments(args)
    assert (year == 2018)

def test_arguments_with_year_in_month():
    args = arguments_with_year_in_month(2018)
    year = year_from_arguments(args)
    assert (year == 2018)

def test_invalid_arguments():
    args = invalid_arguments()
    try:
        year = year_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_without_year():
    args = arguments_without_year()
    year = year_from_arguments(args)
    assert (year==False)

def test_invalid_year():
    args = arguments_with_year(1816)
    try:
        year = year_from_arguments(args)
    except AssertionError:
        assert True

def test_invalid_year_in_month():
    args = arguments_with_year_in_month(1816)
    try:
        year = year_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_with_alphabetic_year():
    args = arguments_with_year("twenty-two")
    year = year_from_arguments(args)
    assert (year == False)
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/arguments/tests/test_year_from_arguments.py
#+end_src

**** month_from_arguments
***** 1. Objetivo

Obtener el mes para filtrar los resultados desde los argumentos recibidos

***** 2. Firma

La función recibe un =argparse.Namespace= con un mes con el formato =YYYY-MM= en la propiedad =month= y devuelve un =tuple= de dos números enteros con el año y el mes

***** 3. Ejemplos

- Caso exitoso, un =Namespace= que tiene un mes válido en la propiedad =month=
- Un =Namespace= que no es un objeto =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =month=
- Un =Namespace= que tiene un mes igual a cero en la propiedad =month=
- Un =Namespace= que tiene un mes mayor a 12 en la propiedad =month=
- Un =Namespace= que tiene valor que no se puede parsear como =int= en la propiedad =month=

#+begin_src python :tangle cli/arguments/tests/examples_month_from_arguments.py
from argparse import Namespace

def arguments_with_month(month):
    args = Namespace()
    args.month = month
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_month():
    args = Namespace()
    args.podcast = "l-histoire-africaine"
    return args

#+end_src

***** 4. Boceto

#+begin_src python
def month_from_arguments(args):
    # validar que args sea un argparse.Namespace
    # verificar que exista la propiedad en args.month
    # verificar que haya un mes en args.month en formato YYYY-MM
    # validar que el mes sea un entero entre 1 y 12
    return month
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/arguments/month_from_arguments.py
import re
from cli.arguments import argument_from_namespace


def month_from_arguments(args):
    year = False
    month = False
    attr = argument_from_namespace(args, "month")
    if attr:
        (year, month) = month_from_attribute(attr)
    if year:
        assert (0 < month) and (month < 13), invalid_month(args.month)
    return (year, month)


def invalid_month(args):
    return "year property must be an int between 1 and 12, received %s" % args


def month_from_attribute(attr):
    year = False
    month = False
    match = re.search("^([0-9]{4})-([0-9]{2})$", str(attr))
    if match:
        year = int(match.groups()[0])
        month= int(match.groups()[1])
    return (year, month)
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= que tiene un mes válido en la propiedad =month=, devuelve una tupla de =int= con el año y el mes
- Cuando recibe un =Namespace= que no es un objeto =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =month=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene un mes igual a cero en la propiedad =month=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene un mes mayor a 12 en la propiedad =month=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene valor que no se puede parsear como =int= en la propiedad =month=, lanza un =AssertionError=

#+begin_src python :tangle cli/arguments/tests/test_month_from_arguments.py
from cli.arguments import month_from_arguments
from cli.arguments.tests.examples_month_from_arguments import *

def test_arguments_with_month():
    args = arguments_with_month("2018-03")
    (year, month) = month_from_arguments(args)
    assert (year == 2018)
    assert (month == 3)

def test_invalid_arguments():
    args = invalid_arguments()
    try:
        (year, month) = month_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_without_month():
    args = arguments_without_month()
    (year, month) = month_from_arguments(args)
    assert (year==False)
    assert (month==False)

def test_arguments_with_zero_month():
    args = arguments_with_month("2019-00")
    try:
        (year, month) = month_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_with_month_14():
    args = arguments_with_month("2013-14")
    try:
        (year, month) = month_from_arguments(args)
    except AssertionError:
        assert True

def test_arguments_with_alphabetic_month():
    args = arguments_with_month("twelve-oh-four")
    (year, month) = month_from_arguments(args)
    assert (year == False)
    assert (month == False)
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/arguments/tests/test_month_from_arguments.py
#+end_src

*** Commands

En este módulo hay solamente dos funciones, por un lado =known_commands= que tiene el listado de comandos válidos aceptados por la aplicación, y por el otro =handlers_from_commands= que devuelve el nombre de la función encargada de procesar cada comando.

**** =__init.py__=
***** Funciones

#+begin_src python :tangle cli/commands/__init__.py
from cli.commands.known_commands import known_commands
from cli.commands.handler_from_command import handler_from_command
#+end_src

***** Tests

#+begin_src python :tangle cli/commands/tests/__init__.py

#+end_src

**** known_commands
***** 1. Objetivo

Obtener el listado de comandos que acepta la aplicación

***** 2. Firma

La función no recibe argumentos y devuelve un =list= de =str=

***** 3. Ejemplos

Dado que la función no recibe argumentos, no es necesario confeccionar ejemplos

***** 4. Boceto

#+begin_src python
def known_commands():
    commands = []
    # agregar los comandos a la lista
    return commands
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/commands/known_commands.py
def known_commands():
    commands = [
        "list-sources", "list-podcasts", "list-episodes", 
        "show-podcast", "show-episode"
    ]
    return commands
#+end_src

***** 6. Casos de prueba

- Todos los comandos deben ser de tipo =str=

#+begin_src python :tangle cli/commands/tests/test_known_commands.py
from cli.commands import known_commands

def test_known_commands():
    commands = known_commands()
    assert (len(commands) == 5)
    for command in commands:
        assert isinstance(command, str)

#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/commands/tests/test_known_commands.py
#+end_src

**** handler_from_command
***** 1. Objetivo

Obtener la función que procesa un comando aceptado por la aplicación

***** 2. Firma

La función recibe un =str= con el nombre del comando y devuelve un =function= con la función que se encarga de procesarlo

***** 3. Ejemplos

- Caso exitoso, un comando conocido por la aplicación
- Un comando que no es un =str=
- Un comando desconocido

#+begin_src python :tangle cli/commands/tests/examples_handler_from_command.py
from cli.commands import known_commands
import random

def invalid_command():
    return 42

def unknown_command():
    command = "this-is-an-unknown-command"
    return command
#+end_src

***** 4. Boceto

#+begin_src python

def handler_from_command(command):
    # validar que command sea un str
    # validar que el comando sea conocido
    # devolver la función correspondiente
    return handler
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/commands/handler_from_command.py
from cli.commands import known_commands

def handler_from_command(command):
    assert isinstance(command, str)
    assert command in known_commands(), unknown_command(command)
    handler = handlers()[command]
    return handler

def unknown_command(command):
    return "unknown command: %s" % command

def handlers():
    from cli.output import (
        output_from_source_list,
        output_from_podcast_list,
        output_from_episode_list,
        output_from_podcast_details,
        output_from_episode_details
    )
    return {
        "list-sources": output_from_source_list, 
        "list-podcasts": output_from_podcast_list,
        "list-episodes": output_from_episode_list, 
        "show-podcast": output_from_podcast_details, 
        "show-episode": output_from_episode_details
    }
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un comando conocido por la aplicación, devuelve la =function= que devuelve su salida
- Cuando recibe un comando que no es un =str=, lanza un =AssertionError=
- Cuando recibe un comando desconocido, lanza un =AssertionError=

#+begin_src python :tangle cli/commands/tests/test_handler_from_command.py
from cli.commands import known_commands, handler_from_command
from cli.commands.tests.examples_handler_from_command import *

def test_known_command():
    for command in known_commands():
        handler = handler_from_command(command)
        assert callable(handler)

def test_invalid_command():
    command = invalid_command()
    try:
        handler = handler_from_command(command)
    except AssertionError:
        assert True

def test_unknown_command():
    command = unknown_command()
    try:
        handler = handler_from_command(command)
    except AssertionError:
        assert True
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/commands/tests/test_handler_from_command.py
#+end_src

*** Output

En este módulo están las funciones que generan la salida de los comandos aceptados por la aplicación. La función =output_from_command= es la que se encarga de determinar qué función ejecutar a partir del comando recibido. El resto de las funciones devuelven un =str= con la salida del comando correspondiente.

**** =__init.py__=
***** Funciones

#+begin_src python :tangle cli/output/__init__.py
from cli.output.output_from_command import output_from_command
from cli.output.output_from_non_unique_record import output_from_non_unique_record
from cli.output.output_from_source_list import output_from_source_list
from cli.output.output_from_podcast_list import output_from_podcast_list
from cli.output.output_from_podcast_details import output_from_podcast_details
from cli.output.output_from_episode_list import output_from_episode_list
from cli.output.output_from_episode_details import output_from_episode_details
#+end_src

***** Tests

#+begin_src python :tangle cli/output/tests/__init__.py

#+end_src

**** output_from_command
***** 1. Objetivo

Obtener la salida del comando recibido

***** 2. Firma

La función recibe un objeto =argparse.Namespace= que tiene la propiedad =command= y devuelve un =str= con la salida del comando recibido

***** 3. Ejemplos

- Caso exitoso, un =Namespace= con un comando conocido por la aplicación en la propiedad =command=
- Un objeto que no es un =argparse.Namespace=
- Un =Namespace= vacío
- Un =Namespace= con un comando desconocido

#+begin_src python :tangle cli/output/tests/examples_output_from_command.py
from argparse import Namespace


def arguments_with_command(command):
    args = Namespace()
    args.command = command
    return args


def invalid_arguments():
    args = 42
    return args


def empty_arguments():
    args = Namespace()
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def output_from_command(args):
    # Obtener el comando con command_from_arguments
    # Obtener el handler del comando con handler_from_command
    # Obtener la salida ejecutando el handler
    return output
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/output/output_from_command.py
from argparse import Namespace
from cli.arguments import command_from_arguments
from cli.commands import handler_from_command

def output_from_command(args):
    command = command_from_arguments(args)
    handler = handler_from_command(command)
    output = handler(args)
    return output 
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= con un comando conocido por la aplicación en la propiedad =command=, devuelve la salida de ese comando
- Cuando recibe un objeto que no es un =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= vacío, lanza un =AssertionError=
- Cuando recibe un =Namespace= con un comando desconocido, lanza un =AssertionError=

#+begin_src python :tangle cli/output/tests/test_output_from_command.py
from cli.output import output_from_command
from cli.output.tests.examples_output_from_command import *


def test_output_from_source_list():
    args = arguments_with_command("list-sources")
    output = output_from_command(args)
    assert "franceinter" in output
    assert "testing" in output


def test_invalid_arguments():
    args = invalid_arguments()
    try:
        output = output_from_command(args)
    except AssertionError:
        assert True


def test_emtpy_arguments():
    args = empty_arguments()
    try:
        output = output_from_command(args)
    except AssertionError:
        assert True


def test_arguments_with_unknown_command():
    args = arguments_with_command("download-file")
    try:
        output = output_from_command(args)
    except AssertionError:
        assert True
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/output/tests/test_output_from_command.py
#+end_src

**** output_from_source_list
***** 1. Objetivo

Obtener la salida del comando =source_list=

***** 2. Firma

La función recibe un objeto =argparse.Namespace= y devuelve un =str= con la salida de la función =sources.list_sources=

***** 3. Ejemplos

- Caso exitoso, un =Namespace= vacío
- Un objeto que no es un =argparse.Namespace=

#+begin_src python :tangle cli/output/tests/examples_output_from_source_list.py
from argparse import Namespace

def empty_arguments():
    args = Namespace()
    return args

def invalid_arguments():
    args = 42
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def output_from_source_list(args):
    # Validar que args sea un argparse.Namespace
    # Obtener las fuentes desde sources.list_sources
    # Formatear la salida
    return output
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/output/output_from_source_list.py
from argparse import Namespace
from sources import list_sources

def output_from_source_list(args):
    assert isinstance(args, Namespace), invalid_arguments(args)
    lines = map(line_from_source, list_sources())
    output = help_message() + "\n\n" + "\n".join(lines)
    return output

def invalid_arguments(args):
    return "arguments parameter must be an argparse.Namespace, received %s instead" % type(args)

def line_from_source(source):
    return "- %s [%s]" % (source.name, source.code)

def help_message():
    return "Podcast source list"
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= vacío devuelve un =str= con el listado de fuentes
- Cuando recibe un objeto que no es un =argparse.Namespace=, lanza un =AssertionError=

#+begin_src python :tangle cli/output/tests/test_output_from_source_list.py
import re
from sources import list_sources
from cli.output import output_from_source_list
from cli.output.tests.examples_output_from_source_list import *

def test_emtpy_arguments():
    args = empty_arguments()
    output = output_from_source_list(args)
    for source in list_sources():
        assert re.search(source.code, output)
        assert re.search(source.name, output)

def test_invalid_arguments():
    args = invalid_arguments()
    try:
        output = output_from_source_list(args)
    except AssertionError:
        assert True
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/output/tests/test_output_from_source_list.py
#+end_src

**** output_from_podcast_list
***** 1. Objetivo

Obtener la salida del comando =podcast_list=

***** 2. Firma

La función recibe un objeto =argparse.Namespace= que tiene que tener la propiedad =source= y devuelve un =str= con el listado de podcasts de esa fuente

***** 3. Ejemplos

- Caso exitoso, un =Namespace= con una fuente válida de podcasts en la propiedad =source=
- Caso exitoso, un =Namespace= con una fuente válida de podcasts en la propiedad =source= y una palabra clave para filtrar el listado en la propiedad =keyword=
- Un objeto que no es un =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =source=
- Un =Namespace= que tiene una fuente desconocida en la propiedad =source=

#+begin_src python :tangle cli/output/tests/examples_output_from_podcast_list.py
from argparse import Namespace

def arguments_with_valid_source():
    args = Namespace()
    args.source = "testing"
    return args

def arguments_with_source_and_keyword():
    args = Namespace()
    args.source = "testing"
    args.keyword = "monde"
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_source():
    args = Namespace()
    return args

def arguments_with_unknown_source():
    args = Namespace()
    args.source = "my-podcast"
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def output_from_podcast_list(args):
    # Obtener la fuente con source_from_arguments
    # Importar el módulo de la fuente
    # Obtener el listado de podcasts desde source.url
    # Si args tiene la propiedad keyword, 
    #    filtrar los podcasts por keyword
    # Formatear la salida del listado
    return output
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/output/output_from_podcast_list.py
from cli.arguments import source_from_arguments, keyword_from_arguments
from franceinter.podcasts import podcasts_from_url
from franceinter.podcasts import podcasts_with_keyword


def output_from_podcast_list(args):
    source = source_from_arguments(args)
    import_from_source(source)
    podcasts = podcasts_from_url(source.url)
    keyword = keyword_from_arguments(args)
    if keyword:
        podcasts = podcasts_with_keyword(podcasts, keyword)
    lines = map(line_from_podcast, podcasts)
    output = help_message(source) + "\n\n" + "\n".join(lines)
    return output


def import_from_source(source):
    return source.name
    #if source.name == "local":
    #    from franceinter.podcasts import podcasts_from_url
    #    from franceinter.podcasts import podcasts_with_keyword
    #else:
    #    __import__(source.name).podcasts.podcasts_from_url
    #    __import__(source.name).podcasts.podcasts_with_keyword


def line_from_podcast(podcast):
    return "- %s [%s]" % (podcast.identifier, podcast.author)


def help_message(source):
    return "Podcast list for source: %s" % source.name
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= con una fuente válida de podcasts en la propiedad =source=, devuelve un =str= con el listado de podcasts
- Caso exitoso, cuando recibe un =Namespace= con una fuente válida de podcasts en la propiedad =source= y una palabra clave para filtrar el listado en la propiedad =keyword=, devuelve un =str= con el listado de podcasts que tienen la palabra clave
- Cuando recibe un objeto que no es un =argparse.Namespace=, lanza un =AssertionError=
- Un =Namespace= que no tiene la propiedad =source=, lanza un =AssertionError=
- Un =Namespace= que tiene una fuente desconocida en la propiedad =source=, lanza un =AssertionError=

#+begin_src python :tangle cli/output/tests/test_output_from_podcast_list.py
import pytest, threading
from utils.http_server import LocalFolderHTTPServer as HTTPServer
from cli.output import output_from_podcast_list
from cli.output.tests.examples_output_from_podcast_list import *

def test_arguments_with_valid_source(http_server):
    args = arguments_with_valid_source()
    output = output_from_podcast_list(args)
    assert "mille-et-un-mondes" in output
    assert "40-jours-en-france" in output
    assert(len(output)>0)

def test_arguments_with_source_and_keyword(http_server):
    args = arguments_with_source_and_keyword()
    output = output_from_podcast_list(args)
    assert "mille-et-un-mondes" in output
    assert "1918-un-monde-en-revolutions" in output
    assert(len(output)>0)

def test_invalid_arguments():
    args = invalid_arguments()
    try:
        output = output_from_podcast_list(args)
    except AssertionError:
        assert True

def test_arguments_without_source():
    args = arguments_without_source()
    try:
        output = output_from_podcast_list(args)
    except AssertionError:
        assert True

def test_arguments_with_unknown_source():
    args = arguments_with_unknown_source()
    try:
        output = output_from_podcast_list(args)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/output/tests/test_output_from_podcast_list.py
#+end_src

**** output_from_podcast_details
***** 1. Objetivo

Obtener la salida del comando =podcast_details=

***** 2. Firma

La función recibe un =argparse.Namespace= que tiene que tener la propiedad =podcast= y devuelve un =str= con el detalle del podcast

En la propiedad =podcast= se recibe el identificador del podcast buscado. Si la búsqueda devuelve más de un resultado, se muestra el listado de podcasts encontrados.

***** 3. Ejemplos

- Caso exitoso, un =Namespace= con un podcast válido en la propiedad =podcast= en formato =source/podcast-identifier=
- Caso exitoso, un =Namespace= con un identificador de podcast válido en la propiedad =podcast= y la fuente en la propiedad =source=
- Un =Namespace= con un identificador de podcast que devuelva más de un resultado en la propiedad =podcast=
- Un objeto que no es un =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =podcast=
- Un =Namespace= que tiene un podcast desconocido en la propiedad =podcast=

#+begin_src python :tangle cli/output/tests/examples_output_from_podcast_details.py
from argparse import Namespace

def arguments_with_podcast(podcast):
    args = Namespace()
    args.podcast = podcast
    return args

def arguments_with_source_and_podcast(source, podcast):
    args = Namespace()
    args.source = source
    args.podcast = podcast
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_podcast():
    args = Namespace()
    return args

def arguments_with_unknown_podcast():
    args = Namespace()
    args.podcast = "testing/my-podcast"
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def output_from_podcast_details(args):
    # Obtener la fuente con source_from_arguments
    # Obtener el identificador del podcast con podcast_from_arguments
    # Importar el módulo de la fuente
    # Obtener el listado de podcasts desde source.url
    # Filtrando el listado por keyword con el identificador del podcast
    # Si el listado devuelve más de un resultado,
    #    Formatear el listado como - identificador [autor]
    # Sino
    #    Formatear el detalle podcast
    return output
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/output/output_from_podcast_details.py
from cli.output import output_from_non_unique_record
from cli.arguments import (
    source_from_arguments,
    podcast_from_arguments
)
from franceinter.podcasts import (
    podcasts_from_url,
    podcasts_with_keyword
)


def output_from_podcast_details(args):
    source = source_from_arguments(args)
    keyword = podcast_from_arguments(args)
    import_from_source(source)
    all_podcasts = podcasts_from_url(source.url)
    podcasts = list(podcasts_with_keyword(all_podcasts, keyword))
    output = output_from_non_unique_record(podcasts, keyword)
    if not output:
        podcast = podcasts[0]
        output = help_message(podcast) + podcast_details(podcast)
    return output


def import_from_source(source):
    return source.name
    #if source.name == "local":
    #    from franceinter.podcasts import podcasts_from_url
    #    from franceinter.podcasts import podcasts_with_keyword
    #else:
    #    __import__(source.name).podcasts.podcasts_from_url
    #    __import__(source.name).podcasts.podcasts_with_keyword


def help_message(podcast):
    return "Podcast details for: '%s'" % podcast.title


def podcast_details(podcast):
    return f'''

identifier: {podcast.identifier}
       URL: {podcast.url}
    author: {podcast.author}'''
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= con un podcast válido en la propiedad =podcast= en formato =source/podcast-identifier=, devuelve un =str= con el detalle del podcast
- Caso exitoso, cuando recibe un =Namespace= con un identificador de podcast válido en la propiedad =podcast= y la fuente en la propiedad =source=, devuelve un =str= con el detalle del podcast
- Cuando recibe un =Namespace= con un identificador en la propiedad =podcast= que devuelve más de un resultado, devuelve un =str= con el mensaje "multiple podcasts" y el listado de los podcasts encontrados
- Cuando recibe un objeto que no es un =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =podcast=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene un podcast desconocido en la propiedad =podcast=, devuelve un =str= con el mensaje "No podcast was found"

#+begin_src python :tangle cli/output/tests/test_output_from_podcast_details.py
import pytest, threading
from utils.http_server import LocalFolderHTTPServer as HTTPServer
from cli.output import output_from_podcast_details
from cli.output.tests.examples_output_from_podcast_details import *

def test_arguments_with_podcast(http_server):
    podcast = "testing/mille-et-un-mondes"
    args = arguments_with_podcast(podcast)
    output = output_from_podcast_details(args)
    assert "mille-et-un-mondes" in output


def test_arguments_with_source_and_podcast(http_server):
    source = "testing"
    podcast = "mille-et-un-mondes"
    args = arguments_with_source_and_podcast(source, podcast)
    output = output_from_podcast_details(args)
    assert "mille-et-un-mondes" in output


def test_output_with_multiple_podcasts(http_server):
    podcast = "testing/monde"
    args = arguments_with_podcast(podcast)
    output = output_from_podcast_details(args)
    assert "Found multiple records" in output


def test_invalid_arguments():
    args = invalid_arguments()
    try:
        output = output_from_podcast_details(args)
    except AssertionError:
        assert True

def test_arguments_without_podcast():
    args = arguments_without_podcast()
    try:
        output = output_from_podcast_details(args)
    except AssertionError:
        assert True

def test_output_with_unknown_podcast(http_server):
    args = arguments_with_unknown_podcast()
    output = output_from_podcast_details(args)
    assert "No record was found" in output


@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/output/tests/test_output_from_podcast_details.py
#+end_src

**** output_from_episode_list
***** 1. Objetivo

Obtener la salida del comando =episode-list=

***** 2. Firma

La función recibe un =argparse.Namespace= que tiene que tener la propiedad =podcast= y devuelve un =str= con el listado de sus episodios.

En la propiedad =podcast= debe estar el identificador del podcast buscado. Si al buscar los podcasts por el identificador se encuentra más de un resultado, la función devuelve el listado de los podcasts encontrados.

Opcionalmente, en el =Namespace= pueden venir las siguientes propiedades:

- =keyword= :: filtra el listado por palabra clave
- =year= :: filtra el listado por año
- =month= :: filtra el listado por mes

***** 3. Ejemplos

- Caso exitoso, un =Namespace= con un podcast válido en la propiedad =podcast= en formato =source/podcast-identifier=
- Caso exitoso, un =Namespace= con un identificador de podcast válido en la propiedad =podcast= y la fuente en la propiedad =source=
- Un =Namespace= con un identificador de podcast que devuelva más de un resultado en la propiedad =podcast=
- Un =Namespace= con el identificador en la propiedad =podcast= y la propiedad =keyword= para filtrar los episodios por palabra clave
- Un =Namespace= con el identificador en la propiedad =podcast= y la propiedad =year= para filtrar los episodios por año
- Un =Namespace= con el identificador en la propiedad =podcast= y la propiedad =month= para filtrar los episodios por mes
- Un objeto que no es un =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =podcast=
- Un =Namespace= que tiene un podcast desconocido en la propiedad =podcast=

#+begin_src python :tangle cli/output/tests/examples_output_from_episode_list.py
from argparse import Namespace

def arguments_with_podcast(podcast):
    args = Namespace()
    args.podcast = podcast
    return args

def arguments_with_podcast_and_source(podcast, source):
    args = Namespace()
    args.podcast = podcast
    args.source = source
    return args

def arguments_with_podcast_and_keyword(podcast, keyword):
    args = Namespace()
    args.podcast = podcast
    args.keyword = keyword
    return args

def arguments_with_podcast_and_year(podcast, year):
    args = Namespace()
    args.podcast = podcast
    args.year = year
    return args

def arguments_with_podcast_and_month(podcast, month):
    args = Namespace()
    args.podcast = podcast
    args.month = month
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_podcast():
    args = Namespace()
    return args

def arguments_with_unknown_podcast():
    args = Namespace()
    args.podcast = "testing/my-podcast"
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def output_from_episode_list(args):
    # Obtener la fuente con source_from_arguments
    # Obtener el identificador del podcast con podcast_from_arguments
    # Importar el módulo de la fuente
    # Obtener el listado de podcasts desde source.url
    # Filtrar el listado por keyword con el identificador del podcast
    # Si el listado devuelve más de un resultado,
    #    Mensaje de múltiples podcasts encontrados
    #    Formatear el listado como - identificador [autor]
    # Si el listado no devuelve ningún resultado,
    #    Formatear el mensaje de podcast no encontrado
    # Si el listado devuelve un único resultado,
    #    Obtener el listado de episodios desde podcast.url
    #    Aplicar el filtro por keyword
    #    Aplicar el filtro por año
    #    Aplicar el filtro por mes
    #    Formatear el listado como identificador [título]
    return output
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/output/output_from_episode_list.py
from calendar import month_name
from cli.output import output_from_non_unique_record
from cli.arguments import (
    source_from_arguments,
    podcast_from_arguments,
    keyword_from_arguments,
    year_from_arguments,
    month_from_arguments
)
from franceinter.podcasts import (
    podcasts_from_url,
    podcasts_with_keyword
)
from franceinter.episodes import (
    episodes_from_podcast,
    episodes_with_keyword,
    episodes_from_year,
    episodes_from_month
)


def output_from_episode_list(args):
    source = source_from_arguments(args)
    podcast_id = podcast_from_arguments(args)
    import_from_source(source)
    all_podcasts = podcasts_from_url(source.url)
    podcasts = list(podcasts_with_keyword(all_podcasts, podcast_id))
    output = output_from_non_unique_record(podcasts, podcast_id)
    if not output:
        podcast = podcasts[0]
        if (source.name == "testing"):
            podcast.url = podcast.url.replace(
                "https://www.franceinter.fr/", 
                "http://localhost:3000/"
            )
        all_episodes = episodes_from_podcast(podcast)
        episodes = filter_episodes(all_episodes, args)
        lines = list(map(line_from_episode, episodes))
        if (len(lines) == 0):
            output = help_message(podcast, args) + "\n\n" + "No episodes found"
        else:
            output = help_message(podcast, args) + "\n\n" + "\n".join(lines)
    return output


def filter_episodes(episodes, args):
    (keyword, year, month) = filters_from_arguments(args)
    if keyword:
        episodes = episodes_with_keyword(episodes, keyword)
    if year and not month:
        episodes = episodes_from_year(episodes, year)
    if year and month:
        episodes = episodes_from_month(episodes, year, month)
    return episodes
    

def filters_from_arguments(args):
    keyword = keyword_from_arguments(args)
    (year, month) = month_from_arguments(args)
    year = year_from_arguments(args)
    return (keyword, year, month)


def import_from_source(source):
    return source.name


def line_from_episode(episode):
    return "- %s: %s" % (episode.identifier, episode.title)


def help_message(podcast, args):
    message = "Episode list for podcast: %s" % podcast.title
    (keyword, year, month) = filters_from_arguments(args)
    if keyword:
        message+= "\nkeyword: %s" % keyword
    if year:
        message+= "\n   year: %s" % year
    if month:
        message+= "\n  month: %s" % month_name[month]
    return message
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= con un podcast válido en la propiedad =podcast= en formato =source/podcast-identifier=, devuelve un =str= con el listado de los episodios de ese podcast
- Caso exitoso, cuando recibe un =Namespace= con un identificador de podcast válido en la propiedad =podcast= y la fuente en la propiedad =source=, devuelve un =str= con el listado de los episodios de ese podcast
- Cuando recibe un =Namespace= con un identificador de podcast que devuelva más de un resultado en la propiedad =podcast=, devuelve un =str= con un mensaje "multiple podcasts" y el listado de podcasts encontrados
- Cuando recibe un =Namespace= con el identificador en la propiedad =podcast= y la propiedad =keyword= para filtrar los episodios por palabra clave, devuelve un =str= con el listado de los episodios que tienen esa palabra clave
- Cuando recibe un =Namespace= con el identificador en la propiedad =podcast= y la propiedad =year= para filtrar los episodios por año, devuelve un =str= con el listado de los episodios que son de ese año
- Cuando recibe un =Namespace= con el identificador en la propiedad =podcast= y la propiedad =month= para filtrar los episodios por mes, devuelve un =str= con el listado de los episodios que son de ese mes
- Cuando recibe un objeto que no es un =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =podcast=, lanza un =AssertionError=
- Cuando recibe =Namespace= que tiene un podcast desconocido en la propiedad =podcast=, devuelve un =str= con el mensaje "No podcast was found"

#+begin_src python :tangle cli/output/tests/test_output_from_episode_list.py
import pytest, threading
from utils.http_server import LocalFolderHTTPServer as HTTPServer
from cli.output import output_from_episode_list
from cli.output.tests.examples_output_from_episode_list import *


def test_arguments_with_podcast(http_server):
    podcast = "testing/3d-le-journal"
    args = arguments_with_podcast(podcast)
    output = output_from_episode_list(args)
    assert "2019-03-02" in output


def test_arguments_with_podcast_and_source(http_server):
    source = "testing"
    podcast = "3d-le-journal"
    args = arguments_with_podcast_and_source(podcast, source)
    output = output_from_episode_list(args)
    assert "2019-02-23" in output


def test_arguments_with_multiple_podcasts(http_server):
    podcast = "testing/monde"
    args = arguments_with_podcast(podcast)
    output = output_from_episode_list(args)
    assert "Found multiple records" in output


def test_arguments_with_podcast_and_keyword(http_server):
    podcast = "testing/3d-le-journal"
    keyword = "recherche"
    args = arguments_with_podcast_and_keyword(podcast, keyword)
    output = output_from_episode_list(args)
    assert "recherche de la longitude" in output


def test_arguments_with_podcast_and_year(http_server):
    podcast = "testing/3d-le-journal"
    year = "2019"
    args = arguments_with_podcast_and_year(podcast, year)
    output = output_from_episode_list(args)
    assert "2019-03-09" in output


def test_arguments_with_podcast_and_month(http_server):
    podcast = "testing/3d-le-journal"
    month = "2019-02"
    args = arguments_with_podcast_and_month(podcast, month)
    output = output_from_episode_list(args)
    assert "2019-02-23" in output


def test_invalid_arguments():
    args = invalid_arguments()
    try:
        output = output_from_episode_list(args)
    except AssertionError:
        assert True


def test_arguments_without_podcast():
    args = arguments_without_podcast()
    try:
        output = output_from_episode_list(args)
    except AssertionError:
        assert True


def test_arguments_with_unknown_podcast(http_server):
    args = arguments_with_unknown_podcast()
    output = output_from_episode_list(args)
    assert "No record was found" in output


def test_arguments_without_results(http_server):
    podcast = "testing/3d-le-journal"
    keyword = "this-string-will-not-be-found"
    args = arguments_with_podcast_and_keyword(podcast, keyword)
    output = output_from_episode_list(args)
    assert "No episodes found" in output


@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/output/tests/test_output_from_episode_list.py
#+end_src

**** output_from_episode_details
***** 1. Objetivo

Obtener la salida del comando =episode_details=

***** 2. Firma

La función recibe un =argparse.Namespace= que tiene que tener la propiedad =episode= y devuelve un =str= con el detalle del episodio

En la propiedad =episode= se recibe el identificador del podcast buscado. Si la búsqueda devuelve más de un resultado, se muestra el listado de episodios encontrados. Si la búsqueda no devuelve ningún resultado, se muestra el mensaje "No episode found".

***** 3. Ejemplos

- Caso exitoso, un =Namespace= con un podcast válido en la propiedad =episode= en formato =source/podcast-identifier/episode=
- Caso exitoso, un =Namespace= con un identificador de episodio en la propiedad =episode=, un identificador de podcast en la propiedad =podcast= y la fuente en la propiedad =source=
- Un =Namespace= con un identificador de episodio en la propiedad =episode= que devuelva más de un resultado
- Un objeto que no es un =argparse.Namespace=
- Un =Namespace= que no tiene la propiedad =episode=
- Un =Namespace= que no tiene la propiedad =podcast=
- Un =Namespace= que tiene un podcast desconocido en la propiedad =podcast=
- Un =Namespace= que tiene un episodio desconocido en la propiedad =episode=

#+begin_src python :tangle cli/output/tests/examples_output_from_episode_details.py
from argparse import Namespace

def arguments_with_episode(episode):
    args = Namespace()
    args.episode = episode
    return args

def arguments_with_source_podcast_episode(source, podcast, episode):
    args = Namespace()
    args.source = source
    args.podcast = podcast
    args.episode = episode
    return args

def invalid_arguments():
    args = 42
    return args

def arguments_without_podcast():
    args = Namespace()
    args.episode = "2019-03-09"
    return args

def arguments_without_episode():
    args = Namespace()
    args.podcast = "testing/3d-le-journal"
    return args

def arguments_with_unknown_podcast():
    args = Namespace()
    args.podcast = "testing/my-podcast"
    return args

def arguments_with_unknown_episode():
    args = Namespace()
    args.episode = "testing/3d-le-journal/unknown-episode"
    return args
#+end_src

***** 4. Boceto

#+begin_src python
def output_from_episode_details(args):
    # Obtener la fuente con source_from_arguments
    # Obtener el identificador del podcast con podcast_from_arguments
    # Obtener el identificador del episodio con episode_from_arguments
    # Importar el módulo de la fuente
    # Obtener el listado de podcasts desde source.url
    # Filtrando el listado por keyword con el identificador del podcast
    # Si el listado devuelve más de un resultado,
    #    Mensaje "multiple records found"
    # Si el listado devuelve solamente un resultado
    #    Mensaje "no record found"
    # Obtener el listado de episodios con episodes_from_url
    # Si el listado devuelve más de un resultado,
    #    Mensaje "multiple records found"
    # Si el listado devuelve solamente un resultado
    #    Mensaje "no record found"
    # Formatear el detalle del episodio
    return output
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/output/output_from_episode_details.py
from cli.output import output_from_non_unique_record
from cli.arguments import (
    source_from_arguments,
    podcast_from_arguments,
    episode_from_arguments
)
from franceinter.podcasts import (
    podcasts_from_url,
    podcasts_with_keyword
)
from franceinter.episodes import (
    episodes_from_podcast,
    episodes_with_keyword
)


def output_from_episode_details(args):
    source = source_from_arguments(args)
    podcast_id = podcast_from_arguments(args)
    import_from_source(source)
    all_podcasts = podcasts_from_url(source.url)
    podcasts = list(podcasts_with_keyword(all_podcasts, podcast_id))
    output = output_from_non_unique_record(podcasts, podcast_id)
    if not output:
        podcast = podcasts[0]
        if (source.name == "testing"):
            podcast.url = podcast.url.replace(
                "https://www.franceinter.fr/", 
                "http://localhost:3000/"
            )
        output = help_message(podcast) + podcast_details(podcast)
        episode_id = episode_from_arguments(args)
        all_episodes = episodes_from_podcast(podcast)
        episodes = list(episodes_with_keyword(all_episodes, episode_id))
        output = output_from_non_unique_record(episodes, episode_id)
        if not output:
            episode = episodes[0]
            output = help_message(episode) + episode_details(episode)
    return output


def import_from_source(source):
    return source.name
    #if source.name == "local":
    #    from franceinter.podcasts import podcasts_from_url
    #    from franceinter.podcasts import podcasts_with_keyword
    #else:
    #    __import__(source.name).podcasts.podcasts_from_url
    #    __import__(source.name).podcasts.podcasts_with_keyword


def help_message(episode):
    return "Episode details for: '%s'" % episode.title


def podcast_details(podcast):
    return f'''

identifier: {podcast.identifier}
       URL: {podcast.url}
    author: {podcast.author}'''


def episode_details(episode):
    return f'''

 date: {episode.date}
title: {episode.title}'''
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =Namespace= con un podcast válido en la propiedad =episode= en formato =source/podcast-identifier/episode=, devuelve un =str= con el detalle del episodio
- Caso exitoso, cuando recibe un =Namespace= con un identificador de episodio en la propiedad =episode=, un identificador de podcast en la propiedad =podcast= y la fuente en la propiedad =source=, devuelve un =str= con el detalle del episodio
- Cuando recibe un =Namespace= con un identificador de podcast en la propiedad =podcast= que devuelva más de un resultado, devuelve un =str= con el mensaje "Multiple records found"
- Cuando recibe un =Namespace= con un identificador de episodio en la propiedad =episode= que devuelva más de un resultado, devuelve un =str= con el mensaje "Multiple records found"
- Cuando recibe un objeto que no es un =argparse.Namespace=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que no tiene la propiedad =episode=, lanza un =AssertionError=
- Cuando recibe un =Namespace= que tiene un podcast desconocido en la propiedad =podcast=, devuelve un =str= con el mensaje "No records found"
- Cuando recibe un =Namespace= que tiene un episodio desconocido en la propiedad =episode=, devuelve un =str= con el mensaje "No records found"

#+begin_src python :tangle cli/output/tests/test_output_from_episode_details.py
import pytest, threading
from utils.http_server import LocalFolderHTTPServer as HTTPServer
from cli.output import output_from_episode_details
from cli.output.tests.examples_output_from_episode_details import *


def test_arguments_with_episode(http_server):
    episode = "testing/mille-et-un-mondes/2019-03-09"
    args = arguments_with_episode(episode)
    output = output_from_episode_details(args)
    assert "2019-03-09" in output


def test_arguments_with_source_podcast_episode(http_server):
    source = "testing"
    podcast = "mille-et-un-mondes"
    episode = "2019-03-09"
    args = arguments_with_source_podcast_episode(source, podcast, episode)
    output = output_from_episode_details(args)
    assert "2019-03-09" in output


def test_output_with_multiple_podcasts(http_server):
    episode = "testing/monde/2019-03-09"
    args = arguments_with_episode(episode)
    output = output_from_episode_details(args)
    assert "Found multiple records" in output


def test_output_with_multiple_episodes(http_server):
    episode = "testing/3d-le-journal/de"
    args = arguments_with_episode(episode)
    output = output_from_episode_details(args)
    assert "Found multiple records" in output


def test_invalid_arguments():
    args = invalid_arguments()
    try:
        output = output_from_episode_details(args)
    except AssertionError:
        assert True


def test_arguments_without_podcast():
    args = arguments_without_podcast()
    try:
        output = output_from_episode_details(args)
    except AssertionError:
        assert True


def test_arguments_without_episode():
    args = arguments_without_episode()
    try:
        output = output_from_episode_details(args)
    except AssertionError:
        assert True


def test_output_with_unknown_podcast(http_server):
    args = arguments_with_unknown_podcast()
    output = output_from_episode_details(args)
    assert "No record was found" in output


def test_output_with_unknown_episode(http_server):
    args = arguments_with_unknown_episode()
    output = output_from_episode_details(args)
    assert "No record was found" in output


@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/output/tests/test_output_from_episode_details.py
#+end_src

**** output_from_non_unique_record
***** 1. Objetivo

Obtener la salida de los comandos en los que se necesita un único registro (podcast o episodio) pero el resultado de la búsqueda devuelve múltiples registros (o ninguno).

***** 2. Firma

La función recibe un =list= y un =str= con el identificador buscado, y si el tamaño de la lista es distinto de 1, devuelve un =str= con el mensaje de error correspondiente. Si el tamaño de la lista es 1, devuelve =False=

Para =len(list) > 1= se devuelve el mensaje =Multiple records found with identifier: xxx=, y luego el listado de los registros.

Para =len(list) == 0= se devuelve el mensaje =No records found with identifier: xxx=

***** 3. Ejemplos

- Caso exitoso, un =list= con más de 1 registro y un =str= con el identificador buscado
- Caso exitoso, un =list= vacío y un =str= con el identificador buscado
- Un objeto que no es un =list= en el primer argumento
- Un objeto que no es un =str= en el segundo argumento
- Un =list= con un solo elemento y un =str= con el identificador buscado

#+begin_src python :tangle cli/output/tests/examples_output_from_non_unique_record.py
class Record:
    def __init__(self, title, identifier):
        self.title = title
        self.identifier = identifier


def list_with_more_than_one_record():
    records = []
    records.append(
        Record(title="3D, Le Journal", identifier="3d-le-journal")
    )
    records.append(
        Record(title="4D, Le Journal", identifier="4d-le-journal")
    )
    return records


def empty_list():
    records = []
    return records


def invalid_list():
    records = 42
    return records


def list_with_only_one_record():
    records = []
    records.append(
        Record(title="4D, Le Journal", identifier="4d-le-journal")
    )
    return records
#+end_src

***** 4. Boceto

#+begin_src python
def output_from_non_unique_record(records, identifier):
    # Validar que records sea un list
    # Validar que identifier sea un str
    # Si len(records) > 1
    #    Mensaje de múltiples registros encontrados
    #    Formatear el listado como - identificador [titulo]
    # Si el listado no devuelve ningún resultado,
    #    Formatear el mensaje de registro no encontrado
    return output
#+end_src

***** 5. Definición

#+begin_src python :tangle cli/output/output_from_non_unique_record.py
def output_from_non_unique_record(records, identifier):
    assert isinstance(records, list), invalid_records(records)
    assert isinstance(identifier, str), invalid_identifier(identifier)
    output = False
    if (len(records) > 1):
        lines = map(line_from_record, records)
        output = "Found multiple records with identifier '%s'" % identifier + "\n\n" + "\n".join(lines)
    elif (len(records) == 0):
        output = "No record was found with identifier '%s'" % identifier
    return output


def line_from_record(record):
    return "- %s [%s]" % (record.identifier, record.title)


def invalid_records(records):
    return "records parameter must be a list, %s received: %s" % (type(records), records)


def invalid_identifier(identifier):
    return "records parameter must be a str, %s received: %s" % (type(identifier), identifier)
#+end_src

***** 6. Casos de prueba

- Caso exitoso, cuando recibe un =list= con más de 1 registro y un =str= con el identificador buscado, devuelve un =str= que contiene el texto "Found multiple records"
- Caso exitoso, cuando recibe un =list= vacío y un =str= con el identificador buscado, devuelve un =str= que contiene el texto "No records were found"
- Cuando recibe un objeto que no es un =list= en el primer argumento, lanza un =AssertionError=
- Cuando recibe un objeto que no es un =str= en el segundo argumento, lanza un =AssertionError=
- Cuando recibe un =list= con un solo elemento y un =str= con el identificador buscado, devuelve =False=

#+begin_src python :tangle cli/output/tests/test_output_from_non_unique_record.py
from cli.output import output_from_non_unique_record
from cli.output.tests.examples_output_from_non_unique_record import *


def test_list_with_more_than_one_record():
    records = list_with_more_than_one_record()
    identifier = "3d-le-journal"
    output = output_from_non_unique_record(records, identifier)
    assert "Found multiple records" in output


def test_empty_list():
    records = empty_list()
    identifier = "3d-le-journal"
    output = output_from_non_unique_record(records, identifier)
    assert "No record was found" in output


def test_invalid_list():
    records = invalid_list()
    identifier = "3d-le-journal"
    try:
        output = output_from_non_unique_record(records, identifier)
    except AssertionError:
        assert True


def test_invalid_identifier():
    records = list_with_more_than_one_record()
    identifier = 1.93
    try:
        output = output_from_non_unique_record(records, identifier)
    except AssertionError:
        assert True


def test_list_with_only_one_record():
    records = list_with_only_one_record()
    identifier = "3d-le-journal"
    output = output_from_non_unique_record(records, identifier)
    assert (output == False)
#+end_src

****** Run tests

#+begin_src sh
pytest ./cli/output/tests/test_output_from_non_unique_record.py
#+end_src

* Herramientas
** Módulos
*** =__init.py__=

#+begin_src python :tangle utils/__init__.py

#+end_src

** LocalFolderHTTPServer

Para poder ejecutar los casos de prueba que realizan peticiones HTTP, necesitamos levantar un servidor HTTP desde una carpeta local.

https://stackoverflow.com/questions/39801718/how-to-run-a-http-server-which-serve-a-specific-path/46332163#46332163

#+begin_src python :tangle utils/http_server.py
import os
try:
    # python 2
    from SimpleHTTPServer import SimpleHTTPRequestHandler
    from BaseHTTPServer import HTTPServer as BaseHTTPServer
except ImportError:
    # python 3
    from http.server import HTTPServer as BaseHTTPServer, SimpleHTTPRequestHandler

class HTTPHandler(SimpleHTTPRequestHandler):
    """This handler uses server.base_path instead of always using os.getcwd()"""
    def translate_path(self, path):
        path = SimpleHTTPRequestHandler.translate_path(self, path)
        relpath = os.path.relpath(path, os.getcwd())
        fullpath = os.path.join(self.server.base_path, relpath)
        return fullpath

class LocalFolderHTTPServer(BaseHTTPServer):
    """The main server, you pass in base_path which is the path you want to serve requests from"""
    def __init__(self, base_path, server_address, RequestHandlerClass=HTTPHandler):
        self.base_path = base_path
        BaseHTTPServer.__init__(self, server_address, RequestHandlerClass)   
#+end_src

** HTML
*** =__init.py__=
**** Funciones

#+begin_src python :tangle utils/html/__init__.py
from utils.html.attribute_from_tag import attribute_from_tag
from utils.html.content_from_tag import content_from_tag
from utils.html.tags_from_html import tags_from_html
from utils.html.html_from_url import html_from_url
#+end_src

**** Tests

#+begin_src python :tangle utils/html/tests/__init__.py

#+end_src

*** attribute_from_tag
**** 1. Objetivo

Obtener el valor de un atributo de un tag HTML que tenga una clase determinada buscando en un fragmento de HTML.

**** 2. Firma

La función recibe cuatro argumentos:

- Un =str= con un fragmento de html
- Un =str= con el nombre del tag buscado
- Un =str= con el nombre de la clase del tag
- Un =str= con el nombre del atributo buscado

Y devuelve un =str= con el valor del atributo. Si no puede encontrar el atributo, devuelve =False=

**** 3. Ejemplos

- Caso exitoso, un fragmento de HTML que tiene el tag, la clase y el atributo buscados
- Un fragmento de HTML que no tiene el tag buscado
- Un fragmento de HTML que no tiene la clase buscada
- Un fragmento de HTML que no tiene el atributo buscado
- Un fragmento de HTML que no es un =str=
- Un nombre de tag que no es un =str=
- Un nombre de clase que no es un =str=
- Un nombre de atributo que no es un =str=

#+begin_src python :tangle utils/html/tests/examples_attribute_from_tag.py
def html_with_tag_class_attr(tag, cls, attr, value):
    html = f'''<{tag} class="{cls}" {attr}="{value}">
    </{tag}>'''
    return html
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup


def attribute_from_tag(html, tag, cls, attr):
    # validar que html sea un str
    # validar que tag sea un str
    # validar que cls sea un str
    # validar que attr sea un str
    # buscar el tag con la clase en el html
    # buscar el atributo dentro del tag
    # devolver el valor
#+end_src

**** 5. Definición

#+begin_src python :tangle utils/html/attribute_from_tag.py
from bs4 import BeautifulSoup


def attribute_from_tag(html, tag, cls, attr):
    assert isinstance(html, str), invalid_str("html", html)
    assert isinstance(tag, str), invalid_str("tag", tag)
    assert isinstance(cls, str), invalid_str("cls", cls)
    assert isinstance(attr, str), invalid_str("attr", attr)
    value = False
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.find(tag, class_=cls)
    if tag and attr in tag.attrs:
        value = tag.attrs[attr]
    return value


def invalid_str(param, html):
    return "%s parameter must be a str, received %s instead" % (param, str(type(html)))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, un fragmento de HTML que tiene el tag, la clase y el atributo buscados
- Un fragmento de HTML que no tiene el tag buscado
- Un fragmento de HTML que no tiene la clase buscada
- Un fragmento de HTML que no tiene el atributo buscado
- Un fragmento de HTML que no es un =str=
- Un nombre de tag que no es un =str=
- Un nombre de clase que no es un =str=
- Un nombre de atributo que no es un =str=

#+begin_src python :tangle utils/html/tests/test_attribute_from_tag.py
from utils.html import attribute_from_tag
from utils.html.tests.examples_attribute_from_tag import *

def test_html_with_tag_class_attr():
    tag = "div"
    cls = "sidebar-left"
    attr = "title"
    value = "News!"
    html = html_with_tag_class_attr(tag, cls, attr, value)
    title = attribute_from_tag(html, tag, cls, attr)
    assert title == value

def test_html_without_tag():
    tag = "div"
    cls = "sidebar-left"
    attr = "title"
    value = "News!"
    html = html_with_tag_class_attr(tag, cls, attr, value)
    title = attribute_from_tag(html, "span", cls, attr)
    assert title == False

def test_html_without_class():
    tag = "div"
    cls = "sidebar-left"
    attr = "title"
    value = "News!"
    html = html_with_tag_class_attr(tag, cls, attr, value)
    title = attribute_from_tag(html, tag, "sidebar-right", attr)
    assert title == False

def test_html_without_attr():
    tag = "div"
    cls = "sidebar-left"
    attr = "title"
    value = "News!"
    html = html_with_tag_class_attr(tag, cls, attr, value)
    title = attribute_from_tag(html, tag, cls, "text")
    assert title == False

def test_html_not_str():
    tag = "div"
    cls = "sidebar-left"
    attr = "title"
    value = "News!"
    html = html_with_tag_class_attr(tag, cls, attr, value)
    try:
        title = attribute_from_tag(42, tag, cls, attr)
    except AssertionError:
        assert True

def test_tag_not_str():
    tag = "div"
    cls = "sidebar-left"
    attr = "title"
    value = "News!"
    html = html_with_tag_class_attr(tag, cls, attr, value)
    try:
        title = attribute_from_tag(html, 42, cls, attr)
    except AssertionError:
        assert True

def test_class_not_str():
    tag = "div"
    cls = "sidebar-left"
    attr = "title"
    value = "News!"
    html = html_with_tag_class_attr(tag, cls, attr, value)
    try:
        title = attribute_from_tag(html, tag, 42, attr)
    except AssertionError:
        assert True

def test_attr_not_str():
    tag = "div"
    cls = "sidebar-left"
    attr = "title"
    value = "News!"
    html = html_with_tag_class_attr(tag, cls, attr, value)
    try:
        title = attribute_from_tag(html, tag, cls, 42)
    except AssertionError:
        assert True
#+end_src

***** Run tests

#+begin_src sh
pytest ./utils/html/tests/test_attribute_from_tag.py
#+end_src

*** content_from_tag
**** 1. Objetivo

Obtener el valor del contenido de un tag HTML que tenga una clase determinada buscando en un fragmento de HTML.

**** 2. Firma

La función recibe tres argumentos:

- Un =str= con un fragmento de html
- Un =str= con el nombre del tag buscado
- Un =str= con el nombre de la clase del tag

Y devuelve un =str= con el contenido. Si no puede encontrar el tag o la clase, devuelve =False=

**** 3. Ejemplos

- Caso exitoso, un fragmento de HTML que tiene el tag y la clase buscados
- Un fragmento de HTML que no tiene el tag buscado
- Un fragmento de HTML que no tiene la clase buscada
- Un fragmento de HTML que no es un =str=
- Un nombre de tag que no es un =str=
- Un nombre de clase que no es un =str=

#+begin_src python :tangle utils/html/tests/examples_content_from_tag.py
def html_with_tag_class_value(tag, cls, value):
    return f'''<{tag} class="{cls}">{value}</{tag}>'''
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup


def attribute_from_tag(html, tag, cls, attr):
    # validar que html sea un str
    # validar que tag sea un str
    # validar que cls sea un str
    # buscar el tag con la clase en el html
    # devolver el contenido del tag
#+end_src

**** 5. Definición

#+begin_src python :tangle utils/html/content_from_tag.py
from bs4 import BeautifulSoup


def content_from_tag(html, tag, cls):
    assert isinstance(html, str), invalid_str("html", html)
    assert isinstance(tag, str), invalid_str("tag", tag)
    assert isinstance(cls, str), invalid_str("cls", cls)
    value = False
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.find(tag, class_=cls)
    if tag:
        value = tag.string
    return value


def invalid_str(param, html):
    return "%s parameter must be a str, received %s instead" % (param, str(type(html)))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un fragmento de HTML que tiene el tag y la clase buscados, devuelve el contenido del tag
- Cuando recibe un fragmento de HTML que no tiene el tag buscado, devuelve =False=
- Cuando recibe un fragmento de HTML que no tiene la clase buscada, devuelve =False=
- Cuando recibe un fragmento de HTML que no es un =str=, lanza un =AssertionError=
- Cuando recibe un nombre de tag que no es un =str=, lanza un =AssertionError=
- Cuando recibe un nombre de clase que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle utils/html/tests/test_content_from_tag.py
from utils.html import content_from_tag
from utils.html.tests.examples_content_from_tag import *

def test_html_with_tag_class_value():
    tag = "div"
    cls = "sidebar-left"
    value = "News!"
    html = html_with_tag_class_value(tag, cls, value)
    title = content_from_tag(html, tag, cls)
    assert title == value

def test_html_without_tag():
    tag = "div"
    cls = "sidebar-left"
    value = "News!"
    html = html_with_tag_class_value(tag, cls, value)
    title = content_from_tag(html, "span", cls)
    assert title == False

def test_html_without_class():
    tag = "div"
    cls = "sidebar-left"
    value = "News!"
    html = html_with_tag_class_value(tag, cls, value)
    title = content_from_tag(html, tag, "sidebar-right")
    assert title == False

def test_html_not_str():
    tag = "div"
    cls = "sidebar-left"
    value = "News!"
    html = html_with_tag_class_value(tag, cls, value)
    try:
        title = content_from_tag(42, tag, cls)
    except AssertionError:
        assert True

def test_tag_not_str():
    tag = "div"
    cls = "sidebar-left"
    value = "News!"
    html = html_with_tag_class_value(tag, cls, value)
    try:
        title = content_from_tag(html, 42, cls)
    except AssertionError:
        assert True

def test_class_not_str():
    tag = "div"
    cls = "sidebar-left"
    value = "News!"
    html = html_with_tag_class_value(tag, cls, value)
    try:
        title = content_from_tag(html, tag, 42)
    except AssertionError:
        assert True
#+end_src

***** Run tests

#+begin_src sh
pytest ./utils/html/tests/test_content_from_tag.py
#+end_src

*** tags_from_html
**** 1. Objetivo

Obtener un array de =str= con los fragmentos de HTML que tengan un tag determinado y un a clase determinada.

**** 2. Firma

La función recibe tres =str=, uno con un fragmento de HTML, y dos con el tag y la clase buscados, y devuelve un =GeneratorType= de =str=

**** 3. Ejemplos

- Un html que tiene varios tags con la clase buscada
- Un html que no es un =str=
- Un tag que no es un =str=
- Una clase que no es un =str=
- Un html que no tiene ningún tag buscado
- Un html que tiene varios tags buscados pero que ninguno tenga la clase correcta
- Un html que tiene algunos tags con la clase buscada y otros que no la tienen

#+begin_src python :tangle utils/html/tests/examples_tags_from_html.py
def html_with_tags_and_class(tag, cls, how_many):
    tags = map(lambda x: tag_with_class(tag, cls), range(how_many))
    return html(tags)


def tag_with_class(tag, cls):
    return f'''<{tag} class="{cls}">this is the tag content</{tag}>'''


def html(tags):
    content = "".join(tags)
    html = f'''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
{content}
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    '''
    return html
#+end_src

**** 4. Boceto

#+begin_src python
def tags_from_html(html):
    # validar que el html sea un string
    # validar que el html sea un string
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # filtrar los tag <div> que tienen la clase "rich-section-list-item-content"
    return tags
#+end_src

**** 5. Definición

#+begin_src python :tangle utils/html/tags_from_html.py
from bs4 import BeautifulSoup


def tags_from_html(html, tag, cls):
    assert isinstance(html, str), invalid_parameter("html", html)
    assert isinstance(tag, str), invalid_parameter("tag", tag)
    assert isinstance(cls, str), invalid_parameter("cls", cls)
    soup = BeautifulSoup(html, "html.parser")
    tags = soup.find_all(tag, class_=cls)
    for tag in tags:
        yield str(tag)


def invalid_parameter(param, value):
    return "%s parameter must be a string, received %s instead" % (
        param, type(value)
    )
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un HTML que tiene varios tags con la clase buscada, devuelve un =GeneratorType= de =str= con los tags del HTML
- Cuando recibe un html que no es un =str=, lanza un =AssertionError=
- Cuando recibe un tag que no es un =str=, lanza un =AssertionError=
- Cuando recibe una clase que no es un =str=, lanza un =AssertionError=
- Cuando recibe un html que no tiene ningún tag buscado, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene varios tags buscados pero que ninguno tenga la clase correcta, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene algunos tags con la clase buscada y otros que no la tienen, devuelve un =GeneratorType= con los tags que tienen la clase buscada

#+begin_src python :tangle utils/html/tests/test_tags_from_html.py
import types
from utils.html import tags_from_html
from utils.html.tests.examples_tags_from_html import *


def test_html_with_tags():
    how_many = 5
    tag = "p"
    cls = "article"
    html = html_with_tags_and_class(tag, cls, how_many)
    tags = tags_from_html(html, tag, cls)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == how_many)


def test_html_is_not_string():
    how_many = 5
    tag = "p"
    cls = "article"
    html = 42
    try:
        tags = tags_from_html(html, tag, cls)
    except AssertionError:
        assert True


def test_tag_is_not_string():
    how_many = 5
    tag = "p"
    cls = "article"
    html = html_with_tags_and_class(tag, cls, how_many)
    try:
        tags = tags_from_html(html, 42, cls)
    except AssertionError:
        assert True


def test_class_is_not_string():
    how_many = 5
    tag = "p"
    cls = "article"
    html = html_with_tags_and_class(tag, cls, how_many)
    try:
        tags = tags_from_html(html, tag, 42)
    except AssertionError:
        assert True


def test_html_without_tags():
    how_many = 5
    tag = "p"
    cls = "article"
    html = html_with_tags_and_class(tag, cls, how_many)
    tags = tags_from_html(html, "header", cls)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)


def test_html_without_class():
    how_many = 5
    tag = "p"
    cls = "article"
    html = html_with_tags_and_class(tag, cls, how_many)
    tags = tags_from_html(html, tag, "title")
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)


def test_some_html_with_tags():
    html = html_with_tags_and_class("p", "article", 5)
    html += html_with_tags_and_class("p", "title", 12)
    tags = tags_from_html(html, "p", "title")
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 12)
#+end_src

***** Run tests

#+begin_src sh
pytest utils/html/tests/test_tags_from_html.py
#+end_src

*** html_from_url
**** 1. Objetivo

Obtener el HTML de un URL

**** 2. Firma

La función recibe un =str= con un URL válido y devuelve otro =str= con el HTML del URL

**** 3. Ejemplos

- Caso exitoso, un URL válido
- Un URL que no es un =str=
- Un URL inválido
- Un URL válido, pero que causa un =ConnectionError= porque el host no existe
- Un URL válido, pero de una página que no existe

#+begin_src python :tangle utils/html/tests/examples_html_from_url.py
def valid_url():
    url = "http://localhost:3000/episode-list.html"
    return url


def not_str_url():
    url = 1234
    return url


def invalid_url():
    url = "ghu:\\{this]url^is((not?valid.com"
    return url


def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url


def connection_error_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url
#+end_src

**** 4. Boceto

#+begin_src python
def html_from_url(url):
    # validar el URL
    # ejecutar la petición HTTP
    # si no hay error de conexión
    # devolver el texto de la respuesta
#+end_src

**** 5. Definición

#+begin_src python :tangle utils/html/html_from_url.py
import requests
from validators.url import url as is_valid_url


def html_from_url(url):
    assert isinstance(url, str), invalid_str(url)
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        return response.text
    except requests.ConnectionError:
        assert False, connection_error(url)

        
def invalid_str(url):
    return "url parameter must be string, received %s instead" % str(type(url))


def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url


def connection_error(url):
    return "request to %s failed with a connection error" % url
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un URL válido devuelve el HTML de la página
- Cuando recibe un URL que no es un =str=, lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=
- Cuando recibe un URL válido pero cuyo host no existe, lanza un =AssertionError=
- Cuando recibe un URL válido pero cuya página, devuelve un =str= vacío

#+begin_src python :tangle utils/html/tests/test_html_from_url.py
import os
import re
import pytest
import threading
from utils.html import html_from_url
from utils.html.tests.examples_html_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer


def test_url_ok(http_server):
    url = valid_url()
    html = html_from_url(url)
    assert isinstance(html, str)
    assert (len(html) > 0)


def test_not_str_url(http_server):
    url = not_str_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True


def test_invalid_url():
    url = invalid_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True


def test_not_found_url(http_server):
    url = not_found_url()
    html = html_from_url(url)
    assert re.search("NOT_FOUND", html)


@pytest.mark.skipif(os.environ.get('ENV') == 'DEV', reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = connection_error_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True


@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()
#+end_src

***** Run tests

#+begin_src sh
pytest utils/html/tests/test_html_from_url.py
#+end_src

* Tests
** Ejecutar los casos de prueba

#+begin_src sh
pytest
#+end_src

*** Variables de entorno

Hay tres pruebas unitarias que requieren esperar cerca de 10 segundos para que falle una petición DNS, y que mientras estamos trabajando en el entorno de desarrollo preferimos saltearlas para agilizar la mecánica de trabajo. Para ello usamos la variable de entorno ~ENV='DEV'~ que se verifica en los tests de conexión fallida.

#+begin_src sh
export ENV='DEV'
pytest
#+end_src

** Generar el reporte de cobertura

#+begin_src sh
pytest --cov-report html:coverage --cov ./franceinter/ --cov ./sources/ --cov ./cli/
#+end_src

Para visualizar el reporte se debe abrir el archivo =./coverage/index.html= con el navegador

#+begin_src sh
firefox --new-tab ./coverage/index.html
#+end_src

** Generar el reporte de complejidad ciclomática

Una herramienta interesante para analizar la complejidad del código es [[https://radon.readthedocs.io/en/latest/][Radon]]. 

- Documentación :: https://radon.readthedocs.io/en/latest/
- GitHub :: https://github.com/rubik/radon

Permite generar un reporte que le asigna a cada unidad de código (función, método o clase) una calificación que va de A (complejidad baja) hasta F (complejidad alta).

|----------+------+-----------------------------------------|
| CC score | Rank | Risk                                    |
|----------+------+-----------------------------------------|
| 1 - 5    | A    | low - simple block                      |
| 6 - 10   | B    | low - well structured and stable block  |
| 11 - 20  | C    | moderate - slightly complex block       |
| 21 - 30  | D    | more than moderate - more complex block |
| 31 - 40  | E    | high - complex block, alarming          |
| 41+      | F    | very high - error-prone, unstable block |
|----------+------+-----------------------------------------|

Podríamos incorporar el análisis de complejidad al procedimiento de integración continua (cuando haya):

- Se crea un issue de rediseño para cada función cuya calificación sea C
- Se falla el build si se encuentran funciones con calificación D o mayor
- Se rechaza un pull request si tiene funciones con calificación D o mayor

*** Reporte de complejidad ciclomática

Es interesante obtener el reporte para revisar las funciones complejas y ver si es posible simplificarlas o refactorizar parte de esa complejidad en nuevas funciones.

De todas maneras, el reporte de Radon nos da una muy buena calificación, dado que todas las funciones tuvieron una calificación A (bloque simple), excepto por las siguientes 12 funciones, que tuvieron B (bloque estable y bien estructurado)

#+begin_src sh :eval never
$ pip install radon

$ radon cc --min B ./cli/ ./franceinter/ ./sources/ ./utils/
cli/arguments/source_from_arguments.py
    F 5:0 source_from_arguments - B
cli/arguments/year_from_arguments.py
    F 4:0 year_from_arguments - B
cli/arguments/podcast_from_arguments.py
    F 4:0 podcast_from_arguments - B
cli/arguments/parser_from_tuples.py
    F 3:0 parser_from_tuples - B
franceinter/episodes/url_from_tag.py
    F 3:0 url_from_tag - B
franceinter/episodes/episodes_from_day.py
    F 3:0 episodes_from_day - B
franceinter/episodes/title_from_tag.py
    F 3:0 title_from_tag - B
franceinter/episodes/episode_from_tag.py
    F 12:0 episode_from_tag - B
franceinter/episodes/date_from_tag.py
    F 5:0 date_from_tag - B
franceinter/episodes/duration_from_tag.py
    F 3:0 duration_from_tag - B
franceinter/podcasts/tests/test_podcast_from_tag.py
    F 4:0 test_podcast_ok - B
sources/tests/test_list_sources.py
    F 4:0 test_sources_ok - B
#+end_src

** TODO Integración continua

- Evaluar [[https://travis-ci.com/plans][Travis CI]]
- Evaluar [[https://circleci.com/open-source/][Circle CI]]
- Evaluar [[https://azure.microsoft.com/en-us/services/devops/pipelines/][Azure Pipelines]]
- Evaluar [[https://jenkins.io/][Jenkins]] para limitar la dependencia de servicios externos

Lo ideal sería tener un único proceso de generación de build + testing que se pueda utilizar en cualquiera de las soluciones de integración continua.

* Licencia

Voy a usar la licencia GPLv3 porque me interesa que los trabajos derivados de este proyecto, si los hubiera, se compartan con la comunidad.

** GPLv3

#+begin_src text :tangle LICENSE
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.   
#+end_src

* Apéndices
** Prueba de concepto: Podcast ID
   :PROPERTIES:
   :CUSTOM_ID: podcast-id-poc
   :END:

Realizamos una prueba de concepto para determinar si se puede utilizar la frecuencia de las palabras que componen el título y el autor para asignarle un identificador único a cada podcast que no sea un código difícil de recordar.

Encontramos que, de los 973 podcasts de France Inter hay solamente 655 que tienen una palabra única en su título o autor que se pueda utilizar como identificador. Esto significa que no tendríamos un identificador único para los 318 podcasts restantes, por lo que *este método no nos sirve*.

Ejemplos de podcasts con identificadores repetidos:

#+begin_src text
Dans la playlist de France Inter - 
id: playlist (4)


Festival de Radio France  - Sylvie Chapelle
id: radio (8)


France Inter : 50 ans de science - Mathieu Vidard
id: science (4)


France Inter avec et pour les femmes - Stéphanie Duncan
id: femmes (4)
#+end_src

#+begin_src python
import re
import itertools
import requests
import requests_cache
from unidecode import unidecode
from franceinter.podcasts import (
    podcasts_from_url, 
    podcasts_with_keyword
)

requests_cache.install_cache()

def all_podcasts():
    url = "https://www.franceinter.fr/emissions/"
    podcasts = podcasts_from_url(url)
    return podcasts

def podcast_words(podcast):
    words = re.split('\W+', podcast.title)
    words+= re.split('\W+', podcast.author)
    words = list(set(words))
    words = map(lambda w: unidecode(w.lower()), words)
    words = filter(lambda w: len(w)>0, words)
    return list(words)

def word_frequencies():
    freq = {}
    podcasts = all_podcasts()
    for podcast in podcasts:
        words = podcast_words(podcast)
        for word in words:
            if word not in freq:
                freq[word]=0
            freq[word]+=1
    return freq

def identifier(freqs, podcast):
    words = podcast_words(podcast)
    identifier = words[0]
    for word in words:
        if freqs[word] <= freqs[identifier]:
            identifier = word
    return identifier

def podcasts_with_unique_id(podcasts):
    frequencies = word_frequencies()
    podcasts_with_id = map(lambda p: [p, identifier(frequencies, p)], podcasts)
    uniques = filter(lambda item: frequencies[item[1]]==1, podcasts_with_id)
    return map(lambda p: p[0], uniques)

def podcasts_with_duplicate_id(podcasts):
    frequencies = word_frequencies()
    podcasts_with_id = map(lambda p: [p, identifier(frequencies, p)], podcasts)
    duplicates = filter(lambda item: frequencies[item[1]]>1, podcasts_with_id)
    return map(lambda p: p[0], duplicates)

def unique_stats():
    frequencies = word_frequencies()
    unique_podcasts = podcasts_with_unique_id(all_podcasts())
    print ("Unique ID: " + str(len(list(unique_podcasts))))
    print ("Total: " + str(len(list(all_podcasts()))))

def print_identifier(podcasts):
    frequencies = word_frequencies()
    for podcast in podcasts:
        print("%s - %s" % (podcast.title, podcast.author))
        podcast_id = identifier(frequencies, podcast)
        print("id: %s (%s)" % (podcast_id, frequencies[podcast_id]))
        print("\n")

def podcast_slice(keyword, how_many):
    podcasts_keyword = podcasts_with_keyword(all_podcasts(), keyword)
    podcast_slice = itertools.islice(podcasts_keyword, how_many)
    return podcast_slice

def unique_podcasts(keyword, how_many):
    podcasts = podcast_slice(keyword, how_many)
    return podcasts_with_unique_id(podcasts)
    
def duplicated_podcasts(keyword, how_many):
    podcasts = podcast_slice(keyword, how_many)
    return podcasts_with_duplicate_id(podcasts)
    

#unique_stats()
#podcasts = unique_podcasts("cheissoux", 200)
#podcasts = podcast_slice("cheissoux", 200)
podcasts = duplicated_podcasts("france", 15)
print_identifier(podcasts)

#+end_src

** Implementación de referencia

#+begin_src python :python python-3.6 :results output
from bs4 import BeautifulSoup
from urllib.request import urlopen
import re

def slugify(string):
    return re.sub(r'[-\s]+', '-',
                  (re.sub(r'[^\w\s-]', '',string).strip().lower()))

def linkToDate(link):
    date = ""
    rd = re.search("([0-9]{2})-([a-z]+)-([0-9]{4})$", link)
    if rd:
        date = rd.group(3) + "-" + monthNumber(rd.group(2)) + "-" + rd.group(1)
    return date
        
def monthNumber(month):
    return {
        'janvier': "01",
        'fevrier': "02",
        'mars': "03",
        'avril': "04",
        'mai': "05",
        'juin': "06",
        'juillet': "07",
        'aout': "08",
        'septembre': "09",
        'octobre': "10",
        'novembre': "11",
        'decembre': "12"
    }[month]

    
r = urlopen('https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin?p=2').read()
soup = BeautifulSoup(r, "html.parser")
#print(soup.prettify())
buttons = soup.find_all("button", class_="replay-button")

for button in buttons:
    if "data-url" in button.attrs:
        #print(button.attrs)
        link = button.attrs["data-diffusion-path"]
        date = linkToDate(link)
        filename = date + "-" + slugify(button.attrs["data-diffusion-title"]) + ".mp3"
        #print(filename)
        print("curl -o " + filename + " " + button.attrs["data-url"])
        #print("")

#+end_src

#+RESULTS:
:results:
:end:

** Historial de mejoras y correcciones
*** France Inter
**** Podcasts

- [X] =podcasts_from_query= :: Analizar el cambio de nombre por =podcasts_matching_query=, que expresa mejor que la función es un filtro de podcasts usando una palabra clave. Pensándolo bien, el nombre de que mejor expresa lo que hace la función es =podcasts_with_keyword= ([[https://github.com/martinalsinet/podcast-db/commit/4bea0e6d3d091c132ca9cf58985a7bbaafbb6c55][4bea0e6]])

- [X] =podcasts_with_keyword= :: Agregar que no distinga entre los caracteres acentuados (á vs a) al buscar. Por ejemplo, si la palabra buscada es =té= debería devolver los podcasts que contengan tanto =té= como =te= ([[https://github.com/martinalsinet/podcast-db/commit/a907f390b9df9d69622f1f4be6c5831e12407808][a907f39]])

- [X] =identifier= :: Agregar un método =identifier()= a la clase Podcast que devuelva la parte única del URL. Modificar la función =podcasts-with-keyword= para que también busque la palabra clave en el identificador. ([[https://github.com/martinalsinet/podcast-db/commit/d5edc9fb3e965a5ad6eec570f4db40432f8d73c0][d5edc9f]])

- [X] Corregir los imports :: Declarar las funciones que se exportan en cada módulo dentro del archivo =__init.py__= ([[https://github.com/martinalsinet/podcast-db/commit/8b0f1321e3773f24bc5c8b97ac55692047411540][8b0f132]])

**** Episodes

- [X] =Episode.date= :: Cambiar el tipo de dato de la fecha del episodio =Episode.date= para que sea un =datetime.date= ([[https://github.com/martinalsinet/podcast-db/commit/3a2904b07b6eb6808116267f0a2180d09fab294c][3a2904b]])

- [X] =episodes_with_keyword= :: Agregar que no distinga entre los caracteres acentuados (á vs a) al buscar. Por ejemplo, si la palabra buscada es =té= debería devolver los podcasts que contengan tanto =té= como =te= ([[https://github.com/martinalsinet/podcast-db/commit/a907f390b9df9d69622f1f4be6c5831e12407808][a907f39]])

- [X] =identifier= :: Agregar un método =identifier()= a la clase Episode que devuelva la fecha de publicación del episodio en formato =YYYY-MM-DD=. Modificar la función =episodes-with-keyword= para que también busque la palabra clave en el identificador. ([[https://github.com/martinalsinet/podcast-db/commit/36597bd5fb9e2d7f7c442096fef5bf1249e2ce13][36597bd]])

- [X] Corregir los imports :: Declarar las funciones que se exportan en cada módulo dentro del archivo =__init.py__= ([[https://github.com/martinalsinet/podcast-db/commit/fdfc35b2619f997ad0d5a32fe7862ac1c82bcb30][fdfc35b]])

- [X] Tests condicionales :: Estamos ignorando los tests de fallas en la conexión de red porque tardan más de 10 segundos en dar timeout. Hay que usar =@pytest.mark.skipif= para agregar una variable de entorno que permita saltearlos en desarrollo. Ver [[https://stackoverflow.com/questions/22603562/how-to-check-a-member-variable-with-py-test-skipif][esta pregunta]] de StackOverflow que tiene un ejemplo similar. ([[https://github.com/martinalsinet/podcast-db/commit/f7936dd7e59f6f75b4cbd73849709ef397fc2e9b][f7936dd]])

- [X] URL inválido en episodios :: Revisar el listado de episodios de "Sur les épaules de Darwin" porque está dando URL inválido para un episodio de 2011. Aparentemente el error es porque el URL tiene un espacio (=.../carrefour (2).mp3=). ([[https://github.com/martinalsinet/podcast-db/commit/17cbd03469ecd17747f8a331084a8b908dfe8ab3][17cbd03]])

#+begin_src txt
AssertionError: received tag has an invalid episode URL
 <button class="replay-button playable" data-clip-type="reecoute" data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-25-juin-2011" data-diffusion-title='"Entendre leurs voix" avec Florence Aubenas' data-diffusion-uuid="136e81f2-a7b2-11e0-b8ee-842b2b72cd1d" data-duration="54 min" data-duration-seconds="3241" data-emission-business-reference="16177" data-emission-title="Sur les épaules de Darwin" data-emission-uuid="6f540125-eb9f-11e1-a7b7-782bcb76618d" data-end-time="1551032275" data-extract-id="" data-extract-title="" data-is-aod="1" data-next-media-info="/get_next_audio/136e81f2-a7b2-11e0-b8ee-842b2b72cd1d" data-start-time="1551029034" data-theme="" data-theme-uuid="" data-url="https://s3-eu-west-1.amazonaws.com/cruiser-production/static/inter/sons/2011/07/s27/carrefour (2).mp3" data-uuid="0962e356-a7b2-11e0-b8ee-842b2b72cd1d" data-xiti-action="C" data-xiti-id="0962e356" data-xiti-level="4" data-xiti-libelle='Reecouter::Sur les épaules de Darwin-"Entendre leurs voix" avec Florence Aubenas-0962e356' data-xiti-trackable="true" data-xiti-type="A" title='réecouter "Entendre leurs voix" avec Florence Aubenas'><svg class="icon replay-button-icon icon-play-player"><use xlink:href="#icon_player-play" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-pause-player"><use xlink:href="#icon_player-pause" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-play"><use xlink:href="#icon_play" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-pause"><use xlink:href="#icon_pause" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-play-disabled"><use xlink:href="#icon_playdisabled" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-direct-audio"><use xlink:href="#icon_direct-audio" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg></button>
#+end_src

- [X] Refactor :: Refactor de =episodes_from_year=, =episodes_from_month= y =episodes_from_day= para que usen =episodes_between_dates= ([[https://github.com/martinalsinet/podcast-db/commit/e547e44753d5f4fc3a89646ab41cccff0196dec3][f4dacab]], [[https://github.com/martinalsinet/podcast-db/commit/8f4d980ea26990e66d30d2559c434390b42d0d5b][8f4d980]], [[https://github.com/martinalsinet/podcast-db/commit/e547e44753d5f4fc3a89646ab41cccff0196dec3][e547e44]])

- [X] =attribute_from_tag= :: Crear una nueva función =attribute_from_tag= para extraer un atributo de un tag con una clase determinada

Luego de la implementación de varias funciones vemos que hay un patrón de código que se repite: Se busca un tag HTML con una clase determinada, y de ese tag se extrae un atributo específico. Podemos ver ejemplos de este patrón en las funciones =title_from_tag=, =url_from_tag= y =author_from_tag= del módulo podcasts y otros tantos en las funciones de este módulo que extraen los atributos del episodio (p.ej. =title_from_tag=). Quizás sea necesario crear un nuevo módulo /Tags/ que contenga la lógica que se encarga de extraer datos de los tags HTML.

Una ventaja adicional de crear un nuevo módulo para manipular los tags es que podemos encapsular el uso de la biblioteca =BeautifulSoup=, y eso nos haría más sencillo el poder reemplazarla llegado el caso. Idealmente, no deberíamos hacer referencia a los objetos o clases de =BeautifulSoup= (p.ej. =bs4.elements.Tag=) en el resto de la aplicación. ([[https://github.com/martinalsinet/podcast-db/commit/2d1cd88d02256b114c61bbe923571ddc149434c9][2d1cd88]])

*** France Culture

- [X] Reemplazar la función =title_from_tag= :: Vemos que las funciones =title_from_tag=, =author_from_tag= y =description_from_tag= se pueden reemplazar por un llamado a =utils.html.content_from_tag==, dado que lo único que hacen es extraer el contenido de un tag con una clase en particular. ([[https://github.com/martinalsinet/podcast-db/commit/d69434e39ece9bfe91b1e0fa113b2a85621aa5d0][d69434e]])

*** CLI

- [X] Corregir los imports :: Declarar las funciones que se exportan en cada módulo dentro del archivo =__init.py__= ([[https://github.com/martinalsinet/podcast-db/commit/d79cf61f6cdaf127c3969c0a73b4880206f9a854][d79cf61]])

- [X] =assert False= en tests :: Hay que agregar un =assert False= casos de prueba que esperan una excepción para asegurarse de que realmente esté saliendo por el camino de la excepción. *Update:* Luego de pensarlo un rato, recordé que quité los =assert False= porque cuando el test es exitoso nunca se llegan a ejecutar esos asserts dado que siempre sale por la excepción, y entonces aparecen como líneas no ejecutadas en el reporte de cobertura.

- [X] =argument_tuples= :: Cambiarle el nombre a =known_arguments= porque la palabra /tuples/ indica un detalle de implementación que distrae en vez de aclarar las cosas. ([[https://github.com/martinalsinet/podcast-db/commit/72f19213dc7a40b8d39d7ac3bdca87af4dcfd728][72f1921]])

- [X] =argument_from_namespace= :: Encontramos un patrón de código que se repite en las funciones del módulo =cli.arguments=. Todas las funciones reciben un objeto =argparse.Namespace=, verifican su tipo y extraen de éste uno o más argumentos que pueden ser obligatorios u opcionales. Hay que agregar una nueva función que implemente esas verificaciones. ([[https://github.com/martinalsinet/podcast-db/commit/50dc9b166b5f68f89bec987c9c2b064d634226a6][50dc9b1]])

- [X] Búsqueda de podcast o episodio :: Dentro del módulo =cli.output= están las funciones que muestran el detalle de un podcast o episodio. Estas funciones reciben el identificador del registro buscado, y puede suceder que cuando se realice la búsqueda se encuentre más de un resultado (o ninguno). En ese caso es necesario mostrar un mensaje de error ("Multiple/No records found"). Hay que crear una función =output_from_non_unique_record= que reciba un listado de resultados y devuelva un =str= con el mensaje correspondiente. ([[https://github.com/martinalsinet/podcast-db/commit/19f31e63e33fd547c9c8a473aa18567f4b232cca][19f31e6]])

- [X] Argumentos opcionales --year y --month :: Actualmente las funciones =year_from_arguments= y =month_from_arguments= lanzan un =AssertionError= si no existe la propiedad =year= y =month= respectivamente. Esto obliga a preguntar si existe el atributo antes de usarlas, para no disparar la excepción, lo cual complica el código innecesariamente. Hay que modificar estas funciones para que devuelvan =False= si la propiedad necesaria no está presente en los argumentos. ([[https://github.com/martinalsinet/podcast-db/commit/25eb9145ed938d2702813b01ad45bed89e3294bc][25eb914]])

- [X] Cobertura de tests en cli.arguments :: Luego de los cambios que se hicieron en las funciones =year_from_arguments= y =month_from_arguments= hay que actualizar algunos tests que antes esperaban una excepción y ahora reciben un =False= ([[https://github.com/martinalsinet/podcast-db/commit/e2f978029da3ccee9c939af81648cdee3330d553][e2f9780]])

