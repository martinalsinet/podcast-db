#+TITLE: Podcast Database
#+AUTHOR: Martín Alsinet
#+DATE: 2019
#+OPTIONS: ^:nil num:nil ':t
#+LANGUAGE: es
#+PROPERTY: header-args:python :python python-3.6 :results output drawer :mkdirp yes
#+PROPERTY: header-args:sh :results raw drawer
#+TODO: TODO DOING | DONE

* Indice                                                                :TOC:
- [[#motivación][Motivación]]
  - [[#literate-programming][Literate Programming]]
  - [[#how-to-design-programs][How to Design Programs]]
- [[#diseño][Diseño]]
  - [[#fuentes-de-podcasts][Fuentes de podcasts]]
  - [[#funcionalidades][Funcionalidades]]
- [[#versionado][Versionado]]
  - [[#changelog][ChangeLog]]
  - [[#roadmap][Roadmap]]
- [[#setup][Setup]]
  - [[#dependencias][Dependencias]]
  - [[#requirementstxt][requirements.txt]]
  - [[#instalar-las-dependencias][Instalar las dependencias]]
  - [[#generar-el-ejecutable][Generar el ejecutable]]
  - [[#gitignore][.gitignore]]
- [[#interface-desde-línea-de-comandos][Interface desde línea de comandos]]
  - [[#diseño-1][Diseño]]
  - [[#wishlist][Wishlist]]
  - [[#mejoras][Mejoras]]
  - [[#implementación][Implementación]]
- [[#sources][Sources]]
  - [[#diseño-2][Diseño]]
  - [[#implementación-1][Implementación]]
- [[#france-inter][France Inter]]
  - [[#módulos][Módulos]]
  - [[#podcasts][Podcasts]]
  - [[#episodios][Episodios]]
  - [[#html][HTML]]
- [[#herramientas][Herramientas]]
  - [[#módulos-1][Módulos]]
  - [[#localfolderhttpserver][LocalFolderHTTPServer]]
- [[#tests][Tests]]
  - [[#ejecutar-los-casos-de-prueba][Ejecutar los casos de prueba]]
  - [[#generar-el-reporte-de-cobertura][Generar el reporte de cobertura]]
- [[#licencia][Licencia]]
  - [[#gplv3][GPLv3]]
- [[#apéndices][Apéndices]]

* Motivación

Me gusta escuchar podcasts de [[https://franceinter.fr][France Inter]] cuando salgo a caminar, y en su momento me armé un script que me genera los links para descargar los episodios usando cURL.

Quiero mejorar ese script y transformarlo en una aplicación que me permita buscar podcasts, generar una base de datos con podcasts de distintas fuentes (p.ej. YouTube) y armar una cola de descargas.

Además, me gustaría usar este proyecto para probar dos enfoques de programación que me están interesando últimamente:

- [[http://www.literateprogramming.com/][Literate Programming]] :: Es una manera de programar en la que el código de la aplicación es un subproducto del documento que explica cómo está hecha

- [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]] :: En este libro se define una receta para la construcción de programas en forma iterativa usando el paradigma de programación funcional

** Literate Programming

Para escribir este documento estoy usando [[https://www.gnu.org/software/emacs][Emacs]] y [[https://orgmode.org][Org mode]], que es un modo de Emacs que tiene funcionalidades para literate programming.

La idea de la programación literaria consiste en que el código fuente de la aplicación sale de la documentación. Esto quiere decir que para poder generar un ejecutable (un /build/) de una aplicación hecha "literariamente" es necesario procesar la documentación, extraer de ella los fragmentos de código fuente que la constituyen (en org-mode este proceso se denomina /tangle/) y luego generar el ejecutable correspondiente con ese código.

En nuestro caso, la documentación a procesar es /este documento/. Todo el código fuente de la aplicación está contenido en este documento, dentro de los fragmentos de código delimitados por las etiquetas =#+begin_src= y =#+end_src=. Los bloques de código que tienen el parámetro =:tangle path/to/file= en el tag de inicio son exportados al archivo que indica el path. De esta manera, podemos generar todos los archivos del código fuente de la aplicación /tangleando/ la documentación. El comando =org-babel-tangle= dispara la generación de los archivos en cualquier momento.

El hecho de generar el código fuente desde este documento permite que no sea necesario guardarlo en el repositorio. Cada vez que es necesario ejecutar la aplicación, o generar un build para una versión determinada, se exporta el código fuente desde este documento. Como podemos ver usando el comando =git ls-tree=, los únicos archivos que están comiteados en el repositorio son el =.gitignore= y =podcast-db.org= (este archivo). El archivo =README.org= es un link simbólico a =podcast-db.org= para que aparezca como índice en github.

#+begin_src sh
# listar los archivos comiteados en el repositorio
git ls-tree --full-tree -r --name-only HEAD
#+end_src

#+RESULTS:
:results:
.gitignore
README.org
podcast-db.org
:end:

*** ¿Y qué hago si no sé (o no quiero) usar emacs?

Dado que el código fuente está en este documento, para poder obtener los fuentes es necesario procesarlo (tanglearlo) con emacs. Así, podemos extraer el código de la aplicación desde el documento y ejecutarlo como haríamos con cualquier otro programa. 

Vamos a usar [[https://www.docker.com/][Docker]] para bajar una imagen de Emacs y usar esa imagen para tanglear nuestro documento. 

#+begin_src sh :eval never
# descarga la imagen de emacs
docker pull silex/emacs:26-alpine

# lanza emacs en modo batch, 
# carga el archivo ./podcast-db.org del directorio actual,
# y ejecuta org-babel tangle
docker run --rm -i -v $(pwd):/app -w /app silex/emacs:26-alpine emacs --batch -l org podcast-db.org -f org-babel-tangle
#+end_src

Vemos que los fuentes se generan en la carpeta =franceinter=

#+begin_src sh :eval never
find ./franceinter
#+end_src

En teoría podríamos modificar el documento con otro editor de texto y regenerar los fuentes usando este método luego de editarlo, pero el procedimiento sería demasiado engorroso como para usarlo en la práctica.

** How to Design Programs

La otra fuente de inspiración para la metodología utilizada en este proyecto es el libro [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]]. Hay un video---[[https://media.ccc.de/v/35c3-9800-how_to_teach_programming_to_your_loved_ones][How to teach programming to your loved ones]]---en el que Mike Sperber explica la técnica utilizada para construir programas que se describe en el libro.

La idea es desarrollar una aplicación a partir de funciones elementales que se usan como piezas para ir armando componentes más complejos. El libro ofrece una receta para elaborar una función, que es la unidad mínima de código recomendada. Vamos a escribir cada una de las funciones de nuestra aplicación de acuerdo a los pasos de la siguiente receta:

- 1. Objetivo :: Identificar brevemente el propósito de la función. Nombrar las estructuras de datos que va a manipular
- 2. Firma :: Definir formalmente los parámetros de entrada y la salida de la función
- 3. Ejemplos :: Confeccionar un listado de ejemplos de parámetros de entrada que podría recibir la función y analizar cuál debería ser la salida para cada uno
- 4. Boceto :: Traducir la firma de la función en un boceto de la implementación
- 5. Definición :: Completar el boceto teniendo en cuenta el análisis y los ejemplos para lograr cumplir el propósito de la función
- 6. Casos de prueba :: Transformar los ejemplos en casos de prueba y asegurarse de que la función los pase a todos

En este caso, vamos a desarrollar nuestra aplicación en el lenguaje [[https://python.org][Python]] usando el paradigma de programación funcional. Esto quiere decir que nuestra aplicación va a estar mayormente compuesta de funciones (=def my_func():=) que vamos a ir combinando para realizar tareas complejas.

* Diseño
** Fuentes de podcasts

Quiero que mi base de datos pueda consultar las siguientes fuentes de podcasts:

- FranceInter
- FranceCulture
- RFI
- Youtube
- PBS
- BBC
- Team Human
- Radiolab
- RSS feeds

** Funcionalidades
*** Consulta de podcasts y episodios

- [X] Listar las fuentes de podcasts disponibles
- [X] Listar los podcasts de una fuente
- [X] Consultar el detalle de un podcast
- [X] Listar los episodios de un podcast
- [X] Consultar el detalle de un episodio
- [X] Filtrar los episodios de un podcast según algún criterio (año, mes, palabra clave)

*** Descarga y almacenamiento local

- [ ] Guardar las fuentes, los podcasts y sus episodios en una base de datos local
- [ ] Generar una playlist o feed RSS a partir de un listado de episodios
- [ ] Crear una cola de descarga a partir de una playlist
- [ ] Procesar los archivos descargados (p.ej, cambiar el bitrate a 64k)

*** Interfaces de usuario

- [ ] Linea de comandos (CLI)
- [ ] Interface web

* Versionado
** ChangeLog
*** 0.1.0 - 2019-03-01

- Versión inicial
- Consulta de podcasts y episodios
- Fuente FranceInter

** Roadmap
*** 1.0.0

- Consulta de podcasts y episodios de una fuente (FranceInter)
- Guardar las fuentes, los podcasts y sus episodios en una base de datos local
- Interface desde línea de comandos (CLI)

* Setup
** Dependencias

Vamos a usar las siguientes bibliotecas

- requests :: Para realizar las peticiones http
- requests-cache :: Para cachear las peticiones http
- beautifulsoup4 :: Para parsear html
- slugify :: Para generar el nombre del archivo a descargar
- pytest :: Para ejecutar los casos de prueba
- pytest-cov :: Para generar el reporte de cobertura de tests
- validators :: Para validar URLs

**** TODO evaluar [[https://html.python-requests.org/][Requests-HTML]]

Parece que sería una alternativa interesante a BeautifulSoup4. 

Ventajas:

- Automatic following of redirects
- Pagination support
- Mocked user-agent (like a real web browser)

Desventajas:

- Solamente funciona con Python >= 3.6
- Tiene apenas un año de desarrollo (bs4 está /battle-tested/)
- Depende de muchos módulos (bloated?)

** requirements.txt

#+begin_src txt :tangle requirements.txt
beautifulsoup4
slugify
requests
requests-cache
pytest
pytest-cov
validators
#+end_src

** Instalar las dependencias
**** 1. Inicializar la carpeta =./venv=

#+begin_src sh
rm -Rf ./venv
virtualenv-3.6 ./venv
#+end_src

**** 2. Instalar dependencias con =pip=

#+begin_src sh
pip-3.6 install -r requirements.txt
#+end_src

** Generar el ejecutable

- [ ] Usar [[https://www.pyinstaller.org][PyInstaller]] para generar un ejecutable en un solo archivo

#+begin_quote
pip install pyinstaller

Go to your program’s directory and run:

pyinstaller yourprogram.py

This will generate the bundle in a subdirectory called dist.
#+end_quote

** .gitignore

#+begin_src text :tangle .gitignore
.DS_Store
.pytest_cache
__pycache__
.coverage
cache.sqlite
cli
coverage
downloads
franceinter
requirements.txt
sources
utils
venv
#+end_src

* Interface desde línea de comandos
** Diseño
*** Consulta de podcasts y episodios

Quiero que los comandos de consulta sean lo más claro y conciso posible. Tenemos básicamente dos operaciones, listar y ver el detalle, tanto para los podcasts como para los episodios. 

En los listados se puede agregar el argumento =--with-keyword= que filtra por palabra clave y, para los episodios, también se puede filtrar por año con el argumento =--for-year= y por mes con =--for-month=.

Para ver el detalle de un podcast o de un episodio se debe indicar un identificador. En el caso de los podcasts vamos a usar el nombre de la fuente (o su código) seguido de un slash y el identificador del podcast. Para identificar un episodio dentro de un determinado podcast, en principio, vamos a usar como identificador su fecha de publicación.

#+begin_src sh :eval never

# listar fuentes de podcasts
podcast-db --list-sources

# listar podcasts de una fuente
podcast-db --list-podcasts-from franceinter
podcast-db --list-podcasts-from franceinter --with-keyword musique

# ver detalle de un podcast
podcast-db --show-podcast franceinter/darwin

# listar episodios de un podcast
podcast-db --list-episodes-from franceinter/darwin
podcast-db --list-episodes-from franceinter/darwin --for-year 2018
podcast-db --list-episodes-from franceinter/darwin --for-month 2018-05
podcast-db --list-episodes-from franceinter/darwin --with-keyword musique

# ver detalle de un episodio
podcast-db --show-episode franceinter/darwin/2018-04-16

#+end_src

** Wishlist

- [ ] Validar los argumentos recibidos
- [ ] Generar el comando a ejecutar a partir de los argumentos
- [ ] Listar las fuentes de podcasts
- [ ] Listar los podcasts de una fuente
- [ ] Mostrar el detalle de un podcast
- [ ] Listar los episodios de un podcast
- [ ] Mostrar el detalle de un episodio
- [ ] Mostrar el mensaje de ayuda
- [ ] Mostrar el mensaje con la versión

** Mejoras
** Implementación
*** Módulos
**** cli

#+begin_src python :tangle cli/__init__.py
__all__ = [
    "commands", "query", "database"
]
#+end_src

*** Commands
**** Submódulos
**** TODO arguments_from_cli
***** 1. Objetivo
***** 2. Firma
***** 3. Ejemplos
***** 4. Boceto
***** 5. Definición
***** 6. Casos de prueba
**** TODO command_from_arguments
***** 1. Objetivo
***** 2. Firma
***** 3. Ejemplos
***** 4. Boceto
***** 5. Definición
***** 6. Casos de prueba
**** TODO module_from_source
**** TODO output_from_command
*** Query
**** TODO output_from_source_list
**** TODO output_from_podcast_list
**** TODO output_from_podcast_details
**** TODO output_from_episode_list
**** TODO output_from_episode_details
**** TODO output_from_help
**** TODO output_from_version
*** Storage
**** TODO output_from_save_sources
**** TODO output_from_save_podcasts
**** TODO output_from_save_episodes
**** TODO output_from_download_episodes
*** Files
* Sources
** Diseño

- [X] Listar las fuentes de podcasts disponibles

Por el momento, la única fuente disponible es FranceInter

** Implementación
*** Submódulos
**** Sources

#+begin_src python :tangle sources/__init__.py
__all__ = [
    "list_sources"
]
#+end_src

**** Tests

#+begin_src python :tangle sources/tests/__init__.py
__all__ = [
    "test_list_sources"
]
#+end_src

*** list_sources
**** 1. Objetivo

Obtener el listado de fuentes de podcasts disponibles.

**** 2. Firma

La función no recibe argumentos y devuelve una lista de objetos =sources.Source=

#+begin_src python :tangle sources/source.py
class Source:
    def __init__(self, name, code):
        self.name = name
        self.code = code

    def __repr__(self):
        return "Source(name='%s', code='%s')" % (self.name, self.code)
#+end_src

**** 3. Ejemplos

Dado que la función no recibe argumentos, no es necesario confeccionar ejemplos.

**** 4. Boceto

#+begin_src python
def list_sources():
    # devuelve un list
    sources = []
    # hay que agregar la lista de fuentes de podcasts
    return sources
#+end_src

**** 5. Definición

#+begin_src python :tangle sources/list_sources.py
from sources.source import Source

def list_sources():
    franceinter = Source("franceinter", "fri")
    sources = [franceinter]
    return sources
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve una lista de un solo elemento.

#+begin_src python :tangle sources/tests/test_list_sources.py
from sources.list_sources import list_sources
from sources.source import Source

def test_sources_ok():
    sources = list_sources()
    assert (len(sources) == 1)
    assert (sources[0].name == "franceinter")
    assert (sources[0].code == "fri")
    for source in sources:
        assert isinstance(source, Source)

#+end_src

****** Run tests

#+begin_src sh
pytest sources/tests/test_list_sources.py
#+end_src

* France Inter
** Módulos

Vamos a organizar el código en paquetes (carpetas), lo que nos permite usar namespaces para importar las funcionalidades. Para ello, necesitamos crear un archivo =__init__.py= en cada carpeta para declarar los módulos que forman parte nuestro paquete y que Python pueda encontrarlos cuando los referenciamos en el =import=.

El módulo actual es =franceinter=, y tiene los siguientes submódulos:

- podcasts
- episodes

#+begin_src python :tangle franceinter/__init__.py
__all__ = ["podcasts", "episodes"]
#+end_src

** Podcasts
*** Diseño

France Inter publica en una sola página (enorme) el listado de todas sus emisiones. El html está bastante fácil de parsear, dado que los datos cada emisión se encuentran dentro de un =div= con la clase =rich-section-list-item-content=. Revisando el contenido de ese div, podemos obtener el título del podcast, su URL y el autor (que es opcional).

Queremos obtener el listado de los podcasts desde un URL y también desde un archivo local. Además queremos poder filtrar el listado buscando los podcasts que contengan una palabra clave en el autor o en el título.

Para poder consultar los podcasts y los episodios desde la línea de comandos necesitamos asignarle un identificador único a cada podcast. Lo más sencillo de implementar sería asignarle a cada podcast un código numérico o un hash a partir de su nombre o de su URL. El problema es que eso no es muy amigable para el usuario, que debería primero listar los podcasts que le interesan, tomar nota o recordar el código o hash y luego usar ese código para consultar los episodios. 

Sería mejor utilizar el título y el autor del podcast para generar un identificador que sea sencillo de recordar (o por lo menos, más fácil de recordar que un hash). La idea es extraer las palabras del título y del autor de cada podcast y generar un listado con las frecuencias de aparición de cada palabra. Luego, si entre las palabras de un podcast hay una que tenga frecuencia igual a uno (1), esa debería ser la palabra que debemos usar como identificador.

*** Wishlist

- [X] Obtener el listado de los podcasts de France Inter
- [X] Para cada podcast obtener el nombre, el url y el autor
- [X] Filtrar el listado de podcasts por una palabra clave
- [ ] Asignarle un identificador a cada podcast

**** Obtener el listado de los podcasts de France Inter

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcasts_from_url import podcasts_from_url

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
first_five = itertools.islice(podcasts, 5)
for podcast in first_five:
    print(podcast)
    print("\n")
#+end_src

#+RESULTS:
:results:
Podcast(title='1001 mondes', url='https://www.franceinter.fr/emissions/mille-et-un-mondes')


Podcast(title='116 rue Albert-Londres', url='https://www.franceinter.fr/emissions/116-rue-albert-londres')


Podcast(title='18 bis, boulevard Hache-Coeur', url='https://www.franceinter.fr/emissions/18-bis-boulevard-hache-coeur')


Podcast(title='1914/1918 : la grande guerre, cent ans après', url='https://www.franceinter.fr/emissions/1914-1918-la-grande-guerre-cent-ans-apres')


Podcast(title='1918, un monde en révolutions', url='https://www.franceinter.fr/emissions/1918-un-monde-en-revolutions')


:end:

**** Para cada podcast obtener el nombre, el url y el autor

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcasts_from_url import podcasts_from_url

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
first_five = list(itertools.islice(podcasts, 5))
first = first_five[0]
print(" Podcast title: " + first.title)
print("   Podcast URL: " + first.url)
print("Podcast author: " + first.author)
#+end_src

#+RESULTS:
:results:
 Podcast title: 1001 mondes
   Podcast URL: https://www.franceinter.fr/emissions/mille-et-un-mondes
Podcast author: Laura El Makki
:end:

**** Filtrar el listado de podcasts por una palabra clave

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcasts_from_url import podcasts_from_url
from franceinter.podcasts.podcasts_with_keyword import podcasts_with_keyword

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
music_podcasts = podcasts_with_keyword(podcasts, "musique")
first_five = itertools.islice(music_podcasts, 5)
for podcast in first_five:
    print(podcast)
    print("\n")
#+end_src

**** Asignarle un identificador a cada podcast
***** Prueba de concepto: Frecuencia de palabras en título + autor

Realizamos una prueba de concepto para determinar si se puede utilizar la frecuencia de las palabras que componen el título y el autor para asignarle un identificador único a cada podcast que no sea un código difícil de recordar.

Encontramos que, de los 973 podcasts de France Inter hay solamente 655 que tienen una palabra única en su título o autor que se pueda utilizar como identificador. Esto significa que no tendríamos un identificador único para los 318 podcasts restantes, por lo que *este método no nos sirve*.

Ejemplos:

#+begin_src text
Dans la playlist de France Inter - 
id: playlist (4)


Festival de Radio France  - Sylvie Chapelle
id: radio (8)


France Inter : 50 ans de science - Mathieu Vidard
id: science (4)


France Inter avec et pour les femmes - Stéphanie Duncan
id: femmes (4)
#+end_src

#+begin_src python
import re
import itertools
import requests
import requests_cache
from unidecode import unidecode
from franceinter.podcasts.podcasts_from_url import podcasts_from_url
from franceinter.podcasts.podcasts_with_keyword import podcasts_with_keyword

requests_cache.install_cache()

def all_podcasts():
    url = "https://www.franceinter.fr/emissions/"
    podcasts = podcasts_from_url(url)
    return podcasts

def podcast_words(podcast):
    words = re.split('\W+', podcast.title)
    words+= re.split('\W+', podcast.author)
    words = list(set(words))
    words = map(lambda w: unidecode(w.lower()), words)
    words = filter(lambda w: len(w)>0, words)
    return list(words)

def word_frequencies():
    freq = {}
    podcasts = all_podcasts()
    for podcast in podcasts:
        words = podcast_words(podcast)
        for word in words:
            if word not in freq:
                freq[word]=0
            freq[word]+=1
    return freq

def identifier(freqs, podcast):
    words = podcast_words(podcast)
    identifier = words[0]
    for word in words:
        if freqs[word] <= freqs[identifier]:
            identifier = word
    return identifier

def podcasts_with_unique_id(podcasts):
    frequencies = word_frequencies()
    podcasts_with_id = map(lambda p: [p, identifier(frequencies, p)], podcasts)
    uniques = filter(lambda item: frequencies[item[1]]==1, podcasts_with_id)
    return map(lambda p: p[0], uniques)

def podcasts_with_duplicate_id(podcasts):
    frequencies = word_frequencies()
    podcasts_with_id = map(lambda p: [p, identifier(frequencies, p)], podcasts)
    duplicates = filter(lambda item: frequencies[item[1]]>1, podcasts_with_id)
    return map(lambda p: p[0], duplicates)

def unique_stats():
    frequencies = word_frequencies()
    unique_podcasts = podcasts_with_unique_id(all_podcasts())
    print ("Unique ID: " + str(len(list(unique_podcasts))))
    print ("Total: " + str(len(list(all_podcasts()))))

def print_identifier(podcasts):
    frequencies = word_frequencies()
    for podcast in podcasts:
        print("%s - %s" % (podcast.title, podcast.author))
        podcast_id = identifier(frequencies, podcast)
        print("id: %s (%s)" % (podcast_id, frequencies[podcast_id]))
        print("\n")

def podcast_slice(keyword, how_many):
    podcasts_keyword = podcasts_with_keyword(all_podcasts(), keyword)
    podcast_slice = itertools.islice(podcasts_keyword, how_many)
    return podcast_slice

def unique_podcasts(keyword, how_many):
    podcasts = podcast_slice(keyword, how_many)
    return podcasts_with_unique_id(podcasts)
    
def duplicated_podcasts(keyword, how_many):
    podcasts = podcast_slice(keyword, how_many)
    return podcasts_with_duplicate_id(podcasts)
    

#unique_stats()
#podcasts = unique_podcasts("cheissoux", 200)
#podcasts = podcast_slice("cheissoux", 200)
podcasts = duplicated_podcasts("france", 15)
print_identifier(podcasts)

#+end_src

#+RESULTS:
:results:
Dans la playlist de France Inter - 
id: playlist (4)


Festival de Radio France  - Sylvie Chapelle
id: radio (8)


France Inter : 50 ans de science - Mathieu Vidard
id: science (4)


France Inter avec et pour les femmes - Stéphanie Duncan
id: femmes (4)


France Inter et les 40 ans du Prix du Livre Inter - Eva Bettan
id: prix (2)


France Inter et le cinéma - Laurent Delmas
id: cinema (6)


France Inter et le jazz - Elsa Boublil
id: jazz (3)


:end:

***** Otra alternativa: Usar la parte única del URL del podcast

Vemos que el URL es una propiedad única de un podcast, dado que dos podcasts no pueden tener el mismo URL. En el caso de France Inter, la parte única del URL de cada podcast es lo que le sigue a =https://www.franceinter.fr/emissions/=.

Podríamos usar la parte única del URL para identificar al podcast.

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcasts_from_url import podcasts_from_url

requests_cache.install_cache()

url = "https://www.franceinter.fr/emissions/"
podcasts = podcasts_from_url(url)
first_five = list(itertools.islice(podcasts, 5))
for podcast in first_five:
    print(" Podcast title: " + podcast.title)
    print("   Podcast URL: " + podcast.url)
    print("Podcast author: " + podcast.author)
    print("\n")
#+end_src

#+RESULTS:
:results:
 Podcast title: 1001 mondes
   Podcast URL: https://www.franceinter.fr/emissions/mille-et-un-mondes
Podcast author: Laura El Makki


 Podcast title: 116 rue Albert-Londres
   Podcast URL: https://www.franceinter.fr/emissions/116-rue-albert-londres
Podcast author: Alexandre Héraud


 Podcast title: 18 bis, boulevard Hache-Coeur
   Podcast URL: https://www.franceinter.fr/emissions/18-bis-boulevard-hache-coeur
Podcast author: Frédéric Pommier


 Podcast title: 1914/1918 : la grande guerre, cent ans après
   Podcast URL: https://www.franceinter.fr/emissions/1914-1918-la-grande-guerre-cent-ans-apres
Podcast author: 


 Podcast title: 1918, un monde en révolutions
   Podcast URL: https://www.franceinter.fr/emissions/1918-un-monde-en-revolutions
Podcast author: Ali Baddou


:end:

*** TODO Mejoras

- [ ] =podcasts_from_filename= :: Se podrían matchear los errores de lectura del archivo con los códigos de la respuesta HTTP (404 si no se encuentra, 500 si hubo un error de I/O, etc)

- [X] =podcasts_from_query= :: Analizar el cambio de nombre por =podcasts_matching_query=, que expresa mejor que la función es un filtro de podcasts usando una palabra clave. Pensándolo bien, el nombre de que mejor expresa lo que hace la función es =podcasts_with_keyword=

- [ ] =podcasts_with_keyword= :: Agregar que no distinga entre los caracteres acentuados (á vs a) al buscar. Por ejemplo, si la palabra buscada es =té= debería devolver los podcasts que contengan tanto =té= como =te=

- [ ] =autopep8= :: Aplicar el estándar PEP8 a todas las funciones

*** Submódulos
**** Podcasts

#+begin_src python :tangle franceinter/podcasts/__init__.py
__all__ = [
    "author_from_tag", 
    "title_from_tag", 
    "url_from_tag", 
    "podcast_from_tag", 
    "tags_from_html", 
    "podcasts_from_tags", 
    "podcasts_from_response", 
    "podcasts_from_url", 
    "podcasts_from_filename", 
    "podcasts_with_keyword",
    "podcast"
]
#+end_src

**** Tests

#+begin_src python :tangle franceinter/podcasts/tests/__init__.py
__all__ = [
    "test_author_from_tag", 
    "test_title_from_tag", 
    "test_url_from_tag", 
    "test_podcast_from_tag", 
    "test_tags_from_html", 
    "test_podcasts_from_tags", 
    "test_podcasts_from_response", 
    "test_podcasts_from_url", 
    "test_podcasts_from_filename", 
    "test_podcasts_with_keyword",
    "examples_author_from_tag", 
    "examples_title_from_tag",
    "examples_url_from_tag",
    "examples_podcast_from_tag",
    "examples_tags_from_html",
    "examples_podcasts_from_tags",
    "examples_podcasts_from_response",
    "examples_podcasts_from_url",
    "examples_podcasts_from_filename",
    "examples_podcasts_with_keyword"
]
#+end_src

*** podcasts_from_url
**** 1. Objetivo

Extraer el listado de podcasts desde un URL

**** 2. Firma

La función recibe un URL y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Un URL con el listado de podcasts
- Un URL de otra página, que no tiene podcasts
- Un URL de una página inexistente, que dispare un error 404 (not found)
- Un URL de un sitio inexistente, que dispare un error de DNS
- Un URL inválido

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_url.py

def url_ok():
    url = "http://localhost:3000/podcast-list-short.html"
    return url

def wrong_page_url():
    url = "http://localhost:3000/wrong-page.html"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def wrong_site_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

def invalid_url():
    url = "ht pt:\\hostlocal:3000/this-url-is-not-valid.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_url(url):
    # validar el url
    # realizar una petición al url
    # obtener la respuesta del url
    # obtener los podcasts llamando a podcasts_from_url
    # revisar si da un error de conexión
    return podcasts

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_url.py
import requests
from validators.url import url as is_valid_url
from franceinter.podcasts.podcasts_from_response import podcasts_from_response

def podcasts_from_url(url):
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        podcasts = podcasts_from_response(response)
        return podcasts
    except requests.ConnectionError:
        assert False, connection_error(url)

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url
#+end_src

**** 6. Casos de prueba

Bueno, aquí tenemos un caso de prueba un poco más complejo que lo normal. Para poder testear nuestra función necesitamos realizar una petición HTTP. El problema es que no queremos depender de un sitio web externo, o de que haya conectividad a Internet cuando se ejecuten los casos de prueba. La solución es levantar un servidor HTTP desde una carpeta local y en nuestro caso vamos a usar los archivos HTML de ejemplo que tenemos en =franceinter/html=.

Ahora bien, necesitamos que el servidor HTTP esté levantado antes de correr nuestros casos de prueba y sería ideal poder bajarlo luego de ejecutar todos los tests que lo necesiten. Para ello vamos a usar un [[https://docs.pytest.org/en/latest/fixture.html][fixture]] (=@pytest.fixture=), que es una funcionalidad de pytest que permite que los casos de prueba reciban un argumento con algún recurso, en este caso, el servidor HTTP ya levantado y sirviendo los archivos desde la carpeta local.

El atributo ~scope="module"~ indica que el fixture =http_server= será invocado una sola vez por módulo, que es lo que queremos para que todos los tests de nuestra función compartan el mismo servidor HTTP y no tener que levantarlo y bajarlo para cada test. Cuando no se indica un =scope=, pytest invoca el fixture para cada caso de prueba.

Un fixture es una función común y corriente como cualquier otra, a la que pytest llama cuando comienza a procesar el módulo, se guarda el valor retornado, y se lo inyecta a los casos de prueba que declaren ese fixture como parámetro.

Nótese en el código del fixture =http_server= que se levanta el servidor HTTP en otro thread para no bloquear la ejecución de los tests y que se utiliza =yield= para poder bajar el servidor luego de su uso.

- Cuando recibe un URL con el listado de podcasts, devuelve un =GeneratorType= de objetos =Podcast=
- Cuando recibe un URL de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de una página inexistente, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de un sitio inexistente (error de DNS), lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_url.py
import pytest
import threading
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_url import podcasts_from_url
from franceinter.podcasts.tests.examples_podcasts_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = url_ok()
    gen = podcasts_from_url(url)
    assert isinstance(gen, types.GeneratorType)
    podcasts = list(gen)
    assert (len(podcasts) > 0)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_wrong_page_url(http_server):
    url = wrong_page_url()
    podcasts = list(podcasts_from_url(url))
    assert (len(podcasts) == 0)

def test_not_found_url(http_server):
    url = not_found_url()
    podcasts = list(podcasts_from_url(url))
    assert (len(podcasts) == 0)

@pytest.mark.skip(reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = wrong_site_url()
    try:
        podcasts = list(podcasts_from_url(url))
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        podcasts = podcasts_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_url.py
#+end_src

*** podcasts_with_keyword
**** 1. Objetivo

Filtrar un listado de podcasts y obtener solamente los que contienen una palabra clave en el título o en el autor

Se debe buscar la palabra clave sin tener encuenta las mayúsculas o minúsculas (case insensitive match)

**** 2. Firma

La función recibe un listado de objetos =franceinter.podcasts.Podcast= y un =str=, y devuelve un =filter= de objetos =franceinter.podcasts.Podcast=

Para el listado de podcasts vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 podcasts en el que hay 2 que tienen la palabra "radio" en el título 
- Un listado de 5 podcasts en el que hay 3 que tienen la palabra "radio" en el autor
- Un listado de 5 podcasts en el que ninguno tiene la palabra "radio" en el título y/o autor
- Un listado de podcasts que no es iterable
- Un listado de podcasts que no tiene objetos =franceinter.podcasts.Podcast=
- Una query que no es un =str=

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_with_keyword.py
import random
from franceinter.podcasts.podcast import Podcast

def podcasts_with_word_in_title(word):
    podcasts = []
    for i in range(0, 3):
        podcasts.append(new_podcast())
    p = new_podcast()
    p.title+= " " + word
    podcasts.append(p)
    podcasts.append(p)
    random.shuffle(podcasts)
    return podcasts

def podcasts_with_word_in_author(word):
    podcasts = []
    for i in range(0, 2):
        podcasts.append(new_podcast())
    p = new_podcast()
    p.author+= " " + word
    podcasts.append(p)
    podcasts.append(p)
    podcasts.append(p)
    random.shuffle(podcasts)
    return podcasts

def some_podcasts(how_many):
    for i in range(0, how_many):
        yield new_podcast()

def podcasts_not_iterable():
    return 42
        
def invalid_podcasts():
    return range(0,10)

def invalid_keyword():
    return 42

def new_podcast():
    title = "Este es un podcast de ejemplo"
    url = "http://podcastplace.com/shows"
    author = "Juan Perez"
    return Podcast(title, url, author)

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_with_keyword(podcasts, query):
    # validar que los podcasts sean iterables
    # validar que la query sea un str
    # validar que cada podcast sea un Podcast
    # filtrar los podcasts con una función que devuelva true 
    # si el título o el autor contienen la query

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_with_keyword.py
import re
from franceinter.podcasts.podcast import Podcast

def podcasts_with_keyword(podcasts, keyword):
    # validar que los podcasts sean iterables
    try:
        it = iter(podcasts)
    except TypeError:
        assert False, invalid_podcasts(podcasts)
    # validar que la keyword sea un str
    assert isinstance(keyword, str), invalid_keyword(keyword)
    # validar que cada podcast sea un Podcast
    valid_podcasts = filter(is_podcast, podcasts)
    # filtrar los podcasts que contienen la query
    contains_keyword = keyword_matcher(keyword)
    return filter(contains_keyword, valid_podcasts)

def is_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    return True
    
def keyword_matcher(keyword):
    def matcher(podcast):
        return (re.search(keyword, podcast.title, re.IGNORECASE) 
                or re.search(keyword, podcast.author, re.IGNORECASE))
    return matcher
    
def invalid_podcasts(podcasts):
    return "podcasts parameter must be iterable, received %s instead" % type(podcasts)

def invalid_keyword(keyword):
    return "keyword parameter must be a string, received %s instead" % type(keyword)

def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % type(podcast)

#+end_src

**** 6. Casos de prueba

- Cuando recibe un listado de 5 podcasts en el que hay 2 que tienen la palabra "radio" en el título, devuelve un =filter= con los 2 podcasts que cumplen la condición
- Cuando recibe un listado de 5 podcasts en el que hay 3 que tienen la palabra "radio" en el autor, devuelve un =filter= con los 3 podcasts que cumplen la condición
- Cuando recibe un listado de 5 podcasts en el que ninguno tiene la palabra "radio" en el título y/o autor, devuelve un =filter= vacío
- Cuando recibe un listado de podcasts que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de podcasts que no tiene objetos =franceinter.podcasts.Podcast=, lanza un =AssertionError=
- Cuando recibe una query que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_with_keyword.py
import types
from franceinter.podcasts.podcasts_with_keyword import podcasts_with_keyword
from franceinter.podcasts.tests.examples_podcasts_with_keyword import *

def test_podcasts_with_word_in_title():
    podcasts = podcasts_with_word_in_title("radio")
    result = podcasts_with_keyword(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_podcasts_with_word_in_author():
    podcasts = podcasts_with_word_in_author("radio")
    result = podcasts_with_keyword(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 3)

def test_podcasts_without_word():
    podcasts = some_podcasts(8)
    result = podcasts_with_keyword(podcasts, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_podcasts_not_iterable():
    podcasts = podcasts_not_iterable()
    try:
        result = podcasts_with_keyword(podcasts, "radio")
    except AssertionError:
        assert True

def test_invalid_podcasts():
    podcasts = invalid_podcasts()
    try:
        result = podcasts_with_keyword(podcasts, "radio")
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_query():
    podcasts = some_podcasts(10)
    keyword = invalid_keyword()
    try:
        result = podcasts_with_keyword(podcasts, keyword)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_with_keyword.py
#+end_src

*** podcasts_from_response
**** 1. Objetivo

Extraer el listado de podcasts de la respuesta de una petición HTTP

**** 2. Firma

La función recibe una =requests.model.Response= y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Una respuesta válida, con el HTML de la página del listado de podcasts
- Una respuesta inválida, que no es de la clase =requests.model.Response=
- Una respuesta válida, pero que tiene el HTML de otra página

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_response.py
from requests.models import Response

def response_ok():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/podcast-list-short.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

def invalid_response():
    return "i am not a Response"

def wrong_page_response():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/wrong-page.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

#+end_src

#+RESULTS:
:results:
:end:

**** 4. Boceto

#+begin_src python
import requests

def podcasts_from_response(resp):
    # validar la respuesta
    # obtener el HTML de resp.text
    # extraer los tags usando tags_from_html
    # obtener los podcasts usando podcasts_from_html

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_response.py
import requests
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.podcasts_from_tags import podcasts_from_tags

def podcasts_from_response(resp):
    assert isinstance(resp, requests.models.Response), invalid_type(resp)
    html = resp.text
    tags = tags_from_html(html)
    podcasts = podcasts_from_tags(tags)
    return podcasts
    
def invalid_type(resp):
    return "resp parameter must be a requests.models.Response, received %s instead" % type(resp)

#+end_src

**** 6. Casos de prueba

- Cuando recibe una respuesta válida, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Cuando recibe una respuesta que no es de la clase =requests.model.Response=, lanza un =AssertionError=
- Cuando recibe una respuesta válida que tiene el HTML de otra página, devuelve un =GeneratorType= vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_response.py
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_response import podcasts_from_response
from franceinter.podcasts.tests.examples_podcasts_from_response import *

def test_response_ok():
    resp = response_ok()
    podcasts = podcasts_from_response(resp)
    assert isinstance(podcasts, types.GeneratorType)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_invalid_response():
    resp = invalid_response()
    try:
        podcasts = podcasts_from_response(resp)
    except AssertionError:
        assert True
    
def test_wrong_page_response():
    resp = wrong_page_response()
    podcasts = podcasts_from_response(resp)
    assert isinstance(podcasts, types.GeneratorType)
    assert (len(list(podcasts)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_response.py
#+end_src

*** podcasts_from_tags
**** 1. Objetivo

Generar un listado de podcasts a partir de un listado de fragmentos de HTML tomados de la página

**** 2. Firma

La función recibe un listado de objetos =bs4.element.Tag= y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

Vamos a aceptar tanto un =list= como un =GeneratorType=

**** 3. Ejemplos

- Un objeto que no es iterable
- Una lista vacía
- Una lista con tags válidos
- Una lista con objetos que no son del tipo =bs4.element.Tag=
- Una lista con tags válidos y un tag inválido (sin el título o el URL)

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_tags.py
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *
from franceinter.podcasts.tests.examples_podcast_from_tag import (
    tag_ok, 
    tag_without_url
)

def invalid_list():
    return 123

def empty_list():
    return []

def list_without_tags():
    return [1, 2, 3, 4, 5]

def list_with_valid_tags(how_many):
    html = ""
    for item in range(1, how_many):
        html+= str(tag_ok())
    tags = tags_from_html(html)
    return tags

def list_with_invalid_tag(how_many):
    tags = list(list_with_valid_tags(how_many - 1))
    tags+= tag_without_url()
    return tags

#+end_src

**** 4. Boceto

#+begin_src python
from franceinter.podcasts.tags_from_html import tags_from_html

def podcasts_from_tags(tags):
    # validar que tags sea un GeneratorType
    # para cada tag de la lista
    # usar podcast_from_tag() para obtener un podcast
    # yield posdcast

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_tags.py
from franceinter.podcasts.podcast_from_tag import podcast_from_tag

def podcasts_from_tags(tags):
    try:
        it = iter(tags)
    except TypeError:
        assert False, invalid_tags(tags)
    for tag in tags:
        yield podcast_from_tag(tag)

def invalid_tags(tags):
    return "tags parameter must be iterable, received %s instead" % type(tags)
#+end_src

**** 6. Casos de prueba

- Si recibe un objeto que no es iterable, lanza un =AssertionError=
- Si recibe una lista vacía, devuelve un =GeneratorType= vacío
- Si recibe una lista de tags válidos, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Si recibe una lista con objetos que no son del tipo =bs4.element.Tag=, lanza un =AssertionError=
- Si recibe una lista con algún tag inválido (que no tenga el título o el URL), lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_tags.py
import types
from franceinter.podcasts.podcasts_from_tags import podcasts_from_tags
from franceinter.podcasts.tests.examples_podcasts_from_tags import *
from franceinter.podcasts.podcast import Podcast

def test_invalid_list():
    tags = invalid_list()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_empty_list():
    tags = empty_list()
    podcasts = podcasts_from_tags(tags)
    assert isinstance(podcasts, types.GeneratorType)
    assert (len(list(podcasts))==0)

def test_list_with_valid_tags():
    tags = list_with_valid_tags(6)
    podcasts = podcasts_from_tags(tags)
    assert isinstance(podcasts, types.GeneratorType)
    for p in podcasts:
        assert (isinstance(p, Podcast))

def test_list_without_tags():
    tags = list_without_tags()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_list_with_invalid_tag():
    tags = list_with_invalid_tag(6)
    podcasts = podcasts_from_tags(tags)
    try:
        for p in podcasts:
            assert (isinstance(p, Podcast))
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcasts_from_tags.py
#+end_src

*** podcasts_from_filename
**** 1. Objetivo

Extraer un listado de podcasts desde un archivo

**** 2. Firma

La función recibe un =str= con el nombre del archivo y devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=

**** 3. Ejemplos

- Un archivo HTML que tiene un listado de podcasts
- Un archivo HTML de otra página, que no tiene podcasts
- Un archivo que no existe
- Un nombre de archivo que no es un =str=

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_filename.py

def ok_filename():
    return "./franceinter/html/podcast-list-short.html"

def wrong_filename():
    return "./franceinter/html/wrong-page.html"

def not_found_filename():
    return "./franceinter/html/this-file-does-not-exist.html"

def invalid_filename():
    return [1, 2, 3]

#+end_src

**** 4. Boceto

#+begin_src python

def podcasts_from_filename(filename):
    # validar que filename sea un str
    # validar que el archivo exista
    podcasts = []
    # crear un requests.models.Response con el contenido del archivo
    # obtener los podcasts llamando a podcasts_from_response
    return podcasts
     
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_filename.py
from requests.models import Response
from franceinter.podcasts.podcasts_from_response import podcasts_from_response

def podcasts_from_filename(filename):
    assert isinstance(filename, str), invalid_filename(filename)
    resp = Response()
    podcasts = []
    try:
        with open(filename, "rb") as f:
            resp._content = f.read()
            podcasts = podcasts_from_response(resp)
    except (OSError, IOError) as error:
        assert False, not_found(filename, error)
    return podcasts

def invalid_filename(filename):
    return "filename parameter must be a str, %s received instead" % filename

def not_found(filename, error):
    return "filename %s cannot be read, thrown error :\n%s" % (filename, error)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un archivo HTML que tiene un listado de podcasts, devuelve un =GeneratorType= de objetos =franceinter.podcasts.Podcast=
- Cuando recibe un archivo HTML de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un archivo que no existe, lanza un =AssertionError=
- Cuando recibe un nombre de archivo que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_filename.py
import types
from franceinter.podcasts.podcast import Podcast
from franceinter.podcasts.podcasts_from_filename import podcasts_from_filename
from franceinter.podcasts.tests.examples_podcasts_from_filename import *

def test_ok_filename():
    filename = ok_filename()
    podcasts = podcasts_from_filename(filename)
    assert isinstance(podcasts, types.GeneratorType)
    podcasts = list(podcasts)
    assert (len(podcasts) > 0)
    for p in podcasts:
        assert isinstance(p, Podcast)

def test_wrong_filename():
    filename = wrong_filename()
    podcasts = podcasts_from_filename(filename)
    assert isinstance(podcasts, types.GeneratorType)
    podcasts = list(podcasts)
    assert (len(podcasts) == 0)

def test_not_found_filename():
    filename = not_found_filename()
    try:
        podcasts = podcasts_from_filename(filename)
    except AssertionError:
        assert True

def test_invalid_filename():
    filename = invalid_filename()
    try:
        podcasts = podcasts_from_filename(filename)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_podcasts_from_filename.py
#+end_src

*** tags_from_html
**** 1. Objetivo

Obtener un array de tags con el fragmento de html que tiene el detalle del podcast (título, URL y autor) a partir del html de la página con el listado de podcasts

Hay que extraer todos los =<div>= que tengan la clase =rich-section-list-item-content=

**** 2. Firma

La función recibe un =str= con el html de la página y devuelve un =GeneratorType= de elementos =bs4.element.Tag=

**** 3. Ejemplos

- Un html que tiene varios =<div>= con la clase buscada
- Un html que no es un =str=
- Un html que no tiene ningún =<div>=
- Un html que tiene varios =<div>= pero que ninguno tenga la clase =rich-section-list-item-content=
- Un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen

#+begin_src python :tangle franceinter/podcasts/tests/examples_tags_from_html.py
from bs4 import BeautifulSoup
import random

def html_with_divs(how_many):
    class_name = "rich-section-list-item-content"
    divs = map(lambda x: div(class_name), range(how_many))
    return html(divs)

def html_is_not_string():
    return 42

def html_without_divs():
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>'''
    return html

def html_divs_without_class(how_many):
    divs = map(lambda x: div(), range(how_many))
    return html(divs)

def html_some_divs_with_class(how_many_with, how_many_without):
    class_name = "rich-section-list-item-content"
    divs_with = list(map(lambda x: div(class_name), range(how_many_with)))
    divs_without = list(map(lambda x: div(), range(how_many_without)))
    divs = divs_with + divs_without
    random.shuffle(divs)
    return html(divs)

def div(class_name=""):
    attr = ""
    if class_name:
        attr = "class=%s" % class_name
    html = '''<div %s>
    here goes the div body
</div>''' % attr
    soup = BeautifulSoup(html, "html.parser")
    return soup.div

def html(divs):
    div_str = "".join(map(lambda div: str(div), divs))
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
%s
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    ''' % div_str
    return html
    
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup

def tags_from_html(html):
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # filtrar los tag <div> que tienen la clase "rich-section-list-item-content"
    return tags

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/tags_from_html.py
from bs4 import BeautifulSoup

def tags_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    cls = "rich-section-list-item-content"
    tags = soup.find_all("div", class_=cls)
    for tag in tags:
        yield tag

def invalid_html(html):
    return "html parameter must be a string, received %s instead" % type(html)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un html que tiene varios =<div>= con la clase buscada, devuelve un =GeneratorType= de tantos elementos como =<div>= hay en el html
- Cuando recibe un html que no es un string, lanza un =AssertionError=
- Cuando recibe un html que no tiene ningún =<div>=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene varios =<div>= pero ninguno tiene la clase =rich-section-list-item-content=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen, devuelve un =GeneratorType= con solamente los =<div>= que tienen la clase

#+begin_src python :tangle franceinter/podcasts/tests/test_tags_from_html.py
import types
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *

def test_html_with_divs():
    html = html_with_divs(5)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 5)

def test_html_is_not_string():
    try:
        html = html_is_not_string()
        tags = list(tags_from_html(html))
    except AssertionError:
        assert True

def test_html_without_divs():
    html = html_without_divs()
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_divs_without_class():
    html = html_divs_without_class(4)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_some_divs_with_class():
    html = html_some_divs_with_class(2,3)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 2)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_tags_from_html.py
#+end_src

*** podcast_from_tag
**** 1. Objetivo

Obtener un podcast de un fragmento de html.

Un podcast tiene tres propiedades, a saber:

- título :: es un =str= y es obligatorio
- url :: es un =str=, es obligatorio y debe ser un URL válido
- autor :: es un =str=, pero puede estar vacío

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un objeto =franceinter.podcasts.podcast=

Necesitamos entonces definir la clase =podcast=

#+begin_src python :tangle franceinter/podcasts/podcast.py

class Podcast:
    def __init__(self, title, url, author=""):
        self.title = title
        self.url = url
        self.author = author

    def __repr__(self):
        return "Podcast(title='%s', url='%s')" % (self.title, self.url)

#+end_src

**** 3. Ejemplos

- Un tag que tiene todos los elementos para generar un podcast válido (título, URL y autor)
- Un tag que no es un =bs4.element.Tag=
- Un tag que no tiene el elemento del título
- Un tag que no tiene el elemento del URL
- Un tag que tiene el elemento del URL, pero el URL no es válido
- Un tag que no tiene el elemento del autor

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcast_from_tag.py
from bs4 import BeautifulSoup

def tag_ok():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def invalid_tag():
    return "I am not a tag"

def tag_without_title():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_with_invalid_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="this://isnot[?=>avalid[[/\\url"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_author():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def podcast_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag

    # extraer el título con title_from_tag
    # validar que el título no sea un string vacío

    # extraer el url con url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer el autor usando author_from_tag

    # crear una instancia de franceinter.podcasts.podcast
    # con el título, el url y el autor
    return podcast

#+end_src

**** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceinter/podcasts/podcast_from_tag.py
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.podcast import Podcast
from validators.url import url as is_valid_url
import bs4

def podcast_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = title_from_tag(tag)
    assert (title != ""), no_title(tag)

    url = url_from_tag(tag)
    assert (url != ""), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)

    author = author_from_tag(tag)

    return Podcast(title, url, author)

def no_url(tag):
    return "received tag does not have a podcast URL\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid podcast URL\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have a podcast title\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve un podcast
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no tiene título, lanza un =AssertionError=
- Cuando recibe un tag que no tiene url, lanza un =AssertionError=
- Cuando recibe un tag que tiene un url pero es inválido, lanza un =AssertionError=
- Cuando recibe un tag que no tiene autor, devuelve un podcast con un =str= vacío en la propiedad author

#+begin_src python :tangle franceinter/podcasts/tests/test_podcast_from_tag.py
from franceinter.podcasts import podcast
from franceinter.podcasts.podcast_from_tag import podcast_from_tag
from franceinter.podcasts.tests.examples_podcast_from_tag import *

def test_podcast_ok():
    tag = tag_ok()
    podcast = podcast_from_tag(tag)
    assert (len(podcast.title) > 0)
    assert (len(podcast.url) > 0)
    assert (len(podcast.author) >0)
    assert (len(str(podcast)) > 0)

def test_podcast_without_title():
    tag = tag_without_title()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_url():
    tag = tag_without_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    tag = tag_with_invalid_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_author():
    tag = tag_without_author()
    podcast = podcast_from_tag(tag)
    assert len(podcast.title) > 0
    assert len(podcast.url) > 0
    assert len(podcast.author) == 0

def test_invalid_tag():
    tag = invalid_tag()
    try:
        podcast_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_podcast_from_tag.py
#+end_src

*** title_from_tag
**** 1. Objetivo

Obtener el título del podcast de un fragmento de html.

El título se encuentra en el atributo =title= de un =<a>= que tiene la clase =rich-section-list-item-content-title=

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, Un tag que contiene un =<a>= con la clase correcta y el atributo =title=
- Un tag que no tiene el =<a>=
- Un tag que tiene el =<a>= pero éste no tiene la clase =rich-section...=
- Un tag que tiene el =<a>= pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_title_from_tag.py
from bs4 import BeautifulSoup

def tag_with_title():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    title="Sur les epaules de Darwin">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a title="Sur les epaules de Darwin">
</a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    title="Sur les epaules de Darwin">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def title_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    title = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable title
    return title
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/title_from_tag.py
import bs4

def title_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "title" in link.attrs:
        title = link.attrs["title"]
    return title

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el título
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene la clase correcta, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_title_from_tag.py
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

def test_author_ok():
    tag = tag_with_title()
    assert ("Sur les epaules de Darwin" == title_from_tag(tag))

def test_invalid_tag():
    try:
        title_from_tag(5)
    except AssertionError:
        assert True

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == title_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == title_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == title_from_tag(tag))

#+end_src

#+begin_src python
from bs4 import BeautifulSoup
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

tag = tag_with_title()
title = title_from_tag(tag)
print(title)
#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_title_from_tag.py
#+end_src

*** url_from_tag
**** 1. Objetivo

Obtener el URL del podcast de un fragmento de html.

El URL se encuentra en el atributo =href= de un tag =<a>= que tiene la clase =rich-section-list-item-content-title=. 

El URL es relativo, por lo que hay que agregarle baseUrl de France Inter (https://www.franceinter.fr).

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag que contiene un =<a>= con la clase =rich-section-list-item-content-title= y el atributo =href=
- Un tag que no tiene el =<a>=
- Un tag que tiene el =<a>= pero el link no tiene clase
- Un tag que tiene el =<a>= pero el link no tiene el atributo =href=

#+begin_src python :tangle franceinter/podcasts/tests/examples_url_from_tag.py
from bs4 import BeautifulSoup

def tag_with_url():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</p>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a href="emissions/la-tete-au-carre"></a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_href():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def url_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    url = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el <a> hay que revisar si tiene el atributo href
    # si tiene el atributo href 
    #     - se le agrega "https://www.franceinter.fr/" adelante
    #     - se guarda en la variable url
    return url
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/url_from_tag.py
import bs4

def url_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    url = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "href" in link.attrs:
        url = "https://www.franceinter.fr/" + link.attrs["href"]
    return url

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el url
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene la clase buscada, devuelve un string vacío
- Cuando recibe un tag que tiene el =<a>= pero éste no tiene el atributo =href=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_url_from_tag.py
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.tests.examples_url_from_tag import *

def test_url_ok():
    tag = tag_with_url()
    url = "https://www.franceinter.fr/emissions/la-tete-au-carre"
    assert (url == url_from_tag(tag))

def test_invalid_tag():
    try:
        url_from_tag(5)
    except AssertionError:
        assert True

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == url_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == url_from_tag(tag))

def test_title_not_found():
    tag = tag_without_href()
    assert ("" == url_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_url_from_tag.py
#+end_src

*** author_from_tag
**** 1. Objetivo

Obtener el autor del podcast de un fragmento de html. 

El autor se encuentra en el atributo =title= de un =<a>= que está dentro de un =<span>= que tiene la clase =rich-section-list-item-content-infos-author=

**** 2. Firma

La funcion recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, el tag tiene un =<span>= con la clase =rich-section-list-item-content-infos-author= que contiene un =<a>= con el atributo =title=
- El tag no tiene un =<span>=
- El tag tiene un =<span>=, pero éste no tiene un =<a>=
- El tag tiene un =<span>= que contiene un =<a>=, pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_author_from_tag.py
from bs4 import BeautifulSoup

def tag_with_author():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a title="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_span():
    html = '''<div class="boldest">
Extremely bold
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<p title="William Shakespeare"></p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a subtitle="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

#+RESULTS:
:results:
True
:end:

**** 4. Boceto

#+begin_src python

def author_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    author = ""
    # hay que buscar un span con la clase "rich-section..."
    # si existe el span hay que buscar un a
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable author
    return author
    
#+end_src

#+RESULTS:
:results:
None
:end:

**** 5. Definición

#+begin_src python :tangle franceinter/podcasts/author_from_tag.py
import bs4

def author_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    cls = "rich-section-list-item-content-infos-author"
    span = tag.find("span", class_=cls)
    author = ""
    if span:
        link = span.find("a")
        if link and "title" in link.attrs:
            author = link.attrs["title"]
    return author

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve el autor
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no tiene un tag =<span>= con la clase buscada, devuelve un string vacío
- Cuando recibe un tag que tiene el =<span>= pero éste no contiene un =<a>=, devuelve un string vacío
- Cuando recibe un tag que tiene el =<span>= y el =<a>= pero éste último no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_author_from_tag.py
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.tests.examples_author_from_tag import *

def test_author_ok():
    tag = tag_with_author()
    assert ("William Shakespeare" == author_from_tag(tag))

def test_invalid_tag():
    try:
        author_from_tag(5)
    except AssertionError:
        assert True

def test_span_not_found():
    tag = tag_without_span()
    assert ("" == author_from_tag(tag))

def test_a_not_found():
    tag = tag_without_link()
    assert ("" == author_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == author_from_tag(tag))

#+end_src

#+RESULTS:
:results:
None
:end:

***** Run tests

#+begin_src sh
pytest franceinter/podcasts/tests/test_author_from_tag.py
#+end_src

** Episodios
*** Diseño

En el URL de un podcast vemos el listado de los últimos episodios disponibles. Al final del listado hay un selector de páginas para acceder al historial de episodios. Para poder obtener el historial completo necesitamos la cantidad de páginas, que está en un tag =<li>= que tiene la clase =last=. 

Una vez que tengamos la cantidad de páginas podemos obtener el listado de episodios, parseando cada una de las páginas del historial. Como hicimos en el módulo de podcasts, necesitamos poder obtener los episodios tanto desde un URL como desde un archivo local.

Cada episodio tiene un título, una fecha de emisión y un URL para descargar el audio. Podemos ver en el HTML de la página (ver el archivo =./franceinter/html/episode-list.html=) que se puede obtener también la duración en segundos del episodio, dato que puede ser útil más adelante para detectar problemas en la descarga de los archivos.

Por lo que se puede ver en el HTML, muchos de los datos que necesitamos se encuentran en un tag =<button>= que tiene la clase =replay-button=

*** Wishlist

- [X] Obtener el listado de los episodios de un podcast
- [X] Para cada episodio obtener el título, la fecha, el URL del audio y su duración
- [X] Filtrar el listado por una palabra clave
- [X] Filtrar el listado por intervalo de fechas
- [X] Filtrar el listado por año
- [X] Filtrar el listado por mes
- [X] Filtrar el listado por día

***** Obtener el listado de los episodios de un podcast

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first_five = itertools.islice(episodes, 5)
for episode in first_five:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Les chants des abeilles', date='2019-02-16')


Episode(title='L'Apiculteur aveugle', date='2019-02-09')


Episode(title='Les chants du monde', date='2019-02-02')


Episode(title='Une année dans le monde', date='2019-01-26')


Episode(title='Aux origines du chocolat (8)', date='2019-01-19')


:end:

***** Para cada episodio obtener el título, la fecha, el URL del audio y su duración

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first = list(itertools.islice(episodes, 5))[0]
print ("   Title: " + first.title)
print ("    Date: " + first.date)
print ("     URL: " + first.url)
print ("Duration: " + str(first.duration))

#+end_src

#+RESULTS:
:results:
   Title: Les chants des abeilles
    Date: 2019-02-16
     URL: https://media.radiofrance-podcast.net/podcast09/11549-16.02.2019-ITEMA_21984001-0.mp3
Duration: 3253
:end:

***** Filtrar el listado por una palabra clave

#+begin_src python
import itertools
import requests
import requests_cache
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast
from franceinter.episodes.episodes_with_keyword import episodes_with_keyword

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
choco_episodes = episodes_with_keyword(episodes, "chocolat")
first_five = itertools.islice(choco_episodes, 5)
for episode in first_five:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Aux origines du chocolat (8)', date='2019-01-19')


Episode(title='Aux Origines du Chocolat (7)', date='2019-01-12')


Episode(title='Aux Origines du Chocolat (6)', date='2019-01-05')


Episode(title='Aux origines du chocolat (5)', date='2018-12-15')


Episode(title='Aux origines du chocolat (4)', date='2018-12-08')


:end:

***** Filtrar el listado por año, mes, día o intervalo de fechas

#+begin_src python
import itertools
import requests
import requests_cache
from datetime import date as Date
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast
from franceinter.episodes.episodes_between_dates import episodes_between_dates

requests_cache.install_cache()

title = "Sur les épaules de Darwin"
url = "https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin"
author = "Jean-Claude Ameisen"
podcast = Podcast(title, url, author)
episodes = episodes_from_podcast(podcast)
first_100 = itertools.islice(episodes, 100)
june_episodes = episodes_between_dates(first_100, Date(2018, 6, 1), Date(2018, 6, 30))
for episode in june_episodes:
    print(episode)
    print("\n")

#+end_src

#+RESULTS:
:results:
Episode(title='Dans les ombres rêveuses', date='2018-06-30')


Episode(title='Le plomb et l'argent (4)', date='2018-06-23')


Episode(title='Le plomb et l'argent (3)', date='2018-06-16')


Episode(title='Le plomb et l'argent (2)', date='2018-06-09')


Episode(title='Le plomb et l'argent', date='2018-06-02')


:end:

*** TODO Mejoras

- [ ] Crear una nueva función =attribute_from_tag= para extraer un atributo de un tag con una clase determinada

Luego de la implementación de varias funciones vemos que hay un patrón de código que se repite: Se busca un tag HTML con una clase determinada, y de ese tag se extrae un atributo específico. Podemos ver ejemplos de este patrón en las funciones =title_from_tag=, =url_from_tag= y =author_from_tag= del módulo podcasts y otros tantos en las funciones de este módulo que extraen los atributos del episodio (p.ej. =title_from_tag=). Quizás sea necesario crear un nuevo módulo /Tags/ que contenga la lógica que se encarga de extraer datos de los tags HTML.

Una ventaja adicional de crear un nuevo módulo para manipular los tags es que podemos encapsular el uso de la biblioteca =BeautifulSoup=, y eso nos haría más sencillo el poder reemplazarla llegado el caso. Idealmente, no deberíamos hacer referencia a los objetos o clases de =BeautifulSoup= (p.ej. =bs4.elements.Tag=) en el resto de la aplicación.

- [ ] Crear un nuevo módulo =HTML= dentro de =Utils= que tenga la función =html_from_url=

A primera vista, la función =html_from_url= parecería ser una función trivial que quizás no debiera existir. Sin embargo, al encapsular las peticiones HTTP en esta función ganamos la posibilidad de cambiar la dependencia de la biblioteca =requests= en caso que sea necesario. Por ahora la colocamos en el módulo episodes, pero la idea es extraerla en un nuevo módulo =HTML= dentro de =Utils= para poder utilizarla en otras partes de la aplicación. Así podríamos utilizarla, por ejemplo, en la función =podcasts_from_url=.

- [ ] Extraer la función =tags_from_html= al nuevo módulo =utils.html=

Notamos que la función =tags_from_html= está repetida en los módulos Podcasts y Episodes. Esto nos sugiere que habría que hacer un cambio en el diseño para extraer esa lógica común a otro módulo, para eliminar la duplicación de ese código.

- [X] Cambiar el tipo de dato de la fecha del episodio =Episode.date= para que sea un =datetime.date=

- [ ] Revisar el listado de episodios de "Sur les épaules de Darwin" porque está dando URL inválido para un episodio de 2011

#+begin_src txt
AssertionError: received tag has an invalid episode URL
 <button class="replay-button playable" data-clip-type="reecoute" data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-25-juin-2011" data-diffusion-title='"Entendre leurs voix" avec Florence Aubenas' data-diffusion-uuid="136e81f2-a7b2-11e0-b8ee-842b2b72cd1d" data-duration="54 min" data-duration-seconds="3241" data-emission-business-reference="16177" data-emission-title="Sur les épaules de Darwin" data-emission-uuid="6f540125-eb9f-11e1-a7b7-782bcb76618d" data-end-time="1551032275" data-extract-id="" data-extract-title="" data-is-aod="1" data-next-media-info="/get_next_audio/136e81f2-a7b2-11e0-b8ee-842b2b72cd1d" data-start-time="1551029034" data-theme="" data-theme-uuid="" data-url="https://s3-eu-west-1.amazonaws.com/cruiser-production/static/inter/sons/2011/07/s27/carrefour (2).mp3" data-uuid="0962e356-a7b2-11e0-b8ee-842b2b72cd1d" data-xiti-action="C" data-xiti-id="0962e356" data-xiti-level="4" data-xiti-libelle='Reecouter::Sur les épaules de Darwin-"Entendre leurs voix" avec Florence Aubenas-0962e356' data-xiti-trackable="true" data-xiti-type="A" title='réecouter "Entendre leurs voix" avec Florence Aubenas'><svg class="icon replay-button-icon icon-play-player"><use xlink:href="#icon_player-play" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-pause-player"><use xlink:href="#icon_player-pause" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-play"><use xlink:href="#icon_play" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-pause"><use xlink:href="#icon_pause" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-play-disabled"><use xlink:href="#icon_playdisabled" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg><svg class="icon replay-button-icon icon-direct-audio"><use xlink:href="#icon_direct-audio" xmlns:xlink="http://www.w3.org/1999/xlink"></use></svg></button>
#+end_src

- [ ] Refactor de =episodes_from_year=, =episodes_from_month= y =episodes_from_day= para que usen =episodes_between_dates=

- [ ] =autopep8= :: Aplicar el estándar PEP8 a todas las funciones

*** Submódulos
**** Episodes

#+begin_src python :tangle franceinter/episodes/__init__.py
__all__ = [
    "title_from_tag",
    "url_from_tag",
    "date_from_tag",
    "duration_from_tag",
    "episode_from_tag",
    "html_from_url",
    "lastpage_from_html",
    "pages_from_podcast",
    "tags_from_html",
    "episodes_from_response",
    "episodes_from_url",
    "episodes_from_filename",
    "episodes_from_podcast",
    "episodes_with_keyword",
    "episodes_between_dates",
    "episodes_from_year",
    "episodes_from_month",
    "episodes_from_day"
]
#+end_src

**** Tests

#+begin_src python :tangle franceinter/episodes/tests/__init__.py
__all__ = [
    "test_title_from_tag", 
    "test_url_from_tag", 
    "test_date_from_tag", 
    "test_duration_from_tag", 
    "test_episode_from_tag", 
    "test_html_from_url",
    "test_lastpage_from_html",
    "test_pages_from_podcast",
    "test_tags_from_html",
    "test_episodes_from_response", 
    "test_episodes_from_url", 
    "test_episodes_from_filename", 
    "test_episodes_from_podcast", 
    "test_episodes_with_keyword", 
    "test_episodes_between_dates", 
    "test_episodes_from_year", 
    "test_episodes_from_month", 
    "test_episodes_from_day", 
    "examples_title_from_tag",
    "examples_url_from_tag",
    "examples_date_from_tag",
    "examples_duration_from_tag",
    "examples_episode_from_tag",
    "examples_html_from_url",
    "examples_lastpage_from_html",
    "examples_pages_from_podcast",
    "examples_tags_from_html",
    "examples_episodes_from_response",
    "examples_episodes_from_url",
    "examples_episodes_from_filename",
    "examples_episodes_from_podcast",
    "examples_episodes_with_keyword",
    "examples_episodes_between_dates",
    "examples_episodes_from_year",
    "examples_episodes_from_month",
    "examples_episodes_from_day"
]
#+end_src

*** episodes_from_podcast
**** 1. Objetivo

Obtener el listado de episodios de un podcast.

Con el podcast obtiene el listado de páginas y de cada página extrae el listado de episodios.

**** 2. Firma

La función recibe un =franceinter.podcast.Podcast= y devuelve un =GeneratorType= de =franceinter.episodes.Episode=

**** 3. Ejemplos

- Caso exitoso, un podcast válido
- Un podcast con el URL vacío
- Un podcast con el URL inválido
- Un objeto que no es un =franceinter.podcasts.Podcast=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_podcast.py
from franceinter.podcasts.podcast import Podcast

def valid_podcast():
    title = "Sur les epaules de Darwin"
    url = "http://localhost:3000/episode-list.html"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_empty_url():
    title = "Sur les epaules de Darwin"
    url = ""
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_invalid_url():
    title = "Sur les epaules de Darwin"
    url = "ghu:\\{this]url^is((not?valid.com"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def invalid_podcast():
    return "this is not a podcast object"

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_podcast(podcast):
    # validar el podcast
    # obtener el listado de URLs usando pages_from_podcast
    # para cada URL obtener los episodios usando episodes_from_url
    yield episode

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_podcast.py
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.pages_from_podcast import pages_from_podcast
from franceinter.episodes.episodes_from_url import episodes_from_url


def episodes_from_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    pages = pages_from_podcast(podcast)
    for url in pages:
        episodes = episodes_from_url(url)
        for episode in episodes:
            yield episode


def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % str(type(podcast))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un podcast válido, devuelve un =GeneratorType= con los episodios del podcast
- Cuando recibe un podcast con el URL vacío, lanza un =AssertionError=
- Cuando recibe un podcast con el URL inválido, lanza un =AssertionError=
- Cuando recibe un objeto que no es un =franceinter.podcasts.Podcast=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_podcast.py
import types
import pytest
import threading
from franceinter.episodes.episode import Episode
from franceinter.episodes.episodes_from_podcast import episodes_from_podcast
from franceinter.episodes.tests.examples_episodes_from_podcast import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    podcast = valid_podcast()
    episodes = episodes_from_podcast(podcast)
    assert isinstance(episodes, types.GeneratorType)
    for episode in episodes:
        assert isinstance(episode, Episode)

def test_podcast_with_empty_url():
    podcast = podcast_with_empty_url()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    podcast = podcast_with_invalid_url()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

def test_invalid_podcast():
    podcast = invalid_podcast()
    try:
        episodes = list(episodes_from_podcast(podcast))
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_episodes_from_podcast.py
#+end_src

*** episodes_with_keyword
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que contienen una palabra clave en el título

Se debe buscar la palabra clave sin tener encuenta las mayúsculas o minúsculas (case insensitive match)

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y un =str=, y devuelve un =filter= de objetos =franceinter.episodes.Episode=

Para el listado de episodios vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que tienen la palabra clave el título 
- Un listado de 5 episodios en el que ninguno tiene la palabra clave en el título
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Una query que no es un =str=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_with_keyword.py
import random
from franceinter.episodes.episode import Episode

def episodes_with_word_in_title(word):
    episodes = list(some_episodes(3))
    ep = new_episode()
    ep.title+= " " + word
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def some_episodes(how_many):
    for i in range(0, how_many):
        yield new_episode()

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_keyword():
    return 42

def new_episode():
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = "2018-09-12"
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_with_keyword(episodes, keyword):
    # validar que los episodios sean iterables
    # validar que la keyword sea un str
    # validar que cada episodio sea un Episode
    # filtrar los episodios con una función que devuelva true 
    # si el título contiene la palabra clave

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_with_keyword.py
import re
from franceinter.episodes.episode import Episode

def episodes_with_keyword(episodes, keyword):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(keyword, str), invalid_keyword(keyword)
    valid_episodes = filter(is_episode, episodes)
    contains_keyword = keyword_matcher(keyword)
    return filter(contains_keyword, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def keyword_matcher(keyword):
    def matcher(episode):
        return re.search(keyword, episode.title, re.IGNORECASE)
    return matcher
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_keyword(keyword):
    return "keyword parameter must be a string, received %s instead" % type(keyword)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que tienen la palabra clave el título, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno tiene la palabra clave en el título, devuelve un =filter= vacío
- Cuando recibe un listado de podcasts que no es iterable, lanza un =AssertionError=
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Una query que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_with_keyword.py
import types
from franceinter.episodes.episodes_with_keyword import episodes_with_keyword
from franceinter.episodes.tests.examples_episodes_with_keyword import *

def test_episodes_with_word_in_title():
    episodes = episodes_with_word_in_title("radio")
    result = episodes_with_keyword(episodes, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_without_word():
    episodes = some_episodes(5)
    result = episodes_with_keyword(episodes, "radio")
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        result = episodes_with_keyword(episodes, "radio")
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        result = episodes_with_keyword(episodes, "radio")
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_query():
    episodes = some_episodes(10)
    keyword = invalid_keyword()
    try:
        result = episodes_with_keyword(episodes, keyword)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_with_keyword.py
#+end_src

*** episodes_from_year
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados en un año determinado

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y un número entero con el año y devuelve un =filter= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados en un año dado
- Un listado de 5 episodios en el que ninguno fue publicado en un año dado
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Un año que no es un =int=
- Un año que es negativo

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_year.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episode import Episode

def some_episodes_with_year(year):
    other_year = year + 5
    episodes = list(episodes_with_year(3, other_year))
    ep = new_episode(year)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def episodes_with_year(how_many, year):
    for i in range(0, how_many):
        yield new_episode(year)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_year():
    return "This is not a year"

def negative_year():
    return -42

def new_episode(year):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = Date(year, 4, 16)
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_year(episodes, year):
    # validar que los episodios sean iterables
    # validar que el año sea un int > 0
    # filtrar los episodios con una función que devuelva true 
    # si la fecha tiene el año correcto

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_year.py
from franceinter.episodes.episode import Episode

def episodes_from_year(episodes, year):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(year, int), invalid_year(year)
    valid_episodes = filter(is_episode, episodes)
    is_from_year = year_filter(year)
    return filter(is_from_year, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def year_filter(year):
    def matcher(episode):
        return (episode.date.year == year)
    return matcher
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_year(year):
    return "year parameter must be a date, received %s instead" % type(year)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados en un año dado, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado en un año dado, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe un año que no es un =int=, lanza un =AssertionError=
- Cuando recibe un año que es negativo, devuelve un =filter= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_year.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episodes_from_year import episodes_from_year
from franceinter.episodes.tests.examples_episodes_from_year import *

def test_episodes_from_year():
    year = 1987
    episodes = some_episodes_with_year(year)
    result = episodes_from_year(episodes, year)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_from_another_year():
    year = 1987
    episodes = episodes_with_year(5, year)
    another_year = 1948
    result = episodes_from_year(episodes, another_year)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        year = 1987
        result = episodes_from_year(episodes, year)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        year = 1987
        result = episodes_from_year(episodes, year)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_year():
    year = 1987
    episodes = episodes_with_year(5, year)
    inv_year = invalid_year()
    try:
        result = episodes_from_year(episodes, inv_year)
    except AssertionError:
        assert True

def test_negative_year():
    year = 1987
    episodes = episodes_with_year(5, year)
    neg_year = negative_year()
    result = episodes_from_year(episodes, neg_year)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_year.py
#+end_src

*** episodes_from_month
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados en un mes determinado

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y dos números enteros con el año y el mes respectivamente, y devuelve un =filter= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados en un mes dado
- Un listado de 5 episodios en el que ninguno fue publicado en un mes dado
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Un año que no es un =int=
- Un mes que no es un =int=
- Un año que es negativo
- Un mes que es negativo
- Un mes que es mayor a 12

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_month.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episode import Episode

def some_episodes_with_month(year, month):
    other_year = year + 5
    episodes = list(episodes_with_month(3, other_year, month))
    ep = new_episode(year, month)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def episodes_with_month(how_many, year, month):
    for i in range(0, how_many):
        yield new_episode(year, month)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_year():
    return "This is not a year"

def invalid_month():
    return "This is not a month"

def new_episode(year, month):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = Date(year, month, 16)
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_month(episodes, year, month):
    # validar que los episodios sean iterables
    # validar que el año sea un int > 0
    # validar que el mes sea un int entre 1 y 12
    # filtrar los episodios con una función que devuelva true 
    # si la fecha tiene el mes correcto

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_month.py
from franceinter.episodes.episode import Episode

def episodes_from_month(episodes, year, month):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(year, int), invalid_year(year)
    assert month_is_valid(month), invalid_month(month)
    valid_episodes = filter(is_episode, episodes)
    is_from_month = month_filter(year, month)
    return filter(is_from_month, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def month_filter(year, month):
    def matcher(episode):
        return (
            (episode.date.year == year)
            and (episode.date.month == month)
        )
    return matcher
    
def month_is_valid(month):
    return (
        isinstance(month, int) 
        and (month > 0)
        and (month < 13)
    )
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_year(year):
    return "year parameter must be an int, received %s instead" % type(year)

def invalid_month(month):
    return "month parameter must be an int bewtween 1 and 12, received %s instead" % str(month)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados en un mes dado, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado en un mes dado, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe un año que no es un =int=, lanza un =AssertionError=
- Cuando recibe un año que es negativo, devuelve un =filter= vacío
- Cuando recibe un mes que no es un =int=, lanza un =AssertionError=
- Cuando recibe un mes que no está entre 1 y 12, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_month.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episodes_from_month import episodes_from_month
from franceinter.episodes.tests.examples_episodes_from_month import *

def test_episodes_from_month():
    year = 1987
    month = 2
    episodes = some_episodes_with_month(year, month)
    result = episodes_from_month(episodes, year, month)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_from_another_month():
    year = 1987
    month = 5
    episodes = episodes_with_month(5, year, month)
    another_year = 1948
    result = episodes_from_month(episodes, another_year, month)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        year = 1987
        month = 4
        result = episodes_from_month(episodes, year, month)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        year = 1987
        month = 4
        result = episodes_from_month(episodes, year, month)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_year():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    inv_year = invalid_year()
    try:
        result = episodes_from_month(episodes, inv_year, month)
    except AssertionError:
        assert True

def test_negative_year():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    neg_year = -998
    result = episodes_from_month(episodes, neg_year, month)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_invalid_month():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    inv_month = invalid_month()
    try:
        result = episodes_from_month(episodes, year, inv_month)
    except AssertionError:
        assert True

def test_negative_month():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    negative_month = -5
    try:
        result = episodes_from_month(episodes, year, negative_month)
    except AssertionError:
        assert True

def test_month_over_12():
    year = 1987
    month = 4
    episodes = episodes_with_month(5, year, month)
    month_over_12 = 18
    try:
        result = episodes_from_month(episodes, year, month_over_12)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_month.py
#+end_src

*** episodes_from_day
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados en un día determinado

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y tres números enteros con el año, el mes y el día respectivamente, y devuelve un =filter= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados en un día dado
- Un listado de 5 episodios en el que ninguno fue publicado en un día dado
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Un año que no es un =int=
- Un mes que no es un =int=
- Un día que no es un =int=
- Un año que es negativo
- Un mes que es negativo
- Un día que es negativo
- Un mes que es mayor a 12
- Un día que es mayor a 31

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_day.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episode import Episode

def some_episodes_with_day(year, month, day):
    other_year = year + 5
    episodes = list(episodes_with_day(3, other_year, month, day))
    ep = new_episode(year, month, day)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def episodes_with_day(how_many, year, month, day):
    for i in range(0, how_many):
        yield new_episode(year, month, day)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_year():
    return "This is not a year"

def invalid_month():
    return "This is not a month"

def invalid_day():
    return "This is not a day"

def new_episode(year, month, day):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = Date(year, month, day)
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_day(episodes, year, month, day):
    # validar que los episodios sean iterables
    # validar que el año sea un int > 0
    # validar que el mes sea un int entre 1 y 12
    # validar que el mes sea un int entre 1 y 31
    # filtrar los episodios con una función que devuelva true 
    # si la fecha tiene el día correcto

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_day.py
from franceinter.episodes.episode import Episode

def episodes_from_day(episodes, year, month, day):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(year, int), invalid_year(year)
    assert month_is_valid(month), invalid_month(month)
    assert day_is_valid(day), invalid_day(day)
    valid_episodes = filter(is_episode, episodes)
    is_from_day = day_filter(year, month, day)
    return filter(is_from_day, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def day_filter(year, month, day):
    def matcher(episode):
        return (
            (episode.date.year == year)
            and (episode.date.month == month)
            and (episode.date.day == day)
        )
    return matcher
    
def month_is_valid(month):
    return (
        isinstance(month, int) 
        and (month > 0)
        and (month < 13)
    )

def day_is_valid(day):
    return (
        isinstance(day, int) 
        and (day > 0)
        and (day < 32)
    )
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_year(year):
    return "year parameter must be an int, received %s instead" % type(year)

def invalid_month(month):
    return "month parameter must be an int bewtween 1 and 12, received %s instead" % str(month)

def invalid_day(day):
    return "day parameter must be an int bewtween 1 and 31, received %s instead" % str(day)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados en un mes dado, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado en un mes dado, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe un año que no es un =int=, lanza un =AssertionError=
- Cuando recibe un año que es negativo, devuelve un =filter= vacío
- Cuando recibe un mes que no es un =int=, lanza un =AssertionError=
- Cuando recibe un mes que no está entre 1 y 12, lanza un =AssertionError=
- Cuando recibe un día que no es un =int=, lanza un =AssertionError=
- Cuando recibe un día que no está entre 1 y 31, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_day.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episodes_from_day import episodes_from_day
from franceinter.episodes.tests.examples_episodes_from_day import *

def test_episodes_from_day():
    year = 1987
    month = 2
    day = 23
    episodes = some_episodes_with_day(year, month, day)
    result = episodes_from_day(episodes, year, month, day)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_from_another_day():
    year = 1987
    month = 5
    day = 21
    episodes = episodes_with_day(5, year, month, day)
    another_year = 1948
    result = episodes_from_day(episodes, another_year, month, day)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        year = 1987
        month = 4
        day = 7
        result = episodes_from_day(episodes, year, month, day)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        year = 1987
        month = 4
        day = 7
        result = episodes_from_day(episodes, year, month, day)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_year():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    inv_year = invalid_year()
    try:
        result = episodes_from_day(episodes, inv_year, month, day)
    except AssertionError:
        assert True

def test_negative_year():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    neg_year = -998
    result = episodes_from_day(episodes, neg_year, month, day)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_invalid_month():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    inv_month = invalid_month()
    try:
        result = episodes_from_day(episodes, year, inv_month, day)
    except AssertionError:
        assert True

def test_negative_month():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    negative_month = -5
    try:
        result = episodes_from_day(episodes, year, negative_month, day)
    except AssertionError:
        assert True

def test_month_over_12():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    month_over_12 = 18
    try:
        result = episodes_from_day(episodes, year, month_over_12, day)
    except AssertionError:
        assert True

def test_invalid_day():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    inv_day = invalid_day()
    try:
        result = episodes_from_day(episodes, year, month, inv_day)
    except AssertionError:
        assert True

def test_negative_day():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    negative_day = -5
    try:
        result = episodes_from_day(episodes, year, month, negative_day)
    except AssertionError:
        assert True

def test_day_over_31():
    year = 1987
    month = 4
    day = 7
    episodes = episodes_with_day(5, year, month, day)
    day_over_31 = 43
    try:
        result = episodes_from_day(episodes, year, month, day_over_31)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_day.py
#+end_src

*** episodes_between_dates
**** 1. Objetivo

Filtrar un listado de episodios y obtener solamente los que fueron publicados entre dos fechas

**** 2. Firma

La función recibe un listado de objetos =franceinter.episodes.Episode= y dos objetos =datetime.date= (de inicio y fin del intervalo), y devuelve un =filter= de objetos =franceinter.episodes.Episode=

Para el listado de episodios vamos a recibir cualquier objeto que sea iterable, como por ejemplo un =list= o un =GeneratorType=

**** 3. Ejemplos

- Un listado de 5 episodios en el que hay 2 que fueron publicados entre las fechas dadas
- Un listado de 5 episodios en el que ninguno fue publicado entre las fechas dadas
- Un listado de episodios que no es iterable
- Un listado de episodios que no tiene objetos =franceinter.episodes.Episode=
- Una fecha de inicio que no es un =datetime.date=
- Una fecha de fin que no es un =datetime.date=
- Una fecha de inicio que es posterior a la fecha de fin

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_between_dates.py
import random
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episode import Episode

def some_episodes_between_dates(starting_at, ending_at):
    date_outside = ending_at + TimeDelta(days=5)
    episodes = list(some_episodes_with_date(3, date_outside))
    date_between = random_date_between(starting_at, ending_at)
    ep = new_episode(date_between)
    episodes.append(ep)
    episodes.append(ep)
    random.shuffle(episodes)
    return episodes

def random_date_between(date1, date2):
    days = (date2 - date1).days
    random_days = random.randint(0, days)
    random_date = date1 + TimeDelta(days=random_days)
    return random_date

def some_episodes_with_date(how_many, episode_date):
    for i in range(0, how_many):
        yield new_episode(episode_date)

def episodes_not_iterable():
    return 42
        
def invalid_episodes():
    return range(0,10)

def invalid_date():
    return 42

def new_episode(episode_date):
    title = "Este es un episodio de ejemplo"
    url = "http://podcastplace.com/shows/my-podcast/season-01-episode-01.mp3"
    date = str(episode_date)
    duration = 3265
    return Episode(title, url, date, duration)

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_between_dates(episodes, starting_at, ending_at):
    # validar que los episodios sean iterables
    # validar que las fechas sean datetime.date
    # validar que cada episodio sea un Episode
    # filtrar los episodios con una función que devuelva true 
    # si la fecha está entre starting_at y ending_at

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_between_dates.py
from datetime import date as Date, datetime as DateTime
from franceinter.episodes.episode import Episode

def episodes_between_dates(episodes, starting_at, ending_at):
    try:
        it = iter(episodes)
    except TypeError:
        assert False, invalid_episodes(episodes)
    assert isinstance(starting_at, Date), invalid_date(starting_at)
    assert isinstance(ending_at, Date), invalid_date(ending_at)
    valid_episodes = filter(is_episode, episodes)
    is_between_dates = date_filter(starting_at, ending_at)
    return filter(is_between_dates, valid_episodes)

def is_episode(episode):
    assert isinstance(episode, Episode), invalid_episode(episode)
    return True
    
def date_filter(starting_at, ending_at):
    def matcher(episode):
        episode_date = DateTime.strptime(episode.date, "%Y-%m-%d").date()
        return ((starting_at <= episode_date) 
                and (episode_date <= ending_at))
    return matcher
    
def invalid_episodes(episodes):
    return "episodes parameter must be iterable, received %s instead" % type(episodes)

def invalid_date(date):
    return "starting_at and ending_at parameters must be a date, received %s instead" % type(date)

def invalid_episode(episode):
    return "episode parameter must be an Episode, received %s instead" % type(episode)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un listado de 5 episodios en el que hay 2 que fueron publicados entre las fechas dadas, devuelve un =filter= con los 2 episodios que cumplen la condición
- Cuando recibe un listado de 5 episodios en el que ninguno fue publicado entre las fechas dadas, devuelve un =filter= vacío
- Cuando recibe un listado de episodios que no es iterable, lanza un =AssertionError=
- Cuando recibe un listado de episodios que no tiene objetos =franceinter.episodes.Episode=, lanza un =AssertionError=
- Cuando recibe una fecha de inicio que no es un =datetime.date=, lanza un =AssertionError=
- Cuando recibe una fecha de fin que no es un =datetime.date=, lanza un =AssertionError=
- Cuando recibe una fecha de inicio que es posterior a la fecha de fin, devuelve un =filter= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_between_dates.py
import types
from datetime import date as Date, timedelta as TimeDelta
from franceinter.episodes.episodes_between_dates import episodes_between_dates
from franceinter.episodes.tests.examples_episodes_between_dates import *

def test_episodes_between_dates():
    starting_at = Date.today()
    ending_at = Date.today() + TimeDelta(days=5)
    episodes = some_episodes_between_dates(starting_at, ending_at)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 2)

def test_episodes_outside_interval():
    date_outside = Date.today() - TimeDelta(days=30)
    episodes = some_episodes_with_date(5, date_outside)
    starting_at = Date.today()
    ending_at = Date.today() + TimeDelta(days=5)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

def test_episodes_not_iterable():
    episodes = episodes_not_iterable()
    try:
        starting_at = Date.today()
        ending_at = Date.today() + TimeDelta(days=5)
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_episodes():
    episodes = invalid_episodes()
    try:
        starting_at = Date.today()
        ending_at = Date.today() + TimeDelta(days=5)
        result = episodes_between_dates(episodes, starting_at, ending_at)
        assert (len(list(result)) == 0)
    except AssertionError:
        assert True

def test_invalid_starting_date():
    episode_date = Date.today() + TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = invalid_date()
    ending_at = Date.today() + TimeDelta(days=5)
    try:
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_ending_date():
    episode_date = Date.today() + TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = Date.today()
    ending_at = invalid_date()
    try:
        result = episodes_between_dates(episodes, starting_at, ending_at)
    except AssertionError:
        assert True

def test_invalid_interval():
    episode_date = Date.today() - TimeDelta(days=2)
    episodes = some_episodes_with_date(5, episode_date)
    starting_at = Date.today()
    ending_at = Date.today() - TimeDelta(days=5)
    result = episodes_between_dates(episodes, starting_at, ending_at)
    assert isinstance(result, filter)
    assert (len(list(result)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_between_dates.py
#+end_src

*** episodes_from_url
**** 1. Objetivo

Extraer el listado de episodios desde un URL

**** 2. Firma

La función recibe un URL y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un URL con el listado de episodios
- Un URL de otra página, que no tiene episodios
- Un URL de una página inexistente, que dispare un error 404 (not found)
- Un URL de un sitio inexistente, que dispare un error de DNS
- Un URL inválido

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_url.py

def url_ok():
    url = "http://localhost:3000/episode-list.html"
    return url

def wrong_page_url():
    url = "http://localhost:3000/wrong-page.html"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def wrong_site_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

def invalid_url():
    url = "ht pt:\\hostlocal:3000/this-url-is-not-valid.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_url(url):
    # validar el url
    # realizar una petición al url
    # obtener la respuesta del url
    # obtener los episodes llamando a episodes_from_response
    # revisar si da un error de conexión
    return episodes

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_url.py
import requests
from validators.url import url as is_valid_url
from franceinter.episodes.episodes_from_response import episodes_from_response

def episodes_from_url(url):
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        episodes = episodes_from_response(response)
        return episodes
    except requests.ConnectionError:
        assert False, connection_error(url)

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url
#+end_src

**** 6. Casos de prueba

- Cuando recibe un URL con el listado de episodios, devuelve un =GeneratorType= de objetos =Episode=
- Cuando recibe un URL de otra página, que no tiene episodios, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de una página inexistente, devuelve un =GeneratorType= vacío
- Cuando recibe un URL de un sitio inexistente (error de DNS), lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_url.py
import pytest
import threading
import types
from franceinter.episodes.episode import Episode
from franceinter.episodes.episodes_from_url import episodes_from_url
from franceinter.episodes.tests.examples_episodes_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = url_ok()
    gen = episodes_from_url(url)
    assert isinstance(gen, types.GeneratorType)
    episodes = list(gen)
    assert (len(episodes) > 0)
    for e in episodes:
        assert isinstance(e, Episode)

def test_wrong_page_url(http_server):
    url = wrong_page_url()
    episodes = list(episodes_from_url(url))
    assert (len(episodes) == 0)

def test_not_found_url(http_server):
    url = not_found_url()
    episodes = list(episodes_from_url(url))
    assert (len(episodes) == 0)

@pytest.mark.skip(reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = wrong_site_url()
    try:
        episodes = list(episodes_from_url(url))
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        episodes = episodes_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_url.py
#+end_src

*** episodes_from_response
**** 1. Objetivo

Extraer el listado de episodios de la respuesta de una petición HTTP

**** 2. Firma

La función recibe una =requests.model.Response= y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Una respuesta válida, con el HTML de una página del listado de episodios
- Una respuesta inválida, que no es de la clase =requests.model.Response=
- Una respuesta válida, pero que tiene el HTML de otra página

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_response.py
from requests.models import Response

def response_ok():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/episode-list.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

def invalid_response():
    return "i am not a Response"

def wrong_page_response():
    resp = Response()
    resp.status_code = 200
    filename = "./franceinter/html/wrong-page.html" 
    with open(filename, "rb") as f:
        resp._content = f.read()
    return resp

#+end_src

**** 4. Boceto

#+begin_src python
import requests

def episodes_from_response(resp):
    # validar la respuesta
    # obtener el HTML de resp.text
    # extraer los tags usando tags_from_html
    # obtener los podcasts usando episodes_from_tags

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_response.py
import requests
from franceinter.episodes.tags_from_html import tags_from_html
from franceinter.episodes.episodes_from_tags import episodes_from_tags

def episodes_from_response(resp):
    assert isinstance(resp, requests.models.Response), invalid_type(resp)
    html = resp.text
    tags = tags_from_html(html)
    episodes = episodes_from_tags(tags)
    return episodes
    
def invalid_type(resp):
    return "resp parameter must be a requests.models.Response, received %s instead" % type(resp)

#+end_src

**** 6. Casos de prueba

- Cuando recibe una respuesta válida, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Cuando recibe una respuesta que no es de la clase =requests.model.Response=, lanza un =AssertionError=
- Cuando recibe una respuesta válida que tiene el HTML de otra página, devuelve un =GeneratorType= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_response.py
import types
from franceinter.episodes.episode import Episode
from franceinter.episodes.episodes_from_response import episodes_from_response
from franceinter.episodes.tests.examples_episodes_from_response import *

def test_response_ok():
    resp = response_ok()
    episodes = episodes_from_response(resp)
    assert isinstance(episodes, types.GeneratorType)
    for e in episodes:
        assert isinstance(e, Episode)

def test_invalid_response():
    resp = invalid_response()
    try:
        episodes = episodes_from_response(resp)
    except AssertionError:
        assert True
    
def test_wrong_page_response():
    resp = wrong_page_response()
    episodes = episodes_from_response(resp)
    assert isinstance(episodes, types.GeneratorType)
    assert (len(list(episodes)) == 0)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_response.py
#+end_src

*** episodes_from_filename
**** 1. Objetivo

Extraer un listado de episodios desde un archivo

**** 2. Firma

La función recibe un =str= con el nombre del archivo y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

**** 3. Ejemplos

- Un archivo HTML que tiene un listado de episodios
- Un archivo HTML de otra página, que no tiene episodios
- Un archivo que no existe
- Un nombre de archivo que no es un =str=

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_filename.py

def ok_filename():
    return "./franceinter/html/episode-list.html"

def wrong_filename():
    return "./franceinter/html/wrong-page.html"

def not_found_filename():
    return "./franceinter/html/this-file-does-not-exist.html"

def invalid_filename():
    return [1, 2, 3]

#+end_src

**** 4. Boceto

#+begin_src python

def episodes_from_filename(filename):
    # validar que filename sea un str
    # validar que el archivo exista
    episodes = []
    # crear un requests.models.Response con el contenido del archivo
    # obtener los episodios llamando a episodes_from_response
    return episodes
     
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_filename.py
from requests.models import Response
from franceinter.episodes.episodes_from_response import episodes_from_response

def episodes_from_filename(filename):
    assert isinstance(filename, str), invalid_filename(filename)
    resp = Response()
    episodes = []
    try:
        with open(filename, "rb") as f:
            resp._content = f.read()
            episodes = episodes_from_response(resp)
    except (OSError, IOError) as error:
        assert False, not_found(filename, error)
    return episodes

def invalid_filename(filename):
    return "filename parameter must be a str, %s received instead" % filename

def not_found(filename, error):
    return "filename %s cannot be read, thrown error :\n%s" % (filename, error)
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un archivo HTML que tiene un listado de podcasts, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Cuando recibe un archivo HTML de otra página, que no tiene podcasts, devuelve un =GeneratorType= vacío
- Cuando recibe un archivo que no existe, lanza un =AssertionError=
- Cuando recibe un nombre de archivo que no es un =str=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_filename.py
import types
from franceinter.episodes.episode import Episode
from franceinter.episodes.episodes_from_filename import episodes_from_filename
from franceinter.episodes.tests.examples_episodes_from_filename import *

def test_ok_filename():
    filename = ok_filename()
    episodes = episodes_from_filename(filename)
    assert isinstance(episodes, types.GeneratorType)
    episodes = list(episodes)
    assert (len(episodes) > 0)
    for e in episodes:
        assert isinstance(e, Episode)

def test_wrong_filename():
    filename = wrong_filename()
    episodes = episodes_from_filename(filename)
    assert isinstance(episodes, types.GeneratorType)
    episodes = list(episodes)
    assert (len(episodes) == 0)

def test_not_found_filename():
    filename = not_found_filename()
    try:
        episodes = episodes_from_filename(filename)
    except AssertionError:
        assert True

def test_invalid_filename():
    filename = invalid_filename()
    try:
        episodes = episodes_from_filename(filename)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_episodes_from_filename.py
#+end_src

#+RESULTS:
:results:
:end:

*** episodes_from_tags
**** 1. Objetivo

Generar un listado de episodios a partir de un listado de fragmentos de HTML tomados de la página

**** 2. Firma

La función recibe un listado de objetos =bs4.element.Tag= y devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=

Vamos a aceptar tanto un =list= como un =GeneratorType=

**** 3. Ejemplos

- Un objeto que no es iterable
- Una lista vacía
- Una lista con tags válidos
- Una lista con objetos que no son del tipo =bs4.element.Tag=
- Una lista con tags válidos y un tag inválido (sin el título o el URL)

#+begin_src python :tangle franceinter/episodes/tests/examples_episodes_from_tags.py
import random
from franceinter.episodes.tags_from_html import tags_from_html
from franceinter.episodes.tests.examples_episode_from_tag import (
    tag_ok,
    tag_without_title
)

def invalid_list():
    return 123

def empty_list():
    return []

def list_without_tags():
    return [1, 2, 3, 4, 5]

def list_with_valid_tags(how_many):
    html = "<div class='diffusions-list'>"
    for i in range(1, how_many):
        html+= str(tag_ok())
    html+= "</div>"
    tags = tags_from_html(html)
    return tags

def list_with_invalid_tag(how_many):
    tags = list(list_with_valid_tags(how_many - 1))
    tags.append(tag_without_title())
    random.shuffle(tags)
    return tags

#+end_src

**** 4. Boceto

#+begin_src python
from franceinter.episodes.tags_from_html import tags_from_html

def podcasts_from_tags(tags):
    # validar que tags sea un GeneratorType
    # para cada tag de la lista
    # usar episode_from_tag() para obtener un podcast
    # yield posdcast

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/episodes_from_tags.py
from franceinter.episodes.episode_from_tag import episode_from_tag

def episodes_from_tags(tags):
    try:
        it = iter(tags)
    except TypeError:
        assert False, invalid_tags(tags)
    for tag in tags:
        yield episode_from_tag(tag)

def invalid_tags(tags):
    return "tags parameter must be iterable, received %s instead" % type(tags)
#+end_src

**** 6. Casos de prueba

- Si recibe un objeto que no es iterable, lanza un =AssertionError=
- Si recibe una lista vacía, devuelve un =GeneratorType= vacío
- Si recibe una lista de tags válidos, devuelve un =GeneratorType= de objetos =franceinter.episodes.Episode=
- Si recibe una lista con objetos que no son del tipo =bs4.element.Tag=, lanza un =AssertionError=
- Si recibe una lista con algún tag inválido (que no tenga el título o el URL), lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episodes_from_tags.py
import types
from franceinter.episodes.episodes_from_tags import episodes_from_tags
from franceinter.episodes.tests.examples_episodes_from_tags import *
from franceinter.episodes.episode import Episode

def test_invalid_list():
    tags = invalid_list()
    try:
        episodes = list(episodes_from_tags(tags))
    except AssertionError:
        assert True

def test_empty_list():
    tags = empty_list()
    episodes = episodes_from_tags(tags)
    assert isinstance(episodes, types.GeneratorType)
    assert (len(list(episodes))==0)

def test_list_with_valid_tags():
    tags = list_with_valid_tags(6)
    episodes = episodes_from_tags(tags)
    assert isinstance(episodes, types.GeneratorType)
    for e in episodes:
        assert (isinstance(e, Episode))

def test_list_without_tags():
    tags = list_without_tags()
    try:
        episodes = list(episodes_from_tags(tags))
    except AssertionError:
        assert True

def test_list_with_invalid_tag():
    tags = list_with_invalid_tag(6)
    episodes = episodes_from_tags(tags)
    try:
        for e in episodes:
            assert (isinstance(e, Episode))
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episodes_from_tags.py
#+end_src

*** pages_from_podcast
**** 1. Objetivo

Obtener un listado de URLs de las páginas del listado de episodios a partir de los datos de un podcast.

**** 2. Firma

La función recibe un objeto =franceinter.podcasts.Podcast= y devuelve un =GeneratorType= con los URLs de las páginas del historial de episodios.

**** 3. Ejemplos

- Caso exitoso, un podcast válido
- Un podcast con el URL vacío
- Un podcast con el URL inválido
- Un objeto que no es un =franceinter.podcasts.Podcast=

#+begin_src python :tangle franceinter/episodes/tests/examples_pages_from_podcast.py
from franceinter.podcasts.podcast import Podcast

def valid_podcast():
    title = "Sur les epaules de Darwin"
    url = "http://localhost:3000/episode-list.html"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_empty_url():
    title = "Sur les epaules de Darwin"
    url = ""
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def podcast_with_invalid_url():
    title = "Sur les epaules de Darwin"
    url = "ghu:\\{this]url^is((not?valid.com"
    author = "Jean-Claude Ameisen"
    return Podcast(title, url, author)

def invalid_podcast():
    return "this is not a podcast object"

#+end_src

**** 4. Boceto

#+begin_src python

def pages_from_podcast(podcast):
    # validar que el podcast sea una instancia de Podcast
    # validar el url
    # obtener el HTML del URL
    # obtener el número de la última página del HTML
    # generar los URLs de las páginas agregando ?p=XX al URL del podcast
    yield page_url

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/pages_from_podcast.py
from franceinter.podcasts.podcast import Podcast
from franceinter.episodes.html_from_url import html_from_url
from franceinter.episodes.lastpage_from_html import lastpage_from_html

def pages_from_podcast(podcast):
    assert isinstance(podcast, Podcast), invalid_podcast(podcast)
    html = html_from_url(podcast.url)
    lastpage = lastpage_from_html(html)
    for page_number in range(1, lastpage + 1):
        page_url = podcast.url + "?p=" + str(page_number)
        yield page_url

def invalid_podcast(podcast):
    return "podcast parameter must be a Podcast, received %s instead" % str(type(podcast))

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un podcast válido, devuelve un =GeneratorType= con los URLs de las páginas del podcast
- Cuando recibe un podcast con el URL vacío, lanza un =AssertionError=
- Cuando recibe un podcast con el URL inválido, lanza un =AssertionError=
- Cuando recibe un objeto que no es un =franceinter.podcasts.Podcast=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_pages_from_podcast.py
import types
import pytest
import threading
from validators.url import url as is_valid_url
from franceinter.episodes.pages_from_podcast import pages_from_podcast
from franceinter.episodes.tests.examples_pages_from_podcast import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    podcast = valid_podcast()
    pages = pages_from_podcast(podcast)
    assert isinstance(pages, types.GeneratorType)
    for page in pages:
        assert is_valid_url(page)

def test_podcast_with_empty_url():
    podcast = podcast_with_empty_url()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    podcast = podcast_with_invalid_url()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

def test_invalid_podcast():
    podcast = invalid_podcast()
    try:
        pages = list(pages_from_podcast(podcast))
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_pages_from_podcast.py
#+end_src

*** lastpage_from_html
**** 1. Objetivo

Obtener la cantidad de páginas del HTML del listado de episodios.

En el HTML del listado de episodios de un podcast hay un paginador donde podemos encontrar la cantidad total de páginas, buscando un tag =<li>= que tiene la clase =last=. Dentro de ese =<li>= hay un link a la última página, que se encuentra en el atributo =href=. 

**** 2. Firma

La función recibe un =str= con el HTML y devuelve un =int= con el número de la última página.

**** 3. Ejemplos

- Caso exitoso, un HTML con el tag =<li>= que tiene la clase =last= y el =<a>= con el atributo =href= correcto
- Un HTML que no es un =str=
- Un HTML que no tiene el tag =<li>=
- Un HTML que tiene el tag =<li>=, pero éste no tiene la clase =last=
- Un HTML que tiene el tag =<li>= con la clase =last=, pero éste no tiene el =<a>=

#+begin_src python :tangle franceinter/episodes/tests/examples_lastpage_from_html.py

def html_ok():
    html = '''<div>
<li class="pager-item last">
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

def invalid_html():
    return 4321

def html_without_item():
    html = '''<div>
<span class="pager-item last">
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</span>
    </div>'''
    return html

def html_without_class():
    html = '''<div>
<li>
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

def html_without_link():
    html = '''<div>
<li>
    <a href="/emissions/sur-les-epaules-de-darwin?p=22"
    title="Aller à la denière page"> >>
    </a>
</li>
    </div>'''
    return html

#+end_src

**** 4. Boceto

#+begin_src python

def lastpage_from_html(html):
    # validar que el html sea un str
    # buscar un <li> con la clase =last=
    # si existe buscar dentro un <a> y extraer el atributo "href"
    # extraer al final del href uno o más números [0-9]
    lastpage = 1
    return lastpage

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/lastpage_from_html.py
from bs4 import BeautifulSoup
import re

def lastpage_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    lastpage = 1
    item = soup.find("li", class_="last")
    if item:
        href = item.find("a").attrs["href"]
        match = re.search("([0-9]+)$", href)
        if match:
            lastpage = int(match.groups()[0])
    return lastpage
     
def invalid_html(html):
    return "html parameter must be a string, %s received" % str(type(html))

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un HTML con el tag =<li>= que tiene la clase =last=, devuelve el número de la última página
- Cuando recibe un HTML que no es un =str=, lanza un =AssertionError=
- Cuando recibe un HTML que no tiene el tag =<li>=, devuelve la primera página (=1=)
- Cuando recibe un HTML que tiene el tag =<li>=, pero éste no tiene la clase =last=, devuelve la primera página (=1=)
- Cuando recibe un HTML que tiene el tag =<li>= con la clase =last=, pero éste no tiene el =<a>=, devuelve la primera página (=1=)

#+begin_src python :tangle franceinter/episodes/tests/test_lastpage_from_html.py
from franceinter.episodes.lastpage_from_html import lastpage_from_html
from franceinter.episodes.tests.examples_lastpage_from_html import *

def test_html_ok():
    html = html_ok()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 22)

def test_invalid_html():
    html = invalid_html()
    try:
        lastpage = lastpage_from_html(html)
    except AssertionError:
        assert True

def test_html_without_item():
    html = html_without_item()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

def test_html_without_class():
    html = html_without_class()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

def test_html_without_link():
    html = html_without_link()
    lastpage = lastpage_from_html(html)
    assert (lastpage == 1)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_lastpage_from_html.py
#+end_src

*** html_from_url
**** 1. Objetivo

Obtener el HTML de un URL

**** 2. Firma

La función recibe un =str= con un URL válido y devuelve otro =str= con el HTML del URL

**** 3. Ejemplos

- Caso exitoso, un URL válido
- Un URL que no es un =str=
- Un URL inválido
- Un URL válido, pero que causa un =ConnectionError= porque el host no existe
- Un URL válido, pero de una página que no existe

#+begin_src python :tangle franceinter/episodes/tests/examples_html_from_url.py

def valid_url():
    url = "http://localhost:3000/episode-list.html"
    return url

def not_str_url():
    url = 1234
    return url

def invalid_url():
    url = "ghu:\\{this]url^is((not?valid.com"
    return url

def not_found_url():
    url = "http://localhost:3000/this-page-does-not-exist.html"
    return url

def connection_error_url():
    url = "http://host.local:3000/this-page-does-not-exist.html"
    return url

#+end_src

**** 4. Boceto

#+begin_src python

def html_from_url(url):
    # validar el URL
    # ejecutar la petición HTTP
    # si no hay error de conexión
    # devolver el texto de la respuesta

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/html_from_url.py
import requests
from validators.url import url as is_valid_url

def html_from_url(url):
    assert isinstance(url, str), invalid_str(url)
    assert is_valid_url(url), invalid_url(url)
    try:
        response = requests.get(url)
        return response.text
    except requests.ConnectionError:
        assert False, connection_error(url)
        
def invalid_str(url):
    return "url parameter must be string, received %s instead" % str(type(url))

def invalid_url(url):
    return "url parameter must be a valid URL, received %s instead" % url

def connection_error(url):
    return "request to %s failed with a connection error" % url

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un URL válido devuelve el HTML de la página
- Cuando recibe un URL que no es un =str=, lanza un =AssertionError=
- Cuando recibe un URL inválido, lanza un =AssertionError=
- Cuando recibe un URL válido pero cuyo host no existe, lanza un =AssertionError=
- Cuando recibe un URL válido pero cuya página, devuelve un =str= vacío

#+begin_src python :tangle franceinter/episodes/tests/test_html_from_url.py
import re
import pytest
import threading
from franceinter.episodes.html_from_url import html_from_url
from franceinter.episodes.tests.examples_html_from_url import *
from utils.http_server import LocalFolderHTTPServer as HTTPServer

def test_url_ok(http_server):
    url = valid_url()
    html = html_from_url(url)
    assert isinstance(html, str)
    assert (len(html) > 0)

def test_not_str_url(http_server):
    url = not_str_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True

def test_invalid_url():
    url = invalid_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True

def test_not_found_url(http_server):
    url = not_found_url()
    html = html_from_url(url)
    assert re.search("NOT_FOUND", html)

@pytest.mark.skip(reason="Slow test (~10 sec) waiting for DNS error")
def test_wrong_site_url(http_server):
    url = connection_error_url()
    try:
        html = html_from_url(url)
    except AssertionError:
        assert True

@pytest.fixture(scope="module")
def http_server():
    web_dir = './franceinter/html'
    httpd = HTTPServer(web_dir, ("", 3000))
    threading.Thread(target=httpd.serve_forever).start()
    yield httpd
    httpd.shutdown()

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_html_from_url.py
#+end_src

*** tags_from_html
**** 1. Objetivo

Obtener un array de tags con los fragmentos de html que tienen el detalle del episodio (título, URL, fecha de emisión y duración) a partir del html de la página con el listado de episodios.

Hay que extraer todos los =<button>= que tengan la clase =replay-button= y que estén dentro de un =<div>= que tiene clase =diffusions-list=. Necesitamos extraer solamente los botones que están dentro de este div porque en el HTML de la página hay otros botones que son de otros podcasts.

**** 2. Firma

La función recibe un =str= con el html de la página y devuelve un =GeneratorType= de elementos =bs4.element.Tag=

**** 3. Ejemplos

- Un html que tiene un =<div>= con la clase buscada y que contiene varios =<button>= con la clase =replay-button=
- Un html que no es un =str=
- Un html que no tiene ningún =<div>=
- Un html que tiene varios =<div>= pero que ninguno tiene la clase =diffusions-list=
- Un html que tiene un =<div>= con la clase buscada y que contiene algunos =<buttons>= con la clase =replay-button= y otros que no la tienen

#+begin_src python :tangle franceinter/episodes/tests/examples_tags_from_html.py
from bs4 import BeautifulSoup
import random

def html_with_buttons(how_many):
    btn_class = "replay-button"
    buttons = map(lambda x: button("click here", btn_class), range(how_many))
    cls_name = "diffusions-list"
    return html(buttons, cls_name)

def html_is_not_string():
    return 42

def html_without_divs():
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>'''
    return html

def html_divs_without_class(how_many):
    content = "blablabla"
    divs = map(lambda x: div(content), range(how_many))
    return html(divs)

def html_some_buttons_with_class(how_many_with, how_many_without):
    cls = "replay-button"
    buttons_with = list(map(lambda x: button("click here", cls), range(how_many_with)))
    buttons_without = list(map(lambda x: button("click here"), range(how_many_without)))
    buttons = buttons_with + buttons_without
    random.shuffle(buttons)
    class_name = "diffusions-list"
    return html(buttons, class_name)

def button(content, class_name=""):
    attr = ""
    if class_name:
        attr = 'class="%s"' % class_name
    html = '''<button %s>%s</button>''' % (attr, content)
    soup = BeautifulSoup(html, "html.parser")
    return soup.button

def div(content):
    html = '''<div>%s</div>''' % content
    soup = BeautifulSoup(html, "html.parser")
    return soup.div

def html(elements, class_name=""):
    attr = ""
    if class_name:
        attr = 'class="%s"' % class_name
    content = "".join(map(lambda e: str(e), elements))
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<div %s>
%s
</div>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    ''' % (attr, content)
    return html
    
#+end_src

**** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup

def tags_from_html(html):
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # buscar el <div> que tiene la clase "diffusions-list"
    # dentro de ese <div> filtrar todos los <button> 
    # que tienen la clase =replay-button=
    yield tag

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/tags_from_html.py
from bs4 import BeautifulSoup

def tags_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    div = soup.find("div", class_="diffusions-list")
    if div:
        buttons = div.find_all("button", class_="replay-button")
        for tag in buttons:
            yield tag

def invalid_html(html):
    return "html parameter must be a string, received %s instead" % type(html)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un html que tiene un =<div>= con la clase buscada y que contiene varios =<button>= con la clase =replay-button=, devuelve un =GeneratorType= que tiene tantos elementos como =<button>= haya en el html
- Cuando recibe un html que no es un string, lanza un =AssertionError=
- Cuando recibe un html que no tiene ningún =<div>=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene varios =<div>= pero ninguno tiene la clase =rich-section-list-item-content=, devuelve un =GeneratorType= vacío
- Cuando recibe un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen, devuelve un =GeneratorType= con solamente los =<div>= que tienen la clase

#+begin_src python :tangle franceinter/episodes/tests/test_tags_from_html.py
import types
from franceinter.episodes.tags_from_html import tags_from_html
from franceinter.episodes.tests.examples_tags_from_html import *

def test_html_with_buttons():
    html = html_with_buttons(5)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 5)

def test_html_is_not_string():
    try:
        html = html_is_not_string()
        tags = list(tags_from_html(html))
    except AssertionError:
        assert True

def test_html_without_divs():
    html = html_without_divs()
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_divs_without_class():
    html = html_divs_without_class(4)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 0)

def test_some_buttons_with_class():
    html = html_some_buttons_with_class(2,3)
    tags = tags_from_html(html)
    assert isinstance(tags, types.GeneratorType)
    assert (len(list(tags)) == 2)

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_tags_from_html.py
#+end_src

*** episode_from_tag
**** 1. Objetivo

Obtener un episodio de un fragmento de html.

Un episodio tiene cuatro propiedades, a saber:

- título :: es un =str= y es obligatorio
- url :: es un =str=, es obligatorio y debe ser un URL válido
- fecha de emisión :: es un =str=, es obligatoria y debe ser una fecha válida en formato =YYYY-MM-DD=
- duración en segundos :: es un =int= y es obligatoria

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un objeto =franceinter.episodes.episode=

Necesitamos entonces definir la clase =episode=

#+begin_src python :tangle franceinter/episodes/episode.py

class Episode:
    def __init__(self, title, url, date, duration):
        self.title = title
        self.url = url
        self.date = date
        self.duration = duration

    def __repr__(self):
        return "Episode(title='%s', date='%s')" % (
            self.title, self.date
        )

#+end_src

**** 3. Ejemplos

- Un tag que tiene todos los elementos para generar un episodio válido (título, URL, fecha y duración)
- Un tag que no es un =bs4.element.Tag=
- Un tag que no tiene el elemento del título
- Un tag que no tiene el elemento del URL
- Un tag que no tiene el elemento de la fecha
- Un tag que no tiene el elemento de la duración
- Un tag que tiene el elemento del URL, pero el URL no es válido
- Un tag que tiene el elemento de la fecha, pero ésta no es válida
- Un tag que tiene el elemento de la duración, pero ésta no es válida

#+begin_src python :tangle franceinter/episodes/tests/examples_episode_from_tag.py
from bs4 import BeautifulSoup

def tag_ok():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def invalid_tag():
    return "I am not a tag"

def tag_without_title():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_url():
    html = '''<button class="replay-button playable"
            data-diffusion-title="Une année dans le monde"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_date():
    html = '''<button class="replay-button playable"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_duration():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_url():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="this://isnot[?=>avalid[[/\\url"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_date():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-mercredi-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="3256"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_duration():
    html = '''<button class="replay-button playable"
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"
            data-diffusion-title="Une année dans le monde"
            data-duration-seconds="forty minutes"
            data-is-aod="1"
            data-start-time="1549664208"
data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3"
data-xiti-level="4">'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def episode_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag

    # extraer el título con title_from_tag
    # validar que el título no sea un string vacío

    # extraer el url con url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer la fecha con date_from_tag
    # validar la fecha

    # extraer la duración con duration_from_tag
    # validar que la duración sea > 0

    # crear una instancia de franceinter.epidsodes.Episode
    # con el título, el url, la fecha y la duración
    return episode

#+end_src

**** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceinter/episodes/episode_from_tag.py
from franceinter.episodes.title_from_tag import title_from_tag
from franceinter.episodes.url_from_tag import url_from_tag
from franceinter.episodes.date_from_tag import date_from_tag
from franceinter.episodes.duration_from_tag import duration_from_tag
from franceinter.episodes.episode import Episode
from validators.url import url as is_valid_url
import datetime
import bs4

def episode_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = title_from_tag(tag)
    assert (title != ""), no_title(tag)

    url = url_from_tag(tag)
    assert (url != ""), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)

    date = date_from_tag(tag)
    assert (date != None), no_date(tag)

    duration = duration_from_tag(tag)
    assert (duration != 0), invalid_duration(tag)

    return Episode(title, url, date, duration)

def no_url(tag):
    return "received tag does not have an episode URL\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid episode URL\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have an episode title\n %s" % str(tag)

def no_date(tag):
    return "received tag does not have an episode publication date\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_duration(tag):
    return "received tag has an invalid duration\n %s" % str(tag)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, devuelve un episodio (=franceinter.episodes.Episode=)
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento del título, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento del URL, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento de la fecha, lanza un =AssertionError=
- Cuando recibe un tag que no tiene el elemento de la duración, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento del URL, pero el URL no es válido, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento de la fecha, pero ésta no es válida, lanza un =AssertionError=
- Cuando recibe un tag que tiene el elemento de la duración, pero ésta no es válida, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_episode_from_tag.py
from franceinter.episodes.episode import Episode
from franceinter.episodes.episode_from_tag import episode_from_tag
from franceinter.episodes.tests.examples_episode_from_tag import *

def test_episode_ok():
    tag = tag_ok()
    episode = episode_from_tag(tag)
    assert isinstance(episode, Episode)
    assert (len(str(episode)) > 0)

def test_tag_without_title():
    tag = tag_without_title()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_url():
    tag = tag_without_url()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_date():
    tag = tag_without_date()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_without_duration():
    tag = tag_without_duration()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_url():
    tag = tag_with_invalid_url()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_date():
    tag = tag_with_invalid_date()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_tag_with_invalid_duration():
    tag = tag_with_invalid_duration()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

def test_invalid_tag():
    tag = invalid_tag()
    try:
        episode = episode_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest franceinter/episodes/tests/test_episode_from_tag.py
#+end_src

*** title_from_tag
**** 1. Objetivo

Obtener el título de un episodio de un fragmento de HTML.

El título se puede obtener en dos lugares: 

- En el atributo =data-diffusion-title= de un =<button>= que tiene la clase =replay-button=
- En el atributo =title= de un =<a>= que tiene la clase =rich-section-list-item-content-title=

Elegimos sacarlo del button porque tiene todos los atributos que necesitamos obtener (titlulo, url, fecha y duración) en el mismo tag

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y el atributo =data-diffusion-title=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-diffusion-title=

#+begin_src python :tangle franceinter/episodes/tests/examples_title_from_tag.py
from bs4 import BeautifulSoup

def tag_with_title():
    html = '''<button class="replay-button" 
    data-diffusion-title="Sur les epaules de Darwin">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<p class="replay-button" 
    data-diffusion-title="Sur les epaules de Darwin">
</p>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.p
    return tag

def tag_without_class():
    html = '''<button data-diffusion-title="Sur les epaules de Darwin">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_title():
    html = '''<button class="replay-buttton"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def title_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    title = ""
    # validar que sea un <button>
    # validar que tenga la clase "replay-button"
    # revisar si tiene el atributo "data-diffusion-title"
    # si tiene el atributo se guarda en la variable title
    return title
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/title_from_tag.py
import bs4

def title_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = ""
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-diffusion-title" in tag.attrs):
        title = tag.attrs["data-diffusion-title"]
    return title

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y el atributo =data-diffusion-title=, devuelve el título
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve un string vacío
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve un string vacío
- Cuando recibe un =<button>= que no tiene el atributo =data-diffusion-title=, devuelve un string vacío

#+begin_src python :tangle franceinter/episodes/tests/test_title_from_tag.py
from franceinter.episodes.title_from_tag import title_from_tag
from franceinter.episodes.tests.examples_title_from_tag import *

def test_author_ok():
    tag = tag_with_title()
    assert ("Sur les epaules de Darwin" == title_from_tag(tag))

def test_invalid_tag():
    try:
        title_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert ("" == title_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == title_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == title_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_title_from_tag.py
#+end_src

*** url_from_tag
**** 1. Objetivo

Obtener el URL de descarga de un episodio a partir de un fragmento de html.

El URL se encuentra en el atributo =data-url= de un tag =<button>= que tiene la clase =replay-button=. 

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =str=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y un URL en el atributo =data-url=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-url=

#+begin_src python :tangle franceinter/episodes/tests/examples_url_from_tag.py
from bs4 import BeautifulSoup

def tag_with_url():
    html = '''<button class="replay-button" 
    data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_class():
    html = '''<button data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<a class="replay-button" 
    data-url="https://media.radiofrance-podcast.net/podcast09/11549-26.01.2019-ITEMA_21962401-0.mp3">
</a>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.a
    return tag

def tag_without_url():
    html = '''<button class="replay-button">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def url_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    url = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-url"
    # se guarda el valor del atributo en la variable url
    return url
    
#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/url_from_tag.py
import bs4

def url_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    url = ""
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-url" in tag.attrs):
        url = tag.attrs["data-url"]
    return url

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y un URL en el atributo =data-url=, devuelve el URL
- Cuando recibe un tag que no es un =bs4.element.Tag=, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve un string vacío
- Cuando recibe un tag =<button>= que no tiene la clase =replay-button=, devuelve un string vacío
- Cuando recibe un tag =<button>= que no tiene el atributo =data-url=, devuelve un string vacío

#+begin_src python :tangle franceinter/episodes/tests/test_url_from_tag.py
from franceinter.episodes.url_from_tag import url_from_tag
from franceinter.episodes.tests.examples_url_from_tag import *

def test_url_ok():
    tag = tag_with_url()
    assert (len(url_from_tag(tag)) > 0)

def test_invalid_url():
    try:
        url_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert ("" == url_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == url_from_tag(tag))

def test_url_not_found():
    tag = tag_without_url()
    assert ("" == url_from_tag(tag))

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_url_from_tag.py
#+end_src

*** date_from_tag
**** 1. Objetivo

Obtener la fecha de emisión de un episodio a partir de un fragmento de html.

La fecha de emisión se encuentra en el atributo =data-diffusion-path= de un tag =<button>= que tiene la clase =replay-button=. En ese atributo, la fecha se encuentra al final del path en formato =día-mes-año=, con el mes en palabras.

Ejemplo: ~data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019"~. 

Tenemos que extraer la fecha del path y devolverla como un =datetime.date=

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =datetime.date=

**** 3. Ejemplos

- Caso exitoso, un =<button>= con la clase =replay-button= y una fecha en el atributo =data-diffusion-path=
- Un tag que no es un =<button>=
- Un =<button>= que no tiene la clase =replay-button=
- Un =<button>= que no tiene el atributo =data-diffusion-path=

#+begin_src python :tangle franceinter/episodes/tests/examples_date_from_tag.py
from bs4 import BeautifulSoup

def tag_with_date():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_class():
    html = '''<button 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<a class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-janvier-2019">
</a>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.a
    return tag

def tag_without_date():
    html = '''<button class="replay-button">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

# la fecha es inválida porque el mes debe estar en francés
def tag_with_invalid_month():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-26-january-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

# la fecha es inválida porque el día es > 31
def tag_with_invalid_day():
    html = '''<button class="replay-button" 
data-diffusion-path="/emissions/sur-les-epaules-de-darwin/sur-les-epaules-de-darwin-42-janvier-2019">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def date_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    date = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-diffusion-path"
    # se guarda el valor del atributo en la variable attr

    # usar una expresión regular para extraer del atributo:
    # - dos números para el día [0-9] 
    # - seguidos de un guión
    # - seguido de una o más letras para el mes [a-z]
    # - seguidos de un guión
    # - seguidos de cuatro números para el año [0-9]
    # - seguidos del fin del string ($)

    # transformar el mes en números con una función auxiliar
    # crear el objeto datetime.date con el año, el día y el mes
    # validar la fecha
    
    return date
    
def month_from_name(month_name):
    # recibe el nombre (janvier, fevrier, etc)
    # y devuelve el número (1, 2, etc)
    return month_num

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/date_from_tag.py
import bs4
import re
import datetime

def date_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    date = None
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-diffusion-path" in tag.attrs):

        attr = tag.attrs["data-diffusion-path"]
        match = re.search("([0-9]{2})-([a-z]+)-([0-9]{4})$", attr)
        if match:
            try:
                date = datetime.date(
                    int(match.group(3)), 
                    month_from_name(match.group(2)), 
                    int(match.group(1))
                )
            except ValueError:
                assert False, invalid_date(match, tag)
    return date

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_date(date, tag):
    return "received tag has an invalid date [%s]\n %s" % (str(date), str(tag))

def month_from_name(month_name):
    try:
        return {
            'janvier': 1,
            'fevrier': 2,
            'mars': 3,
            'avril': 4,
            'mai': 5,
            'juin': 6,
            'juillet': 7,
            'aout': 8,
            'septembre': 9,
            'octobre': 10,
            'novembre': 11,
            'decembre': 12
        }[month_name]
    except KeyError:
        assert False, invalid_month(month_name)

def invalid_month(month_name):
    return "invalid month name, %s received" % month_name

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un =<button>= con la clase =replay-button= y una fecha en el atributo =data-diffusion-path=, devuelve la fecha
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe un tag que no es un =<button>=, devuelve =None=
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve =None=
- Cuando recibe un =<button>= que no tiene el atributo =data-diffusion-path=, devuelve =None=
- Cuando recibe un =<button>= que tiene una fecha inválida en el atributo =data-diffusion-path=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_date_from_tag.py
import datetime
from franceinter.episodes.date_from_tag import date_from_tag
from franceinter.episodes.tests.examples_date_from_tag import *

def test_url_ok():
    tag = tag_with_date()
    assert (datetime.date(2019, 1, 26) == date_from_tag(tag))

def test_invalid_tag():
    try:
        date_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert (None == date_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert (None == date_from_tag(tag))

def test_date_not_found():
    tag = tag_without_date()
    assert (None == date_from_tag(tag))

def test_invalid_month():
    tag = tag_with_invalid_month()
    try:
        date_from_tag(tag)
    except AssertionError:
        assert True

def test_invalid_day():
    tag = tag_with_invalid_day()
    try:
        date_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_date_from_tag.py
#+end_src

*** duration_from_tag
**** 1. Objetivo

Obtener la duración en segundos de un episodio a partir de un fragmento de html.

La duración se encuentra en el atributo =data-duration-seconds= de un tag =<button>= que tiene la clase =replay-button=. 

**** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =int=

**** 3. Ejemplos

- Caso exitoso, un tag =<button>= con la clase =replay-button= y una duración válida en el atributo =data-duration-seconds=
- Un tag que no es un =<button>=
- Un tag =<button>= que no tiene la clase =replay-button=
- Un tag =<button>= que no tiene el atributo =data-duration-seconds=
- Un tag =<button>= con la clase =replay-button= pero que no contiene un número entero en el atributo =data-duration-seconds=

#+begin_src python :tangle franceinter/episodes/tests/examples_duration_from_tag.py
from bs4 import BeautifulSoup

def tag_with_duration():
    html = '''<button class="replay-button" 
data-duration-seconds="3256">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_button():
    html = '''<p class="replay-button" 
data-duration-seconds="3256">
</p>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.p
    return tag

def tag_without_class():
    html = '''<button data-duration-seconds="3256"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_without_duration():
    html = '''<button class="replay-button"></button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

def tag_with_invalid_duration():
    html = '''<button class="replay-button" 
data-duration-seconds="six seconds">
</button>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.button
    return tag

#+end_src

**** 4. Boceto

#+begin_src python

def duration_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un integer
    duration = ""
    # si el tag es un <button>
    # y tiene la clase "replay-button"
    # y tiene el atributo "data-duration-seconds"
    # se guarda el valor del atributo en la variable duration

    # validar que la duración sea un número entero
    return duration

#+end_src

**** 5. Definición

#+begin_src python :tangle franceinter/episodes/duration_from_tag.py
import bs4

def duration_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    duration = 0
    if (tag.name == "button" 
        and "class" in tag.attrs 
        and "replay-button" in tag.attrs["class"]
        and "data-duration-seconds" in tag.attrs):

        value = tag.attrs["data-duration-seconds"]
        try:
            duration = int(value)
        except ValueError:
            assert False, invalid_duration(value, tag)
    return duration

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))

def invalid_duration(duration, tag):
    return "data-duration-seconds attribute must be int, received %s instead\n%s" % (str(type(duration)), tag)

#+end_src

**** 6. Casos de prueba

- Caso exitoso, cuando recibe un tag =<button>= con la clase =replay-button= y una duración válida en el atributo =data-duration-seconds=, devuelve la duración
- Cuando recibe un tag que no es un bs4.element.tag, lanza un =AssertionError=
- Cuando recibe tag que no es un =<button>=, devuelve =0=
- Cuando recibe un =<button>= que no tiene la clase =replay-button=, devuelve =0=
- Cuando recibe un =<button>= que no tiene el atributo =data-url=, devuelve =0=
- Cuando recibe un =<button>= con la clase =replay-button= pero que no contiene un número entero en el atributo =data-duration-seconds=, lanza un =AssertionError=

#+begin_src python :tangle franceinter/episodes/tests/test_duration_from_tag.py
from franceinter.episodes.duration_from_tag import duration_from_tag
from franceinter.episodes.tests.examples_duration_from_tag import *

def test_duration_ok():
    tag = tag_with_duration()
    assert (3256 == duration_from_tag(tag))

def test_invalid_url():
    try:
        duration_from_tag(5)
    except AssertionError:
        assert True

def test_button_not_found():
    tag = tag_without_button()
    assert (0 == duration_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert (0 == duration_from_tag(tag))

def test_duration_not_found():
    tag = tag_without_duration()
    assert (0 == duration_from_tag(tag))

def test_invalid_duration():
    tag = tag_with_invalid_duration()
    try:
        duration_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

***** Run tests

#+begin_src sh
pytest ./franceinter/episodes/tests/test_duration_from_tag.py
#+end_src

** HTML

Vamos a usar cURL para descargar el HTML de las diferentes páginas que necesitamos parsear, así podemos desarrollar y ejecutar los casos de prueba sin tener conexión a Internet. Guardamos los archivos en la carpeta =franceinter/html=.

#+begin_src sh
mkdir -p ./franceinter/html
curl -o ./franceinter/html/podcast-list.html https://www.franceinter.fr/emissions
head -n 1000 ./franceinter/html/podcast-list.html > franceinter/html/podcast-list-short.html
curl -o ./franceinter/html/episode-list.html https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin
curl -o ./franceinter/html/wrong-page.html https://www.pagina12.com.ar
ls -alh ./franceinter/html
#+end_src

#+RESULTS:
:results:
total 10968
drwxr-xr-x  5 martin  staff   160B Feb  8 17:18 .
drwxr-xr-x  7 martin  staff   224B Feb  8 17:18 ..
-rw-r--r--  1 martin  staff   276K Feb  8 17:18 episode-list.html
-rw-r--r--  1 martin  staff   4.1M Feb  8 17:18 podcast-list.html
-rw-r--r--  1 martin  staff    20K Feb  8 17:18 wrong-page.html
:end:

* Herramientas
** Módulos

#+begin_src python :tangle utils/__init__.py
__all__ = ["http_server"]
#+end_src

** LocalFolderHTTPServer

Para poder ejecutar los casos de prueba que realizan peticiones HTTP, necesitamos levantar un servidor HTTP desde una carpeta local.

https://stackoverflow.com/questions/39801718/how-to-run-a-http-server-which-serve-a-specific-path/46332163#46332163

#+begin_src python :tangle utils/http_server.py
import os
try:
    # python 2
    from SimpleHTTPServer import SimpleHTTPRequestHandler
    from BaseHTTPServer import HTTPServer as BaseHTTPServer
except ImportError:
    # python 3
    from http.server import HTTPServer as BaseHTTPServer, SimpleHTTPRequestHandler

class HTTPHandler(SimpleHTTPRequestHandler):
    """This handler uses server.base_path instead of always using os.getcwd()"""
    def translate_path(self, path):
        path = SimpleHTTPRequestHandler.translate_path(self, path)
        relpath = os.path.relpath(path, os.getcwd())
        fullpath = os.path.join(self.server.base_path, relpath)
        return fullpath

class LocalFolderHTTPServer(BaseHTTPServer):
    """The main server, you pass in base_path which is the path you want to serve requests from"""
    def __init__(self, base_path, server_address, RequestHandlerClass=HTTPHandler):
        self.base_path = base_path
        BaseHTTPServer.__init__(self, server_address, RequestHandlerClass)   
#+end_src

* Tests
** Ejecutar los casos de prueba

#+begin_src sh
pytest
#+end_src

** Generar el reporte de cobertura

#+begin_src sh
pytest --cov-report html:coverage --cov ./franceinter/ --cov ./sources/
#+end_src

Para visualizar el reporte se debe abrir el archivo =./coverage/index.html= con el navegador

#+begin_src sh
firefox --new-tab ./coverage/index.html
#+end_src

* Licencia

Voy a usar la licencia GPLv3 porque me interesa que los trabajos derivados de este proyecto, si los hubiera, se compartan con la comunidad.

** GPLv3

#+begin_src text
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.   
#+end_src

* Apéndices
*** listar podcasts

#+begin_src python :python python-3.6 :results drawer
import franceinter.podcasts_old as fr

podcasts = fr.podcasts_from_file('./downloads/emissions.html')
#podcasts = fr.podcasts_from_url('https://www.franceinter.fr/emissions')

#return list(podcasts)[39]
print(list(fr.podcast_search("darwin", podcasts)))
#+end_src

#+RESULTS:
:results:
[{'author': 'Jean Claude Ameisen', 'title': 'Sur les épaules de Darwin', 'url': 'https://franceinter.fr/emissions/sur-les-epaules-de-darwin'}]
:end:

*** implementación de referencia

#+begin_src python :python python-3.6 :results output
from bs4 import BeautifulSoup
from urllib.request import urlopen
import re

def slugify(string):
    return re.sub(r'[-\s]+', '-',
                  (re.sub(r'[^\w\s-]', '',string).strip().lower()))

def linkToDate(link):
    date = ""
    rd = re.search("([0-9]{2})-([a-z]+)-([0-9]{4})$", link)
    if rd:
        date = rd.group(3) + "-" + monthNumber(rd.group(2)) + "-" + rd.group(1)
    return date
        
def monthNumber(month):
    return {
        'janvier': "01",
        'fevrier': "02",
        'mars': "03",
        'avril': "04",
        'mai': "05",
        'juin': "06",
        'juillet': "07",
        'aout': "08",
        'septembre': "09",
        'octobre': "10",
        'novembre': "11",
        'decembre': "12"
    }[month]

    
r = urlopen('https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin?p=2').read()
soup = BeautifulSoup(r, "html.parser")
#print(soup.prettify())
buttons = soup.find_all("button", class_="replay-button")

for button in buttons:
    if "data-url" in button.attrs:
        #print(button.attrs)
        link = button.attrs["data-diffusion-path"]
        date = linkToDate(link)
        filename = date + "-" + slugify(button.attrs["data-diffusion-title"]) + ".mp3"
        #print(filename)
        print("curl -o " + filename + " " + button.attrs["data-url"])
        #print("")

#+end_src

#+RESULTS:
:results:
:end:

