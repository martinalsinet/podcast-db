#+TITLE: Podcast Database
#+AUTHOR: Martín Alsinet
#+DATE: 2019
#+PROPERTY: header-args:python :python python-3.6 :results output drawer :mkdirp yes
#+PROPERTY: header-args:sh :results raw drawer

* Motivación

Me gusta escuchar podcasts de [[https://franceinter.fr][France Inter]] cuando salgo a caminar, y en su momento me armé un script que me genera los links para descargar los episodios usando cURL.

Quiero mejorar ese script y transformarlo en una aplicación que me permita buscar podcasts, generar una base de datos con podcasts de distintas fuentes (p.ej. YouTube) y armar una cola de descargas.

Además, me gustaría usar este proyecto para probar dos enfoques de programación que me están interesando últimamente:

- [[http://www.literateprogramming.com/][Literate Programming]] :: Es una manera de programar en la que el código de la aplicación es un subproducto del documento que explica cómo está hecha

- [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]] :: En este libro se define una receta para la construcción de programas en forma iterativa usando el paradigma de programación funcional

** Literate Programming

Para escribir este documento estoy usando [[https://www.gnu.org/software/emacs][Emacs]] y [[https://orgmode.org][Org mode]], que es un modo de Emacs que tiene funcionalidades para literate programming.

La idea de la programación literaria consiste en que el código fuente de la aplicación sale de la documentación. Esto quiere decir que para poder generar un ejecutable (un /build/) de una aplicación hecha "literariamente" es necesario procesar la documentación, extraer de ella los fragmentos de código fuente que constituyen la aplicación (en org-mode este proceso se denomina /tangle/) y luego generar el ejecutable correspondiente con ese código.

En nuestro caso, la documentación a procesar es /este documento/. Todo el código fuente de la aplicación está contenido en este documento, dentro de los fragmentos de código delimitados por las etiquetas =#+begin_src= y =#+end_src=. Los bloques de código que tienen el parámetro =:tangle path/to/file= en el tag de inicio son exportados al archivo que indica el path. De esta manera, podemos generar todos los archivos del código fuente de la aplicación /tangleando/ la documentación. El comando =org-babel-tangle= dispara la generación de los archivos en cualquier momento.

El hecho de generar el código fuente desde este documento permite que no sea necesario guardarlo en el repositorio. Las carpetas con los fuentes de la aplicación se pueden agregar al archivo =.gitignore= sin problemas, dado que la fuente canónica del código se encuentra en este documento. Cada vez que es necesario ejecutar la aplicación, o generar un build para una versión determinada, se exporta el código desde este documento.

*** ¿Y qué hago si no sé (o no quiero) usar emacs?

Dado que el código fuente está en este documento, para poder obtener los fuentes es necesario procesarlo (tanglearlo) con emacs. Así, podemos extraer el código de la aplicación desde el documento y ejecutarlo como haríamos con cualquier otro programa. 

Vamos a usar [[https://www.docker.com/][Docker]] para bajar una imagen de Emacs y usar esa imagen para tanglear nuestro documento. 

#+begin_src sh :eval never
# descarga la imagen de emacs
docker pull silex/emacs:26-alpine

# lanza emacs en modo batch, 
# carga el archivo ./podcast-db.org del directorio actual,
# y ejecuta org-babel tangle
docker run --rm -i -v $(pwd):/app -w /app silex/emacs:26-alpine emacs --batch -l org podcast-db.org -f org-babel-tangle
#+end_src

Vemos que los fuentes se generan en la carpeta =franceinter=

#+begin_src sh :eval never
find ./franceinter
#+end_src

En teoría podríamos modificar el documento con otro editor de texto y regenerar los fuentes usando este método luego de editarlo, pero el procedimiento sería demasiado engorroso como para usarlo en la práctica.

** How to Design Programs

La otra fuente de inspiración para la metodología utilizada en este proyecto es el libro [[https://htdp.org/2018-01-06/Book/part_preface.html][How to Design Programs]]. Hay un video---[[https://media.ccc.de/v/35c3-9800-how_to_teach_programming_to_your_loved_ones][How to teach programming to your loved ones]]---en el que Mike Sperber explica la técnica utilizada para construir programas que se describe en el libro.

La idea es desarrollar una aplicación a partir de funciones elementales que se usan como piezas para ir armando componentes más complejos. El libro ofrece una receta para elaborar una función, que es la unidad mínima de código recomendada. Vamos a escribir cada una de las funciones de nuestra aplicación de acuerdo a los pasos de la siguiente receta:

- 1. Objetivo :: Identificar brevemente el propósito de la función. Nombrar las estructuras de datos que va a manipular
- 2. Firma :: Definir formalmente los parámetros de entrada y la salida de la función
- 3. Ejemplos :: Confeccionar un listado de ejemplos de parámetros de entrada que podría recibir la función y analizar cuál debería ser la salida para cada uno
- 4. Boceto :: Traducir la firma de la función en un boceto de la implementación
- 5. Definición :: Completar el boceto teniendo en cuenta el análisis y los ejemplos para lograr cumplir el propósito de la función
- 6. Casos de prueba :: Transformar los ejemplos en casos de prueba y asegurarse de que la función los pase a todos

En este caso, vamos a desarrollar nuestra aplicación en el lenguaje [[https://python.org][Python]] usando el paradigma de programación funcional. Esto quiere decir que nuestra aplicación va a estar mayormente compuesta de funciones (=def my_func():=) que vamos a ir combinando para realizar tareas complejas.

* Diseño
** Fuentes de podcasts

Quiero que mi base de datos pueda consultar las siguientes fuentes de podcasts:

- FranceInter
- FranceCulture
- RFI
- Youtube
- PBS
- BBC

** Funcionalidades

- Listar los podcasts de distintas fuentes
- Listar los episodios de un podcast
- Obtener el detalle de un episodio
- Filtrar los episodios según algún criterio (año, mes, palabra clave)
- Generar una playlist o feed RSS de los episodios filtrados
- Crear una cola de descarga a partir de una playlist
- Procesar los archivos descargados (p.ej, cambiar el bitrate a 64k)

* Implementación
** Setup
*** .gitignore

#+begin_src text :tangle .gitignore
.DS_Store
.pytest_cache
__pycache__
downloads
franceinter
requirements.txt
venv
#+end_src

*** Dependencias

Vamos a usar las siguientes bibliotecas

- requests :: Para realizar las peticiones http
- requests-cache :: Para cachear las peticiones http
- beautifulsoup4 :: Para parsear html
- slugify :: Para generar el nombre del archivo a descargar
- pytest :: Para ejecutar los casos de prueba
- validators :: Para validar URLs

*** requirements.txt

#+begin_src txt :tangle requirements.txt
beautifulsoup4
slugify
requests
requests-cache
pytest
validators
#+end_src

*** Instalación de dependencias
**** 1. Inicializar la carpeta =./venv=

#+begin_src sh
rm -Rf ./venv
virtualenv-3.6 ./venv
#+end_src

**** 2. Instalar dependencias con =pip=

#+begin_src sh
pip-3.6 install -r requirements.txt
#+end_src

** France Inter
*** Módulos

Vamos a organizar el código en paquetes (carpetas) que permiten usar namespaces para importar las funcionalidades. Para ello, necesitamos crear un archivo =__init__.py= en cada carpeta que tenga módulos para que python sepa cuáles son los módulos que forman parte del paquete y podamos usarlos en el =import=.

El módulo actual es =franceinter=, y que tiene los siguientes submódulos:

- podcasts
- episodes

#+begin_src python :tangle franceinter/__init__.py
__all__ = ["podcasts", "episodes"]
#+end_src

#+begin_src python :tangle franceinter/podcasts/__init__.py
__all__ = [
    "author_from_tag", 
    "title_from_tag", 
    "url_from_tag", 
    "podcast_from_tag", 
    "tags_from_html", 
    "podcasts_from_tags", 
    "podcast_search",
    "podcast"
]
#+end_src

#+begin_src python :tangle franceinter/podcasts/tests/__init__.py
__all__ = [
    "test_author_from_tag", 
    "test_title_from_tag", 
    "test_url_from_tag", 
    "test_podcast_from_tag", 
    "test_tags_from_html", 
    "test_podcasts_from_tags", 
    "test_podcast_search",
    "examples_author_from_tag", 
    "examples_title_from_tag",
    "examples_url_from_tag",
    "examples_podcast_from_tag",
    "examples_tags_from_html",
    "examples_podcasts_from_tags",
    "examples_podcast_search"
]
#+end_src

*** Podcasts

France Inter publica en una sola página (enorme) el listado de todas sus emisiones. El html está bastante fácil de parsear, dado que los datos cada emisión se encuentran dentro de un =div= con la clase =rich-section-list-item-content=. Revisando el contenido de ese div, podemos obtener el título del podcast, su URL y el autor (que es opcional).

En este submódulo se implementan las siguentes funcionalidades:

- Obtener el listado de los podcasts de France Inter
- Para cada podcast obtener el nombre, el url y el autor
- Filtrar el listado de podcasts por una palabra clave

**** title_from_tag
***** 1. Objetivo

Obtener el título del podcast de un fragmento de html.

El título se encuentra en el atributo =title= de un =<a>= que tiene la clase =rich-section-list-item-content-title=

***** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =string=

***** 3. Ejemplos

1. Caso exitoso, Un tag que contiene un =<a>= con la clase correcta y el atributo =title=
2. Un tag que no tiene el =<a>=
3. Un tag que tiene el =<a>= pero éste no tiene la clase =rich-section...=
4. Un tag que tiene el =<a>= pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_title_from_tag.py
from bs4 import BeautifulSoup

def tag_with_title():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    title="Sur les épaules de Darwin">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a title="Sur les épaules de Darwin">
</a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    title="Sur les épaules de Darwin">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title">
</p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

***** 4. Boceto

#+begin_src python

def author_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    title = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable title
    return title
    
#+end_src

***** 5. Definición

#+begin_src python :tangle franceinter/podcasts/title_from_tag.py
import bs4

def title_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "title" in link.attrs:
        title = link.attrs["title"]
    return title

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

***** 6. Casos de prueba

1. Caso exitoso, devuelve el título
2. El parámetro tag no es un bs4.element.tag, lanza un =AssertionError=
3. El tag no contiene un =<a>=, devuelve un string vacío
4. El tag tiene el =<a>= pero éste no tiene la clase correcta, devuelve un string vacío
5. El tag tiene el =<a>= pero éste no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_title_from_tag.py
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

def test_author_ok():
    tag = tag_with_title()
    assert ("Sur les épaules de Darwin" == title_from_tag(tag))

def test_invalid_tag():
    try:
        title_from_tag(5)
    except AssertionError:
        assert(True)

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == title_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == title_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == title_from_tag(tag))

#+end_src

#+begin_src python
from bs4 import BeautifulSoup
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.tests.examples_title_from_tag import *

tag = tag_with_title()
title = title_from_tag(tag)
print(title)
#+end_src

****** Run tests

#+begin_src sh :results output drawer
./pytest ./franceinter/podcasts/tests/test_title_from_tag.py
#+end_src

#+RESULTS:
:results:
:end:

**** url_from_tag
***** 1. Objetivo

Obtener el URL del podcast de un fragmento de html.

El URL se encuentra en el atributo =href= de un tag =<a>= que tiene la clase =rich-section-list-item-content-title=. 

El URL es relativo, por lo que hay que agregarle baseUrl de France Inter (https://www.franceinter.fr).

***** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un =string=

***** 3. Ejemplos

1. Caso exitoso, un tag que contiene un =<a>= con la clase =rich-section-list-item-content-title= y el atributo =href=
2. Un tag que no tiene el =<a>=
3. Un tag que tiene el =<a>= pero el link no tiene clase
4. Un tag que tiene el =<a>= pero el link no tiene el atributo =href=

#+begin_src python :tangle franceinter/podcasts/tests/examples_url_from_tag.py
from bs4 import BeautifulSoup

def tag_with_url():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<p class="rich-section-list-item-content-title" 
    href="emissions/la-tete-au-carre">
</p>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_class():
    html = '''<div>
<p>Lorem ipsum</p>
<a href="emissions/la-tete-au-carre"></a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_href():
    html = '''<div>
<p>Lorem ipsum</p>
<a class="rich-section-list-item-content-title">
</a>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

***** 4. Boceto

#+begin_src python

def url_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    url = ""
    # hay que buscar un <a> con la clase "rich-section-list-item-content-title"
    # si existe el <a> hay que revisar si tiene el atributo href
    # si tiene el atributo href 
    #     - se le agrega "https://www.franceinter.fr/" adelante
    #     - se guarda en la variable url
    return url
    
#+end_src

***** 5. Definición

#+begin_src python :tangle franceinter/podcasts/url_from_tag.py
import bs4

def url_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    url = ""
    cls = "rich-section-list-item-content-title"
    link = tag.find("a", class_=cls)
    if link and "href" in link.attrs:
        url = "https://www.franceinter.fr/" + link.attrs["href"]
    return url

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

***** 6. Casos de prueba

1. Caso exitoso, devuelve el url
2. El tag no es un bs4.element.tag, lanza un =AssertionError=
3. El tag no contiene un =<a>=, devuelve un string vacío
4. El tag tiene el =<a>= pero éste no tiene la clase buscada, devuelve un string vacío
5. El tag tiene el =<a>= pero éste no tiene el atributo =href=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_url_from_tag.py
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.tests.examples_url_from_tag import *

def test_url_ok():
    tag = tag_with_url()
    url = "https://www.franceinter.fr/emissions/la-tete-au-carre"
    assert (url == url_from_tag(tag))

def test_invalid_tag():
    try:
        url_from_tag(5)
    except AssertionError:
        assert(True)

def test_link_not_found():
    tag = tag_without_link()
    assert ("" == url_from_tag(tag))

def test_class_not_found():
    tag = tag_without_class()
    assert ("" == url_from_tag(tag))

def test_title_not_found():
    tag = tag_without_href()
    assert ("" == url_from_tag(tag))

#+end_src

****** Run tests

#+begin_src sh :results output drawer
./pytest ./franceinter/podcasts/tests/test_url_from_tag.py
#+end_src

**** author_from_tag
***** 1. Objetivo

Obtener el autor del podcast de un fragmento de html. 

El autor se encuentra en el atributo =title= de un =<a>= que está dentro de un =<span>= que tiene la clase =rich-section-list-item-content-infos-author=

***** 2. Firma

La funcion recibe un objeto =bs4.element.Tag= y devuelve un =string=

***** 3. Ejemplos

1. Caso exitoso, el tag tiene un =<span>= con la clase =rich-section-list-item-content-infos-author= que contiene un =<a>= con el atributo =title=
2. El tag no tiene un =<span>=
3. El tag tiene un =<span>=, pero éste no tiene un =<a>=
4. El tag tiene un =<span>= que contiene un =<a>=, pero éste no tiene el atributo =title=

#+begin_src python :tangle franceinter/podcasts/tests/examples_author_from_tag.py
from bs4 import BeautifulSoup

def tag_with_author():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a title="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_span():
    html = '''<div class="boldest">
Extremely bold
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_link():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<p title="William Shakespeare"></p>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_title():
    html = '''<div>
<p>Lorem ipsum</p>
<span class="rich-section-list-item-content-infos-author">
<a subtitle="William Shakespeare"></a>
</span>
    </div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

#+RESULTS:
:results:
True
:end:

***** 4. Boceto

#+begin_src python

def author_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag
    # devuelve un string
    author = ""
    # hay que buscar un span con la clase "rich-section..."
    # si existe el span hay que buscar un a
    # si existe el a hay que revisar si tiene el atributo title
    # si tiene el atributo title se guarda en la variable author
    return author
    
#+end_src

#+RESULTS:
:results:
None
:end:

***** 5. Definición

#+begin_src python :tangle franceinter/podcasts/author_from_tag.py
import bs4

def author_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    cls = "rich-section-list-item-content-infos-author"
    span = tag.find("span", class_=cls)
    author = ""
    if span:
        link = span.find("a")
        if link and "title" in link.attrs:
            author = link.attrs["title"]
    return author

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

***** 6. Casos de prueba

1. Caso exitoso, devuelve el autor
2. El parámetro tag no es un bs4.element.tag, lanza un =AssertionError=
3. El tag no tiene un tag =<span>= con la clase buscada, devuelve un string vacío
4. El tag tiene el =<span>= pero éste no contiene un =<a>=, devuelve un string vacío
5. El tag tiene el =<span>= y el =<a>= pero éste último no tiene el atributo =title=, devuelve un string vacío

#+begin_src python :tangle franceinter/podcasts/tests/test_author_from_tag.py
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.tests.examples_author_from_tag import *

def test_author_ok():
    tag = tag_with_author()
    assert ("William Shakespeare" == author_from_tag(tag))

def test_invalid_tag():
    try:
        author_from_tag(5)
    except AssertionError:
        assert True

def test_span_not_found():
    tag = tag_without_span()
    assert ("" == author_from_tag(tag))

def test_a_not_found():
    tag = tag_without_link()
    assert ("" == author_from_tag(tag))

def test_title_not_found():
    tag = tag_without_title()
    assert ("" == author_from_tag(tag))

#+end_src

#+RESULTS:
:results:
None
:end:

****** Run tests

#+begin_src sh :results output drawer
./pytest franceinter/podcasts/tests/test_author_from_tag.py
#+end_src

#+RESULTS:
:results:
============================= test session starts ==============================
platform linux -- Python 3.6.8, pytest-4.2.0, py-1.7.0, pluggy-0.8.1
rootdir: /app, inifile:
collected 5 items

franceinter/podcasts/tests/test_author_from_tag.py .....                 [100%]

=========================== 5 passed in 0.30 seconds ===========================
:end:

**** podcast_from_tag
***** 1. Objetivo

Obtener un podcast de un fragmento de html.

Un podcast tiene tres propiedades, a saber:

- título :: es un =string= y es obligatorio
- url :: es un =string=, es obligatorio y debe ser un URL válido
- autor :: es un =string=, pero puede estar vacío

***** 2. Firma

La función recibe un objeto =bs4.element.Tag= y devuelve un objeto =franceinter.podcasts.podcast=

Necesitamos entonces definir la clase =podcast=

#+begin_src python :tangle franceinter/podcasts/podcast.py

class Podcast:
    def __init__(self, title, url, author=""):
        self.title = title
        self.url = url
        self.author = author

    def __repr__(self):
        return "Podcast(title='%s', url='%s')" % (self.title, self.url)

#+end_src

***** 3. Ejemplos

1. Un tag que tiene todos los elementos para generar un podcast válido (título, URL y autor)
2. Un tag que no es un =bs4.element.Tag=
3. Un tag que no tiene el elemento del título
4. Un tag que no tiene el elemento del URL
5. Un tag que tiene el elemento del URL, pero el URL no es válido
6. Un tag que no tiene el elemento del autor

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcast_from_tag.py
from bs4 import BeautifulSoup

def tag_ok():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def invalid_tag():
    return "I am not a tag"

def tag_without_title():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_with_invalid_url():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="this://isnot[?=>avalid[[/\\url"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
        Par <a href="personnes/patrick-liegibel" title="Patrick Liegibel">Patrick Liegibel</a>
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

def tag_without_author():
    html = '''<div class="rich-section-list-item-content">
  <div class="rich-section-list-item-content-show">
    <header>
      <div>
        <a href="emissions/au-fil-de-l-histoire"
           itemprop="name"
           title="Au fil de l&#039;histoire"
           class="rich-section-list-item-content-title">
          Au fil de l&#039;histoire
        </a>
      </div>
    </header>
    <div class="rich-section-list-item-content-infos">
      <span class="rich-section-list-item-content-infos-author">
      </span>
    </div>
  </div>
</div>'''
    soup = BeautifulSoup(html, "html.parser")
    tag = soup.div
    return tag

#+end_src

***** 4. Boceto

#+begin_src python

def podcast_from_tag(tag):
    # validar que el tag sea un bs4.element.Tag

    # extraer el título con title_from_tag
    # validar que el autor no sea un string vacío

    # extraer el url con url_from_tag
    # validar que el url no sea un string vacío
    # validar el url

    # extraer el autor usando author_from_tag

    # crear una instancia de franceinter.podcasts.podcast
    # con el título, el url y el autor
    return podcast

#+end_src

***** 5. Definición

Usamos la biblioteca [[https://validators.readthedocs.io/][validators]] para validar el URL del podcast

#+begin_src python :tangle franceinter/podcasts/podcast_from_tag.py
from franceinter.podcasts.title_from_tag import title_from_tag
from franceinter.podcasts.url_from_tag import url_from_tag
from franceinter.podcasts.author_from_tag import author_from_tag
from franceinter.podcasts.podcast import Podcast
from validators.url import url as is_valid_url
import bs4

def podcast_from_tag(tag):
    assert isinstance(tag, bs4.element.Tag), invalid_tag(tag)
    title = title_from_tag(tag)
    assert (title != ""), no_title(tag)

    url = url_from_tag(tag)
    assert (url != ""), no_url(tag)
    assert is_valid_url(url), invalid_url(tag)

    author = author_from_tag(tag)

    return Podcast(title, url, author)


def no_title(tag):
    return "received tag does not have a podcast title\n %s" % str(tag)

def no_url(tag):
    return "received tag does not have a podcast url\n %s" % str(tag)

def invalid_url(tag):
    return "received tag has an invalid podcast url\n %s" % str(tag)

def no_title(tag):
    return "received tag does not have a podcast title\n %s" % str(tag)

def invalid_tag(tag):
    return "tag parameter must be an instance of bs4.element.Tag, received %s instead" % str(type(tag))
#+end_src

***** 6. Casos de prueba

1. Caso exitoso, devuelve un podcast
2. El tag no es un =bs4.element.Tag=, lanza un =AssertionError=
3. El tag no tiene título, lanza un =AssertionError=
4. El tag no tiene url, lanza un =AssertionError=
5. El tag tiene un url pero es inválido, lanza un =AssertionError=
6. El tag no tiene autor, devuelve un podcast con un =string= vacío en la propiedad author

#+begin_src python :tangle franceinter/podcasts/tests/test_podcast_from_tag.py
from franceinter.podcasts import podcast
from franceinter.podcasts.podcast_from_tag import podcast_from_tag
from franceinter.podcasts.tests.examples_podcast_from_tag import *

def test_podcast_ok():
    tag = tag_ok()
    podcast = podcast_from_tag(tag)
    assert len(podcast.title)>0
    assert len(podcast.url)>0
    assert len(podcast.author)>0

def test_podcast_without_title():
    tag = tag_without_title()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_url():
    tag = tag_without_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_with_invalid_url():
    tag = tag_with_invalid_url()
    try:
        podcast = podcast_from_tag(tag)
    except AssertionError:
        assert True

def test_podcast_without_author():
    tag = tag_without_author()
    podcast = podcast_from_tag(tag)
    assert len(podcast.title) > 0
    assert len(podcast.url) > 0
    assert len(podcast.author) == 0

def test_invalid_tag():
    tag = invalid_tag()
    try:
        podcast_from_tag(tag)
    except AssertionError:
        assert True

#+end_src

#+RESULTS:
:results:
:end:

#+begin_src sh
pytest ./franceinter/podcasts/tests/test_podcast_from_tag.py
#+end_src

#+RESULTS:
:results:
============================= test session starts ==============================
platform linux -- Python 3.6.8, pytest-4.2.0, py-1.7.0, pluggy-0.8.1
rootdir: /app, inifile:
collected 5 items

franceinter/podcasts/tests/test_podcast_from_tag.py .....                [100%]

=========================== 5 passed in 0.52 seconds ===========================
:end:

**** tags_from_html
***** 1. Objetivo

Obtener un array de tags con el fragmento de html que tiene el detalle del podcast (título, URL y autor) a partir del html de la página con el listado de podcasts

Hay que extraer todos los =<div>= que tengan la clase =rich-section-list-item-content=

***** 2. Firma

La función recibe un =string= con el html de la página y devuelve una lista de elementos =bs4.element.Tag=

***** 3. Ejemplos

1. Un html que tiene varios =<div>= con la clase buscada
2. Un html que no es un =string=
3. Un html que no tiene ningún =<div>=
4. Un html que tiene varios =<div>= pero que ninguno tenga la clase =rich-section-list-item-content=
5. Un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen

#+begin_src python :tangle franceinter/podcasts/tests/examples_tags_from_html.py
from bs4 import BeautifulSoup
from random import shuffle

def html_with_divs(how_many):
    class_name = "rich-section-list-item-content"
    divs = map(lambda x: div(class_name), range(how_many))
    return html(divs)

def html_is_not_string():
    return 42

def html_without_divs():
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>'''
    return html

def html_divs_without_class(how_many):
    divs = map(lambda x: div(), range(how_many))
    return html(divs)

def html_some_divs_with_class(how_many_with, how_many_without):
    class_name = "rich-section-list-item-content"
    divs_with = list(map(lambda x: div(class_name), range(how_many_with)))
    divs_without = list(map(lambda x: div(), range(how_many_without)))
    divs = divs_with + divs_without
    shuffle(divs)
    return html(divs)

def div(class_name=""):
    attr = ""
    if class_name:
        attr = "class=%s" % class_name
    html = '''<div %s>
    here goes the div body
</div>''' % attr
    soup = BeautifulSoup(html, "html.parser")
    return soup.div

def html(divs):
    div_str = "".join(map(lambda div: str(div), divs))
    html = '''<header><h1>dummy title</h1></header>
<p>bla bla bla</p>
%s
<ul>
  <li> item 1 </li>
  <li> item 2 </li>
</ul>
<footer>All rights reserved!</footer>
    ''' % div_str
    return html
    
#+end_src

***** 4. Boceto

#+begin_src python
from bs4 import BeautifulSoup

def tags_from_html(html):
    # validar que el html sea un string
    tags = []
    # instanciar un objeto BeautifulSoup
    # filtrar los tag <div> que tienen la clase "rich-section-list-item-content"
    return tags

#+end_src

***** 5. Definición

#+begin_src python :tangle franceinter/podcasts/tags_from_html.py
from bs4 import BeautifulSoup

def tags_from_html(html):
    assert isinstance(html, str), invalid_html(html)
    soup = BeautifulSoup(html, "html.parser")
    cls = "rich-section-list-item-content"
    tags = soup.find_all("div", class_=cls)
    return tags

def invalid_html(html):
    return "html parameter must be a string, received %s instead" % type(html)

#+end_src

***** 6. Casos de prueba

1. Caso exitoso, cuando recibe un html que tiene varios =<div>= con la clase buscada, devuelve una lista de tantos elementos como =<div>= hay en el html
2. Cuando recibe un html que no es un string, lanza un =AssertionError=
3. Cuando recibe un html que no tiene ningún =<div>=, devuelve una lista vacía
4. Cuando recibe un html que tiene varios =<div>= pero ninguno tiene la clase =rich-section-list-item-content=, devuelve una lista vacía
5. Cuando recibe un html que tiene algunos =<div>= con la clase buscada y otros que no la tienen, devuelve una lista con solamente los =<div>= que tienen la clase

#+begin_src python :tangle franceinter/podcasts/tests/test_tags_from_html.py
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *

def test_html_with_divs():
    html = html_with_divs(5)
    tags = tags_from_html(html)
    assert (len(tags) == 5)

def test_html_is_not_string():
    try:
        html = html_is_not_string()
        tags = tags_from_html(33)
    except AssertionError:
        assert True

def test_html_without_divs():
    html = html_without_divs()
    tags = tags_from_html(html)
    assert (len(tags) == 0)

def test_divs_without_class():
    html = html_divs_without_class(4)
    tags = tags_from_html(html)
    assert (len(tags) == 0)

def test_some_divs_with_class():
    html = html_some_divs_with_class(2,3)
    tags = tags_from_html(html)
    assert (len(tags) == 2)

#+end_src

**** podcasts_from_tags
***** 1. Objetivo

Generar un listado de podcasts a partir de un listado de fragmentos de HTML tomados de la página

***** 2. Firma

La función recibe un listado de objetos =bs4.element.Tag= y devuelve un listado de objetos =franceinter.podcasts.Podcast=

***** 3. Ejemplos

1. Un objeto que no es un =list=
2. Una lista vacía
3. Una lista con tags válidos
4. Una lista con objetos que no son del tipo =bs4.element.Tag=
5. Una lista con tags válidos y un tag inválido (sin el título o el URL)

#+begin_src python :tangle franceinter/podcasts/tests/examples_podcasts_from_tags.py
from franceinter.podcasts.tags_from_html import tags_from_html
from franceinter.podcasts.tests.examples_tags_from_html import *
from franceinter.podcasts.tests.examples_podcast_from_tag import (
    tag_ok, 
    tag_without_url
)

def invalid_list():
    return "I am not a list"

def empty_list():
    return []

def list_without_tags():
    return [1, 2, 3, 4, 5]

def list_with_valid_tags(how_many):
    html = ""
    for item in range(1, how_many):
        html+= str(tag_ok())
    tags = tags_from_html(html)
    return tags

def list_with_invalid_tag(how_many):
    html = list_with_valid_tags(how_many - 1)
    html+= str(tag_without_url())
    tags = tags_from_html(html)
    return tags

#+end_src

***** 4. Boceto

#+begin_src python
from franceinter.podcasts.tags_from_html import tags_from_html

def podcasts_from_tags(tags):
    # validar que tags sea una lista
    # para cada tag de la lista
    # usar podcast_from_tag() para obtener un podcast
    # yield posdcast

#+end_src

***** 5. Definición

#+begin_src python :tangle franceinter/podcasts/podcasts_from_tags.py
from franceinter.podcasts.podcast_from_tag import podcast_from_tag

def podcasts_from_tags(tags):
    assert isinstance(tags, list), invalid_tags(tags)
    for tag in tags:
        yield podcast_from_tag(tag)

def invalid_tags(tags):
    return "tags parameter must be a list, received %s instead" % type(tags)
#+end_src

***** 6. Casos de prueba

1. Si recibe un objeto que no es un =list=, lanza un =AssertionError=
2. Si recibe una lista vacía, devuelve una lista vacía
3. Si recibe una lista de tags válidos, devuelve una lista de objetos =franceinter.podcasts.Podcast=
4. Si recibe una lista con objetos que no son del tipo =bs4.element.Tag=, lanza un =AssertionError=
5. Si recibe una lista con algún tag inválido (que no tenga el título o el URL), lanza un =AssertionError=

#+begin_src python :tangle franceinter/podcasts/tests/test_podcasts_from_tags.py
from franceinter.podcasts.podcasts_from_tags import podcasts_from_tags
from franceinter.podcasts.tests.examples_podcasts_from_tags import *
from franceinter.podcasts.podcast import Podcast

def test_invalid_list():
    tags = invalid_list()
    try:
        podcasts = list(podcasts_from_tags(tags))
    except AssertionError:
        assert True

def test_empty_list():
    tags = empty_list()
    podcasts = list(podcasts_from_tags(tags))
    assert (len(podcasts)==0)

def test_list_with_valid_tags():
    tags = list_with_valid_tags(6)
    podcasts = podcasts_from_tags(tags)
    for p in podcasts:
        assert (isinstance(p, Podcast))

def test_list_without_tags():
    tags = list_without_tags()
    try:
        podcasts = podcasts_from_tags(tags)
    except AssertionError:
        assert True

def test_list_with_invalid_tag():
    tags = list_with_valid_tags(6)
    podcasts = podcasts_from_tags(tags)
    try:
        for p in podcasts:
            assert (isinstance(p, Podcast))
    except AssertionError:
        assert True

#+end_src

**** TODO podcasts_from_file
***** 1. Objetivo
***** 2. Firma
***** 3. Ejemplos
***** 4. Boceto
***** 5. Definición
***** 6. Casos de prueba
**** TODO podcasts_from_url
***** 1. Objetivo
***** 2. Firma
***** 3. Ejemplos
***** 4. Boceto
***** 5. Definición
***** 6. Casos de prueba
**** TODO podcast_search
***** 1. Objetivo
***** 2. Firma
***** 3. Ejemplos
***** 4. Boceto
***** 5. Definición
***** 6. Casos de prueba
**** Implementación completa

#+begin_src python :tangle franceinter/podcasts_old.py 
from bs4 import BeautifulSoup
from urllib.request import urlopen
import re

def div_author(div):
    cls = "rich-section-list-item-content-infos-author"
    span = div.find("span", class_=cls)
    author = ''
    if span:
        author = span.find("a").attrs["title"]
    return author

def div_title(div):
    cls = "rich-section-list-item-content-title"
    link = div.find("a", class_=cls)
    title = ''
    if link:
        title = link.attrs["title"]
    return title

def div_href(div):
    cls = "rich-section-list-item-content-title"
    link = div.find("a", class_=cls)
    href = ''
    if link:
        href = "https://franceinter.fr/" + link.attrs["href"]
    return href

def div_to_podcast(div):
    return {
        'author': div_author(div),
        'title': div_title(div),
        'url': div_href(div)
    }

def divs(html):
    soup = BeautifulSoup(html, "html.parser")
    cls = "rich-section-list-item-content"
    return soup.find_all("div", class_=cls)

def podcasts():
    for div in divs():
        yield div_to_podcast(div)

def podcasts_from_file(filename):
    with open(filename) as html:
        for div in divs(html.read()):
            yield div_to_podcast(div)

def podcasts_from_url(url):
    with urlopen(url) as html:
        for div in divs(html.read()):
            yield div_to_podcast(div)

def podcast_search(query, podcasts):
    return filter(lambda p: re.search(query, p["title"], re.IGNORECASE) 
                  or re.search(query, p["author"], re.IGNORECASE), 
                  podcasts)

#+end_src

*** Episodios

En el URL de un podcast vemos el listado de los últimos episodios disponibles. Al final del listado hay un selector de páginas para acceder al historial de episodios. Para poder obtener el historial completo necesitamos la cantidad de páginas, que está en un tag ~<li>~ que tiene la clase =last=. Una vez que tengamos la cantidad de páginas podemos obtener el listado de episodios, parseando cada una de las páginas del historial.

#+begin_src python :tangle franceinter/episodes.py
from bs4 import BeautifulSoup
from urllib.request import urlopen
from franceinter import podcasts as p
import re

def lastpage_from_filename(filename):
    with open(filename) as html:
        soup = BeautifulSoup(html, "html.parser")
        lastpage = 1
        item = soup.find("li", class_="last")
        if item:
            href = item.find("a").attrs["href"]
            match = re.search("([0-9]+)$", href)
            if match:
                lastpage = int(match.groups()[0])
        return lastpage

def page_list(podcast):
    lastpage = lastpage_from_filename("episodes.html")
    for pagenum in range(1, lastpage+1):
        yield podcast["url"] + "?p=" + str(pagenum)

#return lastpage_from_filename("episodes.html")

podcasts = p.podcasts_from_file('emissions.html')
darwin = list(p.podcast_search("darwin", podcasts))[0]

return list(page_list(darwin))
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src sh
#curl -o episodes.html https://franceinter.fr/emissions/sur-les-epaules-de-darwin
#ls -alh *.html
cat episodes.html | grep "pager-item"
#+end_src

#+RESULTS:
:results:
                                    <li class="pager-item active">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                    <li class="pager-item">
                                                                            <li class="pager-item show-hidden">
                                        <li class="pager-item next">
                    <li class="pager-item last">
                            <li class="pager-item">
:end:

** test
*** shell

#+begin_src sh
ls -alh ./franceinter
#+end_src

#+RESULTS:
:results:
total 16
drwxr-xr-x   5 martin  staff   160B Feb  3 12:19 .
drwxr-xr-x  19 martin  staff   608B Feb  3 12:22 ..
-rw-r--r--   1 martin  staff    23B Feb  3 12:18 __init__.py
drwxr-xr-x   4 martin  staff   128B Feb  3 12:19 __pycache__
-rw-r--r--   1 martin  staff   1.5K Feb  3 12:18 podcasts.py
:end:

*** listar podcasts

#+begin_src python :python python-3.6 :results drawer
import franceinter.podcasts_old as fr

podcasts = fr.podcasts_from_file('./downloads/emissions.html')
#podcasts = fr.podcasts_from_url('https://www.franceinter.fr/emissions')

#return list(podcasts)[39]
print(list(fr.podcast_search("darwin", podcasts)))
#+end_src

#+RESULTS:
:results:
[{'author': 'Jean Claude Ameisen', 'title': 'Sur les épaules de Darwin', 'url': 'https://franceinter.fr/emissions/sur-les-epaules-de-darwin'}]
:end:

*** implementación anterior

#+begin_src python :python python-3.6 :results output
from bs4 import BeautifulSoup
from urllib.request import urlopen
import re

def slugify(string):
    return re.sub(r'[-\s]+', '-',
                  (re.sub(r'[^\w\s-]', '',string).strip().lower()))

def linkToDate(link):
    date = ""
    rd = re.search("([0-9]{2})-([a-z]+)-([0-9]{4})$", link)
    if rd:
        date = rd.group(3) + "-" + monthNumber(rd.group(2)) + "-" + rd.group(1)
    return date
        
def monthNumber(month):
    return {
        'janvier': "01",
        'fevrier': "02",
        'mars': "03",
        'avril': "04",
        'mai': "05",
        'juin': "06",
        'juillet': "07",
        'aout': "08",
        'septembre': "09",
        'octobre': "10",
        'novembre': "11",
        'decembre': "12"
    }[month]

    
r = urlopen('https://www.franceinter.fr/emissions/sur-les-epaules-de-darwin?p=2').read()
soup = BeautifulSoup(r, "html.parser")
#print(soup.prettify())
buttons = soup.find_all("button", class_="replay-button")

for button in buttons:
    if "data-url" in button.attrs:
        #print(button.attrs)
        link = button.attrs["data-diffusion-path"]
        date = linkToDate(link)
        filename = date + "-" + slugify(button.attrs["data-diffusion-title"]) + ".mp3"
        #print(filename)
        print("curl -o " + filename + " " + button.attrs["data-url"])
        #print("")

#+end_src

#+RESULTS:
:results:
:end:

